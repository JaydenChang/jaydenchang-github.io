<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jayden&#39;s Blog</title>
  
  
  <link href="https://jaydenchang.top/atom.xml" rel="self"/>
  
  <link href="https://jaydenchang.top/"/>
  <updated>2022-01-30T01:59:08.111Z</updated>
  <id>https://jaydenchang.top/</id>
  
  <author>
    <name>Jayden Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>To 脆弱zn 的一封信</title>
    <link href="https://jaydenchang.top/post/To_zn.html"/>
    <id>https://jaydenchang.top/post/To_zn.html</id>
    <published>2022-01-30T16:00:00.000Z</published>
    <updated>2022-01-30T01:59:08.111Z</updated>
    
    <content type="html"><![CDATA[<p>那就再祝你一次新年快乐叭！</p><p>当我在打这一段文字时，我已做好了心理准备。<del>(这篇文章我第二天就会撤掉)</del></p><p>考虑了很久，我想，我是时候该做出决定了，那敞开心扉说吧。在很久之前，我就已经有预想过这个结果了，女生的心，也确实如你所说，我不懂，也猜不透。感情这东西很微妙，喜欢就是喜欢，不喜欢就是不喜欢，如果你是后者，那，我也无话可说。我知道我这样做，以后都可能做不成普通朋友了，但我这次只表达个心意，至于结果，希望不会影响你以后的学习生活。</p><p>算起来，这应该是我人生中真正意义上第一次追求女孩子，也是第一次被拒绝。认识了四个月了，最开始对你没什么感觉，emm，一个很活泼很健谈的女孩，也许是国庆期间的那几次对话，知道了你过去的经历后，对你也有了更深的了解，我渐渐发现了喜欢运动的女孩身上独有的气质，一种说不出的开朗。和你聊天也挺有意思的，原来女生也可以这么话痨(暴露了以前没怎么和女生玩)，也意外知道你的性格有几分敏感(从把你pyq中秋的照片设为私有就能看出来)，之前你说我给你留下了稍微深刻的印象，我内心os：”就这，挺多人知道我的”，后面知道原来是摆摊那次，说实话，那次我没有留意你们宿舍三人，只隐约觉得其中一个女生还挺好看<del>(这个我忘了是谁了，好像是邱[这个就别🔪我了])</del>，因为害羞，看美女看多我就会脸红，我没多看，给完钱马上溜了。</p><p>不知何时起，我开始对你有好感，貌似是十月中旬开始的吧。忘了十月的某一天，悉知你获得了国励后，我看了看我自己，顿时有了自卑心理<del>(希望以后大家不要自卑心理了ww)</del>，我决定开始痛改前非，我应该有和你说过，我有点好胜心，也许是不太喜欢数学，这学期绩点依旧拉跨，于是前几天又开始自卑了，但我知道，这不是我应有的状态，所以我在微博放完垃圾话后，马上调整回来。</p><p>这三个月的值班，我很珍惜每一次和你下班回去的机会，后面不知道怎么的，脑子抽了，竟然选择去吹比赛。当然也很珍惜每一次和你聊天的机会，和你聊天也学到了挺多东西的(人生观，爱情观以及其他的)，也许是我还没尝试过恋爱是什么滋味吧，中间有一段日子，我开始患得患失，理智告诉我不能这么做，我死党及时疏导我，我也开始阅读一些心理学相关的书籍，渐渐的我感觉，我的敏感，貌似好一些了，但还是会在某个晚上翻来覆去，后面想，越分析越难顶，于是干脆放下包袱，想聊就聊吧，放松点，也不去知乎上乱查了，把更多精力放在自己身上，当然，这也算一种成长吧。</p><p>关于我，其实你应该早就知道我对你有好感了，但我想说，如果面对一个对你有好感的男生，而你对他没什么感觉的话，我个人认为，你应该及时释放信号，让这男生渐渐死了这条心，这样，对他也算是一种解脱吧(如果男生对你没感觉另说 [狗头]) (或许，我这样做也有欠缺，我还要不断学习如何和异性相处)。我的话，在这段关系里面，感觉前期没有把重心放在自己身上吧，从十二月中旬开始，我们彼此都没找对方(估计也就剩微博了)，让我开始冷静下来，我过去好像有点迷失了，毕竟大一下就是这样挂科的。</p><p>有人说，喜欢听纯音乐的人是心思很细腻的人，我感觉也是，不然也不会偶尔在微博分享纯音乐，也不会间歇性失眠了；喜欢杰伦的人，都会去模仿这个酷酷的大男孩，每首歌，都有一段伴着她的独家记忆(关于你的记忆，我也会封存在杰伦的歌里)，杰伦的情歌，或许在未来的某个日子你会爱上 [狗头]；杰伦曾说过，”学音乐的孩子是不会变坏的，因为他们有情绪的抒发管道”，emm，我个人认为，我人不算坏，做的坏事不算多，在我的社交圈里，感觉大家还是挺认同我的吧。</p><p>我还记得你有一次问我，你是不是渣女这个话题，我感觉的话，正常的朋友关系里，大家都表现挺正常的，其实还是得看你在恋爱中是什么表现，你也说过，你有点讨好型人格，我觉得吧，或许，那时的你太敏感了，对方没给够安全感，产生这种感觉，大概率是聊天记录引起的。既然都说到这里了，那我也放开说了，我高三那次，感觉，和你差不多，我喜欢那个女生，在疫情时期，醒着的15个小时，她占据了我一半的时间，我去督促学习，指导学习，我死党提醒我，我陷得有点深了，xs，我也提醒他，但是两人都一样陷进去了，最后两人几乎在同一个时间失恋，走了一晚上操场才走出来。现在看来的话，高三的我就是舔dog，从我带学习开始，这段关系就有点变味了，之前我部门学姐也谈过一次恋爱，我学姐陷得有点深，竟去帮那男生做作业，当然，最后两人吵架了，绩点也拉了，就后面我想，或许适合我的恋爱，应该是三观对的上，两人相互独立，双向奔赴。高三的我，完全没有做到真正爱自己，没有把更多精力放在自己身上，前几天和死党在江边散步时聊到这个话题，他说，或许她喜欢那个男生更多一点，不然就是我了，我记得我好像和你说过，经历过才知道怎么去珍惜未来的，我感觉，这句话只在感情经历在一定次数一下的情况成立 [狗头]，但u1s1，每次经历过，被伤害过，都会让自己变得温柔 (又想起了那段经历呜呜呜)。</p><p>总的来说，还是很高兴认识你的，你是一个很好的女孩，心思挺细腻的，很善良(这都是真心话)。你也不用有太多的包袱，我不会做出什么过激的行为，以前该咋地就该咋地，你告诉我的一些小秘密(感觉也不算秘密吧)，我也会藏在心底。本来的话，我还是只想和你做朋友的，一直默默喜欢你，只是，我觉得，喜欢那么久了，并且也过年了，喜欢就勇敢说出来，不说出来总会在青春里留下遗憾，说出来我也无悔了，释然了。也许多年以后回望我们这段经历，或许会不约而同感叹：”年轻真好” 吧。</p><img src='https://jaydenchang.gitee.io/images/images/temp.jpg' style="zoom:80%;" ><p>一些周杰伦的歌词<del>(字好丑呜呜)</del>，代表了我的青春，其中最想送你的是《明明就》，不过我估计你也不会去听，如果听不惯国语，那再送一首粤语的，Hins的《俏郎君》。</p><p>2022，我也会多拍照，我也会不间断在微博上更新，当然了，我也不会找个晚上私发些好看的照片找你了聊天了哈哈哈哈。</p><p>如果有来生，另一个时空的我如果有机会遇到另一个时空的你，我还是会选择认识你，还是会选择喜欢你，还是会选择勇敢的说出来<del>(这里没有想不开的意思)</del>。</p><p>woc，居然写了2k的字，论文写这个类型的话题我绝对满绩 <del>(不是满寄)</del>。</p><p>最后，很感谢你，在我的青春出现过，(如果以后我邀请你来我的婚礼你会来吗哈哈哈哈)，我也会渐渐淡出你的世界。祝你我在未来，都能在对的时间，对的地点，遇到对的人。</p><p align='right'>Jayden Chang</p><p align='right'>2022.1.31</p>]]></content>
    
    
    <summary type="html">一些想说的话，希望不会破环你的过年好心情，不会打扰你的学习、生活</summary>
    
    
    
    <category term="none" scheme="https://jaydenchang.top/categories/none/"/>
    
    
    <category term="none" scheme="https://jaydenchang.top/tags/none/"/>
    
  </entry>
  
  <entry>
    <title>win10找回Ubuntu启动项(非EasyBCD)</title>
    <link href="https://jaydenchang.top/post/0x002B.html"/>
    <id>https://jaydenchang.top/post/0x002B.html</id>
    <published>2022-01-12T16:00:00.000Z</published>
    <updated>2022-01-13T04:04:41.513Z</updated>
    
    <content type="html"><![CDATA[<p>最近想对装在电脑上的Ubuntu进行更新，但是之前在BIOS里改了引导系统的文件，导致找不到Ubuntu启动项，EasyBCD程序也不起作用(整块硬盘Windows分区都是GPT，改BIOS也没什么用)，在必应上逛了两天找到了一个解决方法，在Windows下用命令行修改引导文件</p><p>打开管理员命令行(不是<u><strong>powershell</strong></u>)，输入以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mountvol g: &#x2F;sg:cd EFIbcdedit &#x2F;set &#123;bootmgr&#125; path \EFI\ubuntu\grubx64.efi</code></pre><p>这时候重启，开机就会进入grub菜单</p><p>如果想改回Windows引导，则最后一行命令改为</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bcdedit &#x2F;set &#123;bootmgr&#125; path \EFI\Microsoft\Boot\bootmgfw.efi</code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://linux.cn/article-4667-1.html">桌面应用|Windows和Ubuntu双系统，修复UEFI引导的两种办法 (linux.cn)</a></p>]]></content>
    
    
    <summary type="html">不进入BIOS的情况下找回Ubuntu启动项</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="Linux" scheme="https://jaydenchang.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>不关闭SELinux情况下使用ftp传输</title>
    <link href="https://jaydenchang.top/post/0x002A.html"/>
    <id>https://jaydenchang.top/post/0x002A.html</id>
    <published>2022-01-03T16:00:00.000Z</published>
    <updated>2022-01-03T08:43:52.196Z</updated>
    
    <content type="html"><![CDATA[<p>在做搭建ftp服务器的作业时，整了一个活，在不关闭SELinux的情况下测试ftp服务器</p><p>使用的环境，虚拟机*2 (CentOS 7)，Hyper-v，网卡已设为静态</p><p>需要安装的软件包：</p><ul><li><p>服务器(下称server)：</p><ul><li><p>vsftpd</p></li><li><p>ftp</p></li><li><p>ip可自定义，此处设为192.168.4.5</p></li></ul></li></ul><ul><li><p>客户机(下称client)：</p><ul><li><p>ftp</p></li><li><p>ip这里设为192.168.4.205</p></li></ul></li></ul><h4 id="修改vsftpd配置"><a href="#修改vsftpd配置" class="headerlink" title="修改vsftpd配置"></a>修改vsftpd配置</h4><p>进入目录<code>/etc/vsftpd</code>，编辑<code>vsftpd.conf</code>，在最后一行添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">listen_port&#x3D;21</code></pre><h4 id="防火墙添加信任"><a href="#防火墙添加信任" class="headerlink" title="防火墙添加信任"></a>防火墙添加信任</h4><p>然后在防火墙里允许特定ip访问特定端口(作业里要访问的ip是<code>192.168.4.205</code>)</p><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --permanent --add-rich-rule&#x3D;&quot;rule family&#x3D;&quot;ipv4&quot; source address&#x3D;&quot;192.168.4.205&quot; port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;21&quot; accept&quot;</code></pre><p>向客户机开放21端口</p><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --reload</code></pre><p>重新载入防火墙</p><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --zone&#x3D;public --list-rich-rules</code></pre><p>查看开放的端口</p><p>如果显示防火墙未启动，可以运行命令启动防火墙</p><pre class="line-numbers language-none"><code class="language-none">systemctl start firewalld</code></pre><h4 id="客户机测试"><a href="#客户机测试" class="headerlink" title="客户机测试"></a>客户机测试</h4><p>连接服务器</p><pre class="line-numbers language-none"><code class="language-none">ftp 192.168.4.5</code></pre><p>当显示<code>ftp&gt;</code>时，输入<code>ls</code>或者<code>pwd</code>查看当前位置时，又出现了一个bug，显示<code>no route to host</code>，</p><p>这时候再回到服务器，修改<code>/etc/sysconfig/</code>下的<code>iptables-config</code>，更改其中<code>IPTABLES_MODULES=&quot;&quot;</code>项为</p><pre class="line-numbers language-none"><code class="language-none">IPTABLES_MODULES&#x3D;&quot;ip_nat_ftp ip_conntrack_ftp&quot;</code></pre><p>然后重启防火墙相关服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart iptables.service</code></pre><p>如果服务器重启后，客户机ftp连接服务器还出现<code>no route to host</code>的情况，以此输入以下命令开启相关防火墙服务</p><pre class="line-numbers language-none"><code class="language-none">systemctl start firewalldsystemctl start iptables.service</code></pre><p>如果仅是临时使用，可以运行以下两条命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">modprobe ip_nat_ftpmodprobe ip_conntrack_ftp</code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/u012906135/article/details/69944485">ftp connect: No route to host 解决方案_hello world!-CSDN博客</a></p><p><a href="https://www.jianshu.com/p/4801d9dbaa84">Linux防火墙firewall只允许特定ip访问 - 简书 (jianshu.com)</a></p>]]></content>
    
    
    <summary type="html">两台Linux服务器不关闭SELinux进行ftp传输</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="Linux" scheme="https://jaydenchang.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-图及最小生成树</title>
    <link href="https://jaydenchang.top/post/0x0029.html"/>
    <id>https://jaydenchang.top/post/0x0029.html</id>
    <published>2021-12-08T16:00:00.000Z</published>
    <updated>2021-12-11T06:08:25.654Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更了 <del>其实摸鱼摸太久了</del>，当然也是最近太多事，一直没有时间去打理博客，趁着周末有空，来整理下图部分的内容</p><p>这里来总结下无向图、最小生成树(prim和Dijkstra)算法</p><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 到后面发现，visited在无向图中设计的是真的巧妙template &lt;class DataType&gt;class MGraph &#123;    public:      MGraph(DataType a[], int n, int e); &#x2F;&#x2F; 构造函数，构造有n个顶点e条边的图     ~MGraph() &#123;&#125;     void DFS(int); &#x2F;&#x2F; 深搜     void BFS(int); &#x2F;&#x2F; 广搜        private:     DataType vertex[maxSize]; &#x2F;&#x2F; 存放图中顶点的数组     int edge[maxSize][maxSize]; &#x2F;&#x2F; 存放图中边的数组     int vertexNum, edgeNum; &#x2F;&#x2F; 图中的顶点数和变数&#125;;</code></pre><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, k;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i]; &#x2F;&#x2F; 储存顶点    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            edge[i][j] &#x3D; 0; &#x2F;&#x2F; 初始化邻接矩阵        &#125;    &#125;    for (k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cin &gt;&gt; i &gt;&gt; j; &#x2F;&#x2F; 以此输入每条边依附的两个顶点的编号        edge[i][j] &#x3D; 1; &#x2F;&#x2F; 对输入的边做标记(无向图，双向标记)        edge[j][i] &#x3D; 1;    &#125;&#125;</code></pre><h5 id="广搜和深搜"><a href="#广搜和深搜" class="headerlink" title="广搜和深搜"></a>广搜和深搜</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;        if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0)             DFS(j);        &#x2F;&#x2F; 递归的妙处会在后面讲到    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int w, j, queue[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; queue数组记录的是访问矩阵第几行的顺序    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        visited[i] &#x3D; 0;    &#125;    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;;    MGraph&lt;char&gt; MG(ch, 6, 6);    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS order: \n&quot;;    MG.DFS(0);    cout &lt;&lt; &quot;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;;    cout &lt;&lt; &quot;BFS order: \n&quot;;    MG.BFS(0);&#125;</code></pre><h5 id="测试用例及其邻接矩阵"><a href="#测试用例及其邻接矩阵" class="headerlink" title="测试用例及其邻接矩阵"></a>测试用例及其邻接矩阵</h5><p>测试数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0 10 20 51 21 43 4</code></pre><p>邻接矩阵</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0 1 2 3 4 5 0&#39;   1 1     1 &#39;1&#39; 1   1   1   &#39;2&#39; 1 1         &#39;3&#39;         1   &#39;4&#39;   1   1     &#39; 5&#39; 1           &#39;&#x2F;&#x2F; 以横轴为x，竖轴为y       </code></pre><p>借用这个样例来说一下深搜和广搜</p><h6 id="深搜"><a href="#深搜" class="headerlink" title="深搜"></a>深搜</h6><p>已知无向图的邻接矩阵是关于对角线对称的，深搜从第一行开始搜索，搜索到<code>(1,0)</code>时进入递归，进入递归后，首先对<code>visited[v]</code>进行标记，通过观察可以知道，上一轮DFS传入的j和下一轮DFS的v在矩阵中关于对角线对称 <del>好像是个无用信息</del>，每一轮DFS的<code>visited[v]=1</code>就是为了避免重复访问<code>vertex[v]</code>，再加上那条if语句的配合，即可无重复遍历完整个图</p><h6 id="广搜"><a href="#广搜" class="headerlink" title="广搜"></a>广搜</h6><p>广搜的话其实还是要自己画出一个无向图来并且在debug模式运行一遍才知道大概是怎么个流程。对上面的测试用例来说，在第一轮搜索时，访问的都是和0号这个点有通路的点，第二轮是1号，第三轮是2号，依此类推。如果把最开始输入的0号放在中间，后面输入的数据一圈圈和0号联通，产生关联，那么广搜可以理解为，从搜寻点一圈圈向外扩散找</p><h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;class MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);        private:     int vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, k;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            edge[i][j] &#x3D; 0;        &#125;    &#125;    for (k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cin &gt;&gt; i &gt;&gt; j;        edge[i][j] &#x3D; 1;        edge[j][i] &#x3D; 1;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;        if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0)            DFS(j);    &#125;&#125;template &lt;class DateType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int w, j, queue[maxSize] &#x3D; &#123;0&#125;;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        visited[i] &#x3D; 0;    &#125;    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;;    int i;    MGraph&lt;char&gt; MG(ch, 6, 6);    for (i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS order: \n&quot;;    MG.DFS(0);    cout &lt;&lt; &quot;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;;    cout &lt;&lt; &quot;BFS order: \n&quot;;    MG.BFS(0);&#125;</code></pre><h4 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h4><h5 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;class MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);     void Prim(int);     int minEdge(int[], int);        private:     DataType vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;</code></pre><h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, w &#x3D; 0;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                 edge[i][j] &#x3D; 0; &#x2F;&#x2F; 这里忽略自环            else                edge[i][j] &#x3D; 100;            &#x2F;&#x2F; 这里初始化权值，赋比较大的数即可        &#125;    &#125;    for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cout &lt;&lt; &quot;input two points of the edge: &quot;;        cin &gt;&gt; i &gt;&gt; j;        cout &lt;&lt; &quot;input the weight of the edge: &quot; ;        cin &gt;&gt; w;        edge[i][j] &#x3D; w;        edge[j][i] &#x3D; w;    &#125;&#125;</code></pre><h5 id="prim代码实现"><a href="#prim代码实现" class="headerlink" title="prim代码实现"></a>prim代码实现</h5><p>将图中顶点（V）分两部分，最小生成树的点集为U，其余顶点在集合（V-U）</p><ul><li><ol><li>首先任取一个点作为起点</li></ol></li><li><ol start="2"><li>在V-U中找和起点之间权值最小的边</li></ol></li><li><ol start="3"><li>adjVex记录上一轮找最小值的位置，cost记录到各顶点的距离</li></ol></li><li><ol start="4"><li>然后上一轮找到的权值最小的边的另一个点作为起点，不断重复步骤2，3</li></ol></li></ul><h6 id="找到最小值位置"><a href="#找到最小值位置" class="headerlink" title="找到最小值位置"></a>找到最小值位置</h6><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;int MGraph&lt;DataType&gt;::minEdge(int r[], int n) &#123;    int index;    int min &#x3D; 100; &#x2F;&#x2F; 图中all权值最大不超过100    for (int i &#x3D; 0; i &lt; n; i++) &#123;        if (r[i] !&#x3D; 0 &amp;&amp; r[i] &lt; min) &#123;            min &#x3D; r[i];            index &#x3D; i;        &#125;    &#125;    return index; &#x2F;&#x2F; 返回最小值在数组中的位置&#125;</code></pre><h6 id="prim核心代码"><a href="#prim核心代码" class="headerlink" title="prim核心代码"></a>prim核心代码</h6><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Prim(int v) &#123;    int adjVex[maxSize], cost[maxSize];    int i, j, k;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        &#x2F;&#x2F; 通过起点对adjVex，cost数组初始化        cost[i] &#x3D; edge[v][i];        adjVex[i] &#x3D; v;        &#x2F;&#x2F; 将起点所有有联通的点都录入cost中，找权值最小的边(类似BFS)    &#125;    cost[v] &#x3D; 0; &#x2F;&#x2F; 将顶点加入u中    for (k &#x3D; 1; k &lt; vertexNum; k++) &#123;        j &#x3D; minEdge(cost, vertexNum); &#x2F;&#x2F; 在cost数组找最小值        &#x2F;&#x2F; cout &lt;&lt; &#39;(&#39; &lt;&lt; adjVex[j] &lt;&lt; &#39;,&#39; &lt;&lt; j &lt;&lt; &#39;)&#39; &lt;&lt; cost[j] &lt;&lt; endl; &#x2F;&#x2F; 输出的是点的序号        cout &lt;&lt; &#39;(&#39; &lt;&lt; vertex[j] &lt;&lt; &#39;,&#39; &lt;&lt; vertex[adjVex[j]] &lt;&lt; &#39;)&#39; &lt;&lt; cost[j] &lt;&lt; endl;  &#x2F;&#x2F; 输出的是字符        &#x2F;&#x2F; 输出生成最小生成树的过程(都是输出上一轮查找结果)        cost[j] &#x3D; 0; &#x2F;&#x2F; 将最小值的点加入U中(清零当前最小值的权值，防止后面重复遍历)        for (int p &#x3D; 0; p &lt; vertexNum; p++) &#123;            &#x2F;&#x2F; 这一步，是以第j号为起点，不断寻找和j号联通的最小权值的路线            if (edge[p][j] &lt; cost[p]) &#123;                &#x2F;&#x2F; 从所有与当前最小值临界点出发找到最小值点权值最小的                cost[p] &#x3D; edge[p][j];                adjVex[p] &#x3D; j; &#x2F;&#x2F; 记录新加入顶点上一轮迭代的最小值的位置            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="测试用例及邻接矩阵"><a href="#测试用例及邻接矩阵" class="headerlink" title="测试用例及邻接矩阵"></a>测试用例及邻接矩阵</h5><pre class="line-numbers language-none"><code class="language-none">0 1340 2460 5191 4122 3172 5253 4383 5254 526</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0  1  2  3  4  5 0&#39;    34 46       19 &#39;1&#39; 34          12    &#39;2&#39; 46       17    25 &#39;3&#39;       17    38    &#39;4&#39;    12    38    26 &#39; 5&#39; 19    25    26    &#39;&#x2F;&#x2F; 以横轴为x，竖轴为y       </code></pre><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><h5 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 到后面发现，visited在无向图中设计的是真的巧妙template &lt;class DataType&gt;class MGraph &#123;    public:      MGraph(DataType a[], int n, int e); &#x2F;&#x2F; 构造函数，构造有n个顶点e条边的图     ~MGraph() &#123;&#125;     void DFS(int); &#x2F;&#x2F; 深搜     void BFS(int); &#x2F;&#x2F; 广搜        private:     DataType vertex[maxSize]; &#x2F;&#x2F; 存放图中顶点的数组     int edge[maxSize][maxSize]; &#x2F;&#x2F; 存放图中边的数组     int vertexNum, edgeNum; &#x2F;&#x2F; 图中的顶点数和变数&#125;;</code></pre><h5 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    vertexNum &#x3D; e, edgeNum &#x3D; n;    int i, j, w &#x3D; 0;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                 edge[i][j] &#x3D; 0;            else                edge[i][j] &#x3D; 100;        &#125;        for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;            cout &lt;&lt; &quot;input two vertexes of the edge: &quot;;            cin &gt;&gt; i &gt;&gt; j;            cout &lt;&lt; &quot;input the weight of the edge: &quot;;            cin &gt;&gt; w;            edge[i][j] &#x3D; w;        &#125;    &#125;&#125;</code></pre><h5 id="深搜和广搜"><a href="#深搜和广搜" class="headerlink" title="深搜和广搜"></a>深搜和广搜</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        if (edge[v][i] &lt; 100 &amp;&amp; visited[i] &#x3D;&#x3D; 0)             DFS(i);    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int queue[maxSize];    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &lt; 100 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[v];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; 1;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="Dijkstra-1"><a href="#Dijkstra-1" class="headerlink" title="Dijkstra"></a>Dijkstra</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Dijkstra(MGraph&lt;DataType&gt; mg, int v) &#123;    int dist[maxSize];    &#x2F;&#x2F; dist为起点到各个点的距离，具有临时性    string path[maxSize];    string vertex(mg.vertex);    for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;        dist[i] &#x3D; mg.edge[v][i];        &#x2F;&#x2F; 初始化dist数组，0号顶点到其余各顶点的初始路程        if (dist[i] !&#x3D; 100) &#123;            path[i] +&#x3D; vertex[v];            path[i] +&#x3D; vertex[i];            &#x2F;&#x2F; 这里是记录起点可以直达的路径        &#125; else &#123;            path[i] &#x3D; &quot;&quot;;        &#125;    &#125;    dist[v] &#x3D; 0;    int num &#x3D; 1;    while (num &lt; mg.vertexNum) &#123;        int min &#x3D; 255, k &#x3D; 0; &#x2F;&#x2F; 每一轮重置最小值        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (dist[i] !&#x3D; 0 &amp;&amp; dist[i] &lt; min) &#123;                min &#x3D; dist[i];                k &#x3D; i;                &#x2F;&#x2F; 找最小值            &#125;        &#125;        &#x2F;&#x2F; cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; dist[k] &lt;&lt; &quot;;\n&quot;;        num++; &#x2F;&#x2F; 标记这是第几个被访问的点        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (dist[i] &gt; dist[k] + mg.edge[k][i]) &#123;                dist[i] &#x3D; dist[k] + mg.edge[k][i];                path[i] &#x3D; &quot;&quot;; &#x2F;&#x2F; 重置路径                path[i] +&#x3D; path[k]; &#x2F;&#x2F; 加上之前走过的路                path[i] +&#x3D; vertex[i];            &#125;        &#125;        cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; dist[k] &lt;&lt; &quot;;\n&quot;;        dist[k] &#x3D; 0;    &#125;&#125;</code></pre><h5 id="测试用例及邻接矩阵-1"><a href="#测试用例及邻接矩阵-1" class="headerlink" title="测试用例及邻接矩阵"></a>测试用例及邻接矩阵</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0 1100 3300 41001 2502 4103 2203 460</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0   1   2   3   40          1&#39; 10                 &#39;2&#39;     50      20     &#39;3&#39; 30                 &#39;4&#39; 100     10  60     &#39;&#x2F;&#x2F; 横轴为x，竖轴为y       </code></pre><h5 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;struct MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);     void Dijkstra(MGraph&lt;DataType&gt;, int);        private:     DataType vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, w &#x3D; 0;    vertexNum &#x3D; n, edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                edge[i][j] &#x3D; 0;            else                edge[i][j] &#x3D; 100;        &#125;    &#125;    for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cout &lt;&lt; &quot;input two vertexes of the edge: &quot;;        cin &gt;&gt; i &gt;&gt; j;        cout &lt;&lt; &quot;input the weight of the edge: &quot;;        cin &gt;&gt; w;        edge[i][j] &#x3D; w;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        if (edge[v][i] &lt; 100 &amp;&amp; visited[i] &#x3D;&#x3D; 0)            DFS(i);    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int queue[maxSize];    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &lt; 100 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Dijkstra(MGraph&lt;DataType&gt; mg, int v) &#123;    int distance[maxSize];    string path[maxSize];    string vertex(mg.vertex);    for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;        distance[i] &#x3D; mg.edge[v][i];        if (dist[i] !&#x3D; 100) &#123;            path[i] +&#x3D; vertex[v];            path[i] +&#x3D; vertex[i];        &#125; else &#123;            path[i] &#x3D; &quot;&quot;;        &#125;    &#125;    distance[v] &#x3D; 0;    int num &#x3D; 1;    while (num &lt; mg.vertexNum) &#123;        int min &#x3D; 100, k &#x3D; 0;        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (distance[i] !&#x3D; 0 &amp;&amp; distance[i] &lt; min) &#123;                min &#x3D; distance[i];                k &#x3D; i;            &#125;        &#125;        num++;        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (distance[i] &gt; distance[k] + mg.edge[v][i]) &#123;                distance[i] &#x3D; distance[i] + mg.edge[k][i];                path[i] &#x3D; &quot;&quot;;                path[i] +&#x3D; path[k];                path[i] +&#x3D; vertex[i];            &#125;        &#125;        cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; distance[k] &lt;&lt; &quot;;\n&quot;;        distance[k] &#x3D; 0;    &#125;&#125;int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;&#125;;    MGraph&lt;char&gt; mg(ch, 5, 7);    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS: &quot;;    mg.DFS(0);    cout &lt;&lt; endl;    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;BFS: &quot;;    mg.BFS(0);    cout &lt;&lt; &quot;the short path: \n&quot;;    mg.Dijkstra(mg, 0);&#125;</code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/zgsdlr/article/details/121426826">【数据结构】最小生成树Prim算法_zgsdlr的博客-CSDN博客_ java求最小生成树</a></p>]]></content>
    
    
    <summary type="html">填坑系列之图，整理了数据结构无向图、最小生成树(Prim和Dijkstra)</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--哈夫曼树与哈夫曼编码</title>
    <link href="https://jaydenchang.top/post/0x0028.html"/>
    <id>https://jaydenchang.top/post/0x0028.html</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2021-12-11T10:14:34.545Z</updated>
    
    <content type="html"><![CDATA[<p>填坑系列之哈夫曼树</p><p>刚开始看哈夫曼树时有点懵懵的，加权是啥子玩意，后面查阅资料后才明白，哈夫曼树以及哈夫曼编码多用在压缩编码中，再配合二倍速食用B站大学的网课，算是把整个算法过了一遍</p><h4 id="the-main-structure"><a href="#the-main-structure" class="headerlink" title="the main structure"></a>the main structure</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int Max &#x3D; 1000;char **HuffmanCode;typedef struct Node &#123;    int weight;    int parent, left, right;&#125; HTNode, *HuffmanTree;</code></pre><h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><p>select是来选择剩余结点中权值最小的两颗二叉树(包括新构造的树)的左右子树来构建一个新的二叉树，新根节点权值为其左右子树根节点的权值之和</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Select(HuffmanTree ht, int k, int&amp; id1, int&amp; id2) &#123;    long min1, min2;    min1 &#x3D; min2 &#x3D; 99999; &#x2F;&#x2F; 不能太小    for (int i &#x3D; 0;i &lt; k;i++) &#123;        if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min1 &gt; ht[i].weight) &#123;            &#x2F;&#x2F; 选择无双亲的结点            if (min1 &lt; min2) &#123;                 &#x2F;&#x2F; 这里是比大小的操作，规定min1为小                min2 &#x3D; min1;                id2 &#x3D; id1;            &#125;            min1 &#x3D; ht[i].weight; &#x2F;&#x2F; 这个操作可以把这k个数据都遍历一遍，可以选出两个最小的结点            id1 &#x3D; i;        &#125; else if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min2 &gt; ht[i].weight) &#123;            min2 &#x3D; ht[i].weight;            id2 &#x3D; i;        &#125;    &#125;&#125;</code></pre><h4 id="Create-a-Huffman-Tree"><a href="#Create-a-Huffman-Tree" class="headerlink" title="Create a Huffman Tree"></a>Create a Huffman Tree</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HuffmanTree(huffTree &amp;ht, int n) &#123;    int m &#x3D; n * 2 - 1;    int id1, id2;    int i;    if (n &lt; 0) &#x2F;&#x2F; 创建空树        return;    ht &#x3D; new Node[m];    for (i &#x3D; 0;i &lt; m;i++) &#123;        ht[i].parent &#x3D; ht[i].left &#x3D; ht[i].right &#x3D; -1;        &#x2F;&#x2F; 初始化各节点    &#125;    for (i &#x3D; 0;i &lt; n;i++) &#123;        cin &gt;&gt; ht[i].weight; &#x2F;&#x2F; 输入各个结点的权值    &#125;    for (i &#x3D; n;i &lt; m;i++) &#123;        Select(ht, i, id1, id2);        &#x2F;&#x2F; 在n个结点中选择俩无双亲的结点且权值最小的结点        ht[id1].parent &#x3D; ht[id2].parent &#x3D; i;        &#x2F;&#x2F; 获得id1，id2，把第i个结点设为它俩的双亲        ht[i].left &#x3D; id1;        ht[i].right &#x3D; id2; &#x2F;&#x2F; 设第i个结点的左右孩子为id1，id2        ht[i].weight &#x3D; ht[id1].weight + ht[id2].weight;    &#125;&#125;</code></pre><h4 id="destroy-a-Huffman-Tree"><a href="#destroy-a-Huffman-Tree" class="headerlink" title="destroy a Huffman Tree"></a>destroy a Huffman Tree</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Destroy(HuffmanTree &amp;ht) &#123;    delete[] ht;    ht &#x3D; NULL;&#125;</code></pre><h4 id="create-the-Huffman-Code"><a href="#create-the-Huffman-Code" class="headerlink" title="create the Huffman Code"></a>create the Huffman Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void createHuffmanCode(HuffmanTree ht, HuffmanCode &amp;hc, int n) &#123;    int start;    int cur, f;    hc &#x3D; new char *[n + 1];    char *cd &#x3D; new char[n];    cd[n - 1] &#x3D; &#39;\0&#39;;    for (i &#x3D; 0;i &lt; n;i++) &#123;        start &#x3D; n - 1;         cur &#x3D; i; &#x2F;&#x2F; 当前结点在数组中的位置        f &#x3D; hf[i].parent; &#x2F;&#x2F; 当前结点的父节点在数组的位置        while (f !&#x3D; 0) &#123;            &#x2F;&#x2F; 如果该结点是父节点的左孩子则对应编码为0，否则右孩子为1            start--;            if (hf[f].left &#x3D;&#x3D; cur)                cd[start] &#x3D; &#39;0&#39;;            else                 cd[start] &#x3D; &#39;1&#39;;            &#x2F;&#x2F; 以父节点为孩子结点，继续朝树根的方向遍历            cur &#x3D; f;            f &#x3D; hf[f].parent;        &#125;        &#x2F;&#x2F; 跳出循环后，cd数组中从下标start开始，存放的就是该结点的哈夫曼编码        hc[i] &#x3D; new char[n - start];        strcpy(hc[i], &amp;cd[start]);    &#125;    delete cd;&#125;</code></pre><h4 id="the-code"><a href="#the-code" class="headerlink" title="the code"></a>the code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int Max &#x3D; 9999;typedef char **HuffmanCode;typedef struct Node &#123;    int weight;    int parent, left, right;&#125; HTNode, *HuffmanTree;void Select(HuffmanTree ht, int k, int id1, int id2) &#123;    int min1 &#x3D; min2 &#x3D; 9999;for (int i &#x3D; 0;i &lt; k;i++) &#123;        if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min1 &lt; ht[i].weight) &#123;            if (min1 &lt; min2) &#123;                min2 &#x3D; min1;                id2 &#x3D; id1;            &#125;            id1 &#x3D; i;            min1 &#x3D; ht[i].weight;        &#125; else if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min2 &gt; ht[i].weight) &#123;            min2 &#x3D; ht[i].weight;            id2 &#x3D; i;        &#125;    &#125;&#125;void createHuffmanTree(HuffmanTree ht, int n) &#123;    int id1, id2;    if (n &lt;&#x3D; 0)         return;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        ht[i].left &#x3D; ht[i].right &#x3D; ht[i].parent &#x3D; 0;    &#125;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        cin &gt;&gt; ht[i].weight;    &#125;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        Select(ht, i, id1, id2);        ht[id1].parent &#x3D; ht[id2].parent &#x3D; i;        ht[i].left &#x3D; id1;        ht[i].right &#x3D; id2;        ht[weight] &#x3D; ht[id1].weight + ht[id2].weight;    &#125;&#125;void createHuffmanTreeCode(HuffmanTree ht, HuffmanCode &amp;hc, int n) &#123;    int start, cur f;    hc &#x3D; new char*[n + 1];    char* cd &#x3D; new char[n];    cd[n - 1] &#x3D; &#39;\0&#39;;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        start &#x3D; n - 1;        cur &#x3D; i;        f &#x3D; ht[i].parent;        while (f !&#x3D; 0) &#123;            start--;            if (ht[f].left &#x3D;&#x3D; cur) &#123;                cd[start] &#x3D; &#39;0&#39;;            &#125; else &#123;                cd[start] &#x3D; &#39;1&#39;;            &#125;            cur &#x3D; f;            f &#x3D; ht[i].parent;        &#125;        hc[i] &#x3D; cd[n - start];        strcpy(hc[i], &amp;cd[start]);    &#125;    delete cd;&#125;int main() &#123;    int n;    cin &gt;&gt; n;    HuffmanTree ht;    HuffmanCode hc;    int sum &#x3D; 0;    HuffmanTree(ht, n);    createHuffmanCode(ht, hc, n);    for (int i &#x3D; 0;i &lt; 2 * n - 1;i++) &#123;        cout &lt;&lt; ht[i].weight &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 测试，输出所有结点，包括非原有结点    &#125;    cout &lt;&lt; endl;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        cout &lt;&lt; hc[i] &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 输出每个结点的HuffmanCode    &#125;&#125;</code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.cnblogs.com/linfangnan/p/12593480.html">数据结构：哈夫曼树与哈夫曼编码 - 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p><p><a href="https://www.bilibili.com/video/BV18t411U7Tb">数据结构与算法基础–第09周04–5.7哈夫曼树及其应用4-5.7.2哈夫曼树的构造算法2-哈夫曼树算法实现_哔哩哔哩_bilibili</a>(共6p)</p>]]></content>
    
    
    <summary type="html">填坑系列之哈夫曼树，整理了哈夫曼树和哈夫曼编码</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--简单二叉树(无序)</title>
    <link href="https://jaydenchang.top/post/0x0027.html"/>
    <id>https://jaydenchang.top/post/0x0027.html</id>
    <published>2021-11-15T16:00:00.000Z</published>
    <updated>2021-12-11T05:45:42.062Z</updated>
    
    <content type="html"><![CDATA[<p>本次来简单总结下简单二叉树(无序)，前面欠的债有点多，最近在疯狂追赶课程进度，简单记录下自己对简单二叉树的一些理解</p><h4 id="binary-tree"><a href="#binary-tree" class="headerlink" title="binary tree"></a>binary tree</h4><h5 id="the-main-structure"><a href="#the-main-structure" class="headerlink" title="the main structure"></a>the main structure</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int Max &#x3D; 100;template &lt;class DataType&gt;struct BiNode &#123;    DataType data;    BiNode *leftChild, *rightChild;    &#125;;template &lt;class DataType&gt;class BiTree &#123;    public:     BiTree() &#123; root &#x3D; Create(); &#125;     ~BiTree() &#123; Release(root); &#125;     void PreOrder() &#123; PreOrder(root); &#125;     void InOrder() &#123; InOrder(root); &#125;     void LevelOrder();     int leafNum(BiNode*);     BiNode* getRoot() &#123; return root; &#125;        private:     BiNode* root;     BiNode* Create();     void Release(BiNode* bt);     void PreOrder(BiNode* bt);     void InOrder(BiNode* bt);     void PostOrder(BiNode* bt);&#125;;</code></pre><h5 id="Create"><a href="#Create" class="headerlink" title="Create()"></a>Create()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;BiTree::BiTree() &#123;    BiNode* bt;    DataType ch;    cout &lt;&lt; &quot;enter a binary node: &quot;;    cin &gt;&gt; ch;    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;        return NULL;    &#125; else &#123;        bt &#x3D; new BiNode;        bt-&gt;data &#x3D; ch;        bt-&gt;leftChild &#x3D; Create();        bt-&gt;rightchild &#x3D; Create();        &#x2F;&#x2F; 不断套娃递归    &#125;&#125;</code></pre><h5 id="Release"><a href="#Release" class="headerlink" title="Release()"></a>Release()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;BiTree::Release(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        Release(bt-&gt;leftChild);        Release(bt-&gt;rightChild);        delete bt;    &#125;&#125;</code></pre><h5 id="PreOrder"><a href="#PreOrder" class="headerlink" title="PreOrder"></a>PreOrder</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::PreOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        PreOrder(bt-&gt;leftChild);        PreOrder(bt-&gt;rightChild);    &#125;&#125;</code></pre><h5 id="InOrder"><a href="#InOrder" class="headerlink" title="InOrder()"></a>InOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::InOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        InOrder(bt-&gt;leftChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        InOrder(bt-&gt;rightChild);    &#125;&#125;</code></pre><h5 id="PostOrder"><a href="#PostOrder" class="headerlink" title="PostOrder()"></a>PostOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::PostOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        PostOrder(bt-&gt;leftChild);        PostOrder(bt-&gt;rightChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;    &#125;&#125;</code></pre><h5 id="LevelOrder"><a href="#LevelOrder" class="headerlink" title="LevelOrder()"></a>LevelOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::LevelOrder() &#123;    BiNode *queue[Max], *ptr &#x3D; NULL;    int front &#x3D; -1, rear &#x3D; -1;    if (root &#x3D;&#x3D; NULL)         return;        queue[++rear] &#x3D; root; &#x2F;&#x2F; 根节点入队    while (front !&#x3D; rear) &#123;        ptr &#x3D; queue[++front]; &#x2F;&#x2F; 把根节点赋给临时指针ptr        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 输出当前结点的内容               if (ptr-&gt;leftChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;leftChild;        if (ptr-&gt;rightChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;rightChild;        &#x2F;&#x2F; 这里依次遍历左右左右孩子节点并添加入列    &#125;&#125;</code></pre><h5 id="leafNum"><a href="#leafNum" class="headerlink" title="leafNum()"></a>leafNum()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;int BiTree::leafNum(BiNode* bt)&#123;    if (bt &#x3D;&#x3D; NULL)        return 0;    if (bt-&gt;leftChild &#x3D;&#x3D; NULL &amp;&amp; bt-&gt;rightChild &#x3D;&#x3D; NULL)         return 1;    int left &#x3D; leafNum(bt-&gt;leftChild);    int right &#x3D; leafNum(bt-&gt;rightChild);    return left + right;&#125;</code></pre><h5 id="Complete-code"><a href="#Complete-code" class="headerlink" title="Complete code"></a>Complete code</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int Max &#x3D; 100;template &lt;class DataType&gt;struct BiNode &#123;    DataType data;    BiNode *leftChild, *rightChild;&#125;;template &lt;class DataType&gt;class BiTree &#123;    public:     BiTree() &#123; root &#x3D; Create(); &#125;     ~BiTree() &#123;Release(root); &#125;     void PreOrder() &#123; PreOrder(root); &#125;     void InOrder() &#123; InOrder(root); &#125;     void PostOrder() &#123; PostOrder(root); &#125;     void LevelOrder();     int leafNum(BiNode*);     BiNode* getRoot() &#123; return root; &#125;        private:     BiNode* root;     BiNode* Create();     void Release(BiNode*);     void PreOrder(BiNode*);     void InOrder(BiNode*);     void PostOrder(BiNode*);&#125;;template &lt;class DataType&gt;BiNode* BiTree::Create() &#123;    BiNode* bt;    DataType ch;    cout &lt;&lt; &quot;enter a node data: &quot;;    cin &gt;&gt; ch;    if (ch !&#x3D; &#39;#&#39;) &#123;        bt-&gt;data &#x3D; ch;        bt-&gt;leftChild &#x3D; Create();        bt-&gt;rightChild &#x3D; Create();        return bt;    &#125;&#125;template &lt;class DataType&gt;void BiTree::Release(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        Release(bt-&gt;leftChild);        Release(bt-&gt;rightChild);        delete bt;    &#125;&#125;template &lt;class DataType&gt;void BiTree::PreOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        PreOrder(bt-&gt;leftChild);        PreOrder(bt-&gt;rightChild);    &#125;&#125;template &lt;class DataType&gt;void BiTree::InOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        InOrder(bt-&gt;leftChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        InOrder(bt-&gt;rightChild);    &#125;&#125;template &lt;class DataType&gt;void BiTree::PostOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        PostOrder(bt-&gt;leftChild);        PostOrder(bt-&gt;rightChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;    &#125;&#125;template &lt;class DataType&gt;void BiTree::LevelOrder() &#123;    BiNode* queue[Max], ptr &#x3D; NULL;    int front &#x3D; -1, rear &#x3D; -1;    if (root &#x3D;&#x3D; NULL)        return;queue[++rear] &#x3D; root;    while (front !&#x3D; rear) &#123;        ptr &#x3D; queue[++front];        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;;        if (ptr-&gt;leftChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;leftChild;        if (ptr-&gt;rightChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;rightChild;    &#125;&#125;template &lt;class DataType&gt;int BiTree::leafNum(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL)        return 0;    if (bt-&gt;leftChild &#x3D;&#x3D; NULL &amp;&amp; bt-&gt;rightChild &#x3D;&#x3D; NULL)        return 1;    int left &#x3D; leafNum(bt-&gt;leftChild);    int right &#x3D; leafNum(bt-&gt;rightChild);    return left + right;    &#125;int main() &#123;    BiTree tree;    cout &lt;&lt; &quot;---PreOrder---\n&quot;;    tree.PreOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---InOrder---\n&quot;;    tree.InOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---PostOrder---\n&quot;;    tree.PostOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---LevelOrder---\n&quot;;    tree.LevelOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;the num of the leaves: &quot;;    cout &lt;&lt; tree.leafNum(tree.getRoot());&#125;</code></pre>]]></content>
    
    
    <summary type="html">整理了简单二叉树的简单应用，包括前中后遍历，求树的深度、叶子节点个数</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>kmp</title>
    <link href="https://jaydenchang.top/post/0x0026.html"/>
    <id>https://jaydenchang.top/post/0x0026.html</id>
    <published>2021-10-30T16:00:00.000Z</published>
    <updated>2022-01-06T06:22:17.217Z</updated>
    
    <content type="html"><![CDATA[<p>注：本篇文章只记录我理解的过程、需要注意的小细节，不涉及具体讲解，一些具体的原理、推导步骤可参考文末我列出的文章和视频</p><p>说到字符串匹配，以前的我，对时间、空间复杂度没有什么概念，估计写出来的代码长这样</p><h3 id="BF-brute-force"><a href="#BF-brute-force" class="headerlink" title="BF(brute-force)"></a>BF(brute-force)</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int BF(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0; j &#x3D; 0;    while (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        if (s[i] &#x3D;&#x3D; p[j]) &#123;            i++, j++;            &#x2F;&#x2F; 匹配成功就指针都后移        &#125; else &#123;            i &#x3D; i - j + 1;            j &#x3D; 0;        &#125;    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else         return -1;&#125;</code></pre><p>查阅资料后发现，这￥%&amp;#时间复杂度还挺高，假设文本串长m，模式串长n，时间复杂度是<code>O(m*n)</code>，如果m和n都很大的话，效率会低到无法想象</p><h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><p>这时候，引入一个新算法，kmp，反正就是三个大佬的名字首字母拼在一起</p><p>要理解kmp，首先要理解kmp中的next数组，next数组，说人话，就类似一个索引。kmp的本质就是利用模式串的最长公共前后缀来缩短查找时间</p><p>如果字符失配，模式串向后移动<code>j-next[j]</code>位，这样说还不是很好理解，看一个例子</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td><u><strong>d</strong></u></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>这里在第七位失配，在d前面，有最长公共前后缀”ab”，长度为2，按照刚才说的，模式串向后移动<code>j-next[j]</code>位，即<code>6-next[6]</code>，其中<code>next[6] = 2</code>，变成如下</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td><u><strong>c</strong></u></td><td>d</td><td>a</td><td>b</td><td>d</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>c失配，c前无最长公共前后缀，向后移动<code>2-next[2]</code>，也就是2位</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td><u><strong>d</strong></u></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在d处又失配，再次移动<code>6-next[6]</code>也就是4位</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td>d</td><td></td></tr></tbody></table><p>匹配成功ヾ(≧▽≦*)o</p><p>以上就是kmp算法的基本实现流程</p><h4 id="next"><a href="#next" class="headerlink" title="next"></a>next</h4><h5 id="next数组的二三事"><a href="#next数组的二三事" class="headerlink" title="next数组的二三事"></a>next数组的二三事</h5><p>next数组的实质是：在当前字符前，最长公共前后缀的字符数</p><p>先拿出一个模式串：<code>abcabzan</code></p><p>对于next，有些版本默认第0位是-1，有的是0，这里默认第0位是-1.</p><ul><li>对于第一位是a，前面没有字符，赋值-1</li><li>第二位b前面只有一个字符，没有相同子串，赋值0</li><li>第三位前面两个字符没有同，赋值0</li><li>第四位前面也无，同上</li><li>第五位前面有相同前后缀元素，即a，赋值1</li><li>第六位前面，继续找，发现有更长的前后缀公共元素，是ab，两个字符，赋值2</li><li>第七位无，第八位前有一个a，赋值1，后面无公共元素</li><li>一般来说不用管最后一位是否和前面的字符能匹配上，next的目的是判断当前字符前面是否有相同的子串</li></ul><p>最后把next数组的值罗列一下</p><p><code>-1 0 0 0 1 2 0 1 </code></p><p>然后就得到了next数组</p><h5 id="next数组代码实现"><a href="#next数组代码实现" class="headerlink" title="next数组代码实现"></a>next数组代码实现</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void makeNext(string p, int next[]) &#123;    int j &#x3D; 0, k &#x3D; -1;    int len &#x3D; p.length();    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            &#x2F;&#x2F; 这里判断是否从首位开始匹配，或者模式串前后是否匹配成功            j++, k++;            next[j] &#x3D; k;            &#x2F;&#x2F; 匹配成功就把当前匹配的字符数赋给当前next[j]            &#x2F;&#x2F; 即模式串第j位前有k个最长前后缀公共元素        &#125; else &#123;            k &#x3D; next[k];            &#x2F;&#x2F; 把当前next[k]赋给k，也就相当于整个模式串向后移动next[k]位        &#125;    &#125;&#125;</code></pre><h5 id="next数组的优化"><a href="#next数组的优化" class="headerlink" title="next数组的优化"></a>next数组的优化</h5><table><thead><tr><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>a</td><td>b</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>对于模式串<code>&quot;abab&quot;</code>，它的next数组为<code>-1 0 0 1</code></p><p>当c与b失配时，模式串向后移动<code>3-next[3] = 2</code>，变成如下</p><table><thead><tr><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td></td><td></td><td>a</td><td><u><strong>b</strong></u></td><td>a</td><td>b</td><td></td><td></td><td></td></tr></tbody></table><p>看到上面这里，原来<code>p[j]</code>和<code>s[j]</code>失配，右移之后，变成<code>s[j]</code>和<code>p[next[j]]</code>(即前后缀相同字符)匹配，然后呢，又失配了，虽然说在这组字符串里最后都能匹配成功，但是移动后，按照道理，失配位前面的字符在移动之后都能匹配成功，如果一直出现这样的情况的话，那么匹配的效率就会下降。</p><p>那么怎么修改？答案是，<strong>不能容许<code>p[j]=p[next[j]]</code></strong>。如果出现刚才叙述的情况，则需递归，令<code>next[j] = next[next[j]]</code></p><p>那么这个递归又是怎么个回事呢？(看了好久才懂)</p><p>随便举一个字符串<code>ababc</code></p><p>下标从0开始，到c这个位置，也就是第4位，下标为1的字符b和下标为3的字符b是等价的，在递归之后，next数组更新，可避免出现刚才那样的bug，后移之后在前面的子串部分失配(按照道理，公共前后缀部分是不会失配的)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void makeNext(string p, int next[]) &#123;    int len &#x3D; p.length();    int k &#x3D; -1, j &#x3D; 0;    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            j++, k++;            if (p[j] !&#x3D; p[k])                 next[j] &#x3D; k;            &#x2F;&#x2F; 如果匹配失败就把匹配数赋给next[j]            else                 next[j] &#x3D; next[k];            &#x2F;&#x2F; 不能出现p[j] &#x3D; p[next[j]]的情况，需要继续递归        &#125; else &#123;            k &#x3D; next[k];            &#x2F;&#x2F; 把k复位(分匹配是否成功两种情况)        &#125;    &#125;&#125;</code></pre><p>优化过后的数组</p><table><thead><tr><th>a</th><th>b</th><th>a</th><th>b</th></tr></thead><tbody><tr><td>-1</td><td>0</td><td>-1</td><td>0</td></tr></tbody></table><p>单单只看优化过后的代码，感觉还是有点恍惚，还是要结合kmp的主干部分来看</p><h4 id="kmp-1"><a href="#kmp-1" class="headerlink" title="kmp"></a>kmp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int kmp(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0, j &#x3D; 0;    int *next &#x3D; new int[len2];    makeNext(p, next);    while (j &#x3D;&#x3D; -1 || i &lt; len1 &amp;&amp; j &lt; len2) &#123;        &#x2F;&#x2F; j为-1 or 匹配成功才指针后移        if(s[i] &#x3D;&#x3D; p[j])             i++, j++;        &#x2F;&#x2F; 匹配就指针后移        else             j &#x3D; next[j];                &#x2F;&#x2F; 不匹配就根据之前求出的next来决定模式串从哪开始匹配    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else        return 0;&#125;</code></pre><p>优化过后继续结合刚才优化前出现bug的那个数组</p><p>优化后next：<code>-1 0 -1 0</code></p><table><thead><tr><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>a</td><td><u><strong>b</strong></u></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第四位失配，后移<code>3-next[3]</code>，递归后<code>next[3] = 0</code>，后移了3位</p><table><thead><tr><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td></td><td></td><td></td><td>a</td><td>b</td><td>a</td><td>b</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td><td></td></tr></tbody></table><p>c和a失配，再后移</p><table><thead><tr><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>a</td><td>b</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td></tr></tbody></table><p>匹配成功</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;void makeNext(string p, int next[]);int kmp(string s, string p);void makeNext(string p, int next[]) &#123;    int len &#x3D; p.length();    int j &#x3D; 0, k &#x3D; -1;    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            j++, k++;            if (p[j] !&#x3D; p[k])                next[j] &#x3D; next[k];            else                k &#x3D; next[j];        &#125;     &#125;&#125;int kmp(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0, j &#x3D; 0;    int *next &#x3D; new int[len2];    makeNext(p, next);    while (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        if (j &#x3D;&#x3D; -1 || s[i] &#x3D;&#x3D; p[j])            i++, j++;        else            j &#x3D; next[j];    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else         return 0;&#125;int main() &#123;    string s, p;    cin &gt;&gt; s &gt;&gt; p;    if (kmp(s, p) &#x3D;&#x3D; 1)        cout &lt;&lt; &quot;found the key string\n&quot;;    else        cout &lt;&lt; &quot;not found the key string\n&quot;;&#125;</code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解KMP（2014年8月22日版）_结构之法 算法之道-CSDN博客_kmp</a></p><p><a href="https://www.bilibili.com/video/BV1Ys411d7yh?from=search&seid=14595349758363193343&spm_id_from=333.337.0.0">【soso字幕】汪都能听懂的KMP字符串匹配算法【双语字幕】_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">填坑系列之kmp，本篇文章只记录我理解的过程、需要注意的小细节，不涉及具体讲解，一些具体的原理、推导步骤可参考文末我列出的文章和视频</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--不设头指针的循环链队列</title>
    <link href="https://jaydenchang.top/post/0x0025.html"/>
    <id>https://jaydenchang.top/post/0x0025.html</id>
    <published>2021-10-24T16:00:00.000Z</published>
    <updated>2021-12-11T05:52:19.369Z</updated>
    
    <content type="html"><![CDATA[<p>本次数据结构的作业是设计一个只有尾指针的循环链队列，要求实现构造(有参 &amp;&amp; 无参)、析构、出入列、获取头结点等功能。在完成过程中踩了很多坑(特别是在实现析构时qwq)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;struct Node &#123;    DataType data;    Node&lt;DataType&gt;* next;&#125;;template &lt;class DataType&gt;class LinkQueue &#123;    public:     LinkQueue();     LinkQueue(int [], int);     ~LinkQueue();     void EnQueue(DataType x);     DataType DeQueue();     DataType GetQueue();        private:     Node&lt;DataType&gt;* rear;&#125;;</code></pre><h4 id="有参构造-amp-amp-无参构造"><a href="#有参构造-amp-amp-无参构造" class="headerlink" title="有参构造&amp;&amp;无参构造"></a>有参构造&amp;&amp;无参构造</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue(int arr[], int n) &#123;    rear &#x3D; new Node&lt;DataType&gt;;    Node&lt;DataType&gt;* p &#x3D; rear;    &#x2F;&#x2F;储存首地址，最后把尾巴连上for(int i &#x3D; 0; i &lt; n; i++) &#123;        rear-&gt;next &#x3D; new Node&lt;DataType&gt;;        rear &#x3D; rear-&gt;next;        rear-&gt;data &#x3D; arr[i];    &#125;    rear-&gt;next &#x3D; p;    &#x2F;&#x2F; 把尾巴连到首部&#125;template &lt;class DataType&gt;LinkQueue&lt;DataTpye&gt;::LinkQueue() &#123;    rear &#x3D; NULL;&#125;</code></pre><h4 id="进队-amp-amp-出队"><a href="#进队-amp-amp-出队" class="headerlink" title="进队 &amp;&amp; 出队"></a>进队 &amp;&amp; 出队</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void LinkQueue&lt;DataType&gt;::EnQueue(DataType x) &#123;    Node&lt;DataType&gt;* p &#x3D; new Node&lt;DataType&gt;;        p-&gt;data &#x3D; x;    if (rear &#x3D;&#x3D; NULL) &#123;        rear &#x3D; p;        rear-&gt;next &#x3D; p;    &#125; else &#123;        p-&gt;next &#x3D; rear-&gt;next;  &#x2F;&#x2F; 新建节点连接头指针        rear-&gt;next &#x3D; p; &#x2F;&#x2F; 尾指针连接新节点        rear &#x3D; p; &#x2F;&#x2F; 尾指针后移    &#125;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::DeQueue() &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    DataType x;    if (rear &#x3D;&#x3D; NULL)         throw &quot;dive dowm&quot;;    p &#x3D; rear-&gt;next;    x &#x3D; p-&gt;data;    if (rear &#x3D;&#x3D; p)        rear &#x3D; NULL;    else         rear-&gt;next &#x3D; p-&gt;next;    delete p;    return x;&#125;</code></pre><h4 id="获取头结点"><a href="#获取头结点" class="headerlink" title="获取头结点"></a>获取头结点</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::GetQueue() &#123;    if (rear !&#x3D; NULL)        return rear-&gt;next-&gt;data;    &#x2F;&#x2F; return rear-&gt;data;    &#x2F;&#x2F; 这里rear已经指向队末，按照上一行代码，返回的是队末元素    else        throw &quot;empty queue&quot;;&#125;</code></pre><h4 id="清空循环链队列-也可写成析构"><a href="#清空循环链队列-也可写成析构" class="headerlink" title="清空循环链队列(也可写成析构)"></a>清空循环链队列(也可写成析构)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::~LinkQueue() &#123;    Node&lt;DataType&gt;* p;    while (rear !&#x3D; NULL) &#123;        &#x2F;&#x2F; the wrong version:                &#x2F;&#x2F; p &#x3D; rear;        &#x2F;&#x2F; rear &#x3D; rear-&gt;next;        &#x2F;&#x2F; delete p;        p &#x3D; rear-&gt;next;        if (rear &#x3D;&#x3D; p) &#123;            delete rear;            break;        &#125; else             rear-&gt;next &#x3D; p-&gt;next;        delete p;    &#125;&#125;</code></pre><p>关于这个析构函数，我在网上找了很多个版本，很多代码都是写成注释里的那样，包括老师给的答案也是，有些编译器直接运行可能看不出什么问题，但是放在debug模式里，就会报错</p><img src='https://jaydenchang.gitee.io/images/images/0x0025-1.jpg' style="zoom:67%;" ><p>如上图，在这里我已将循环链队列所有元素delete，当我查看变量的值时，发现，没那么简单，rear指针不为null，它指向的data值也是不规则的，也就不难说明为什么跳不出第46行的while循环了</p><img src='https://jaydenchang.gitee.io/images/images/0x0025-2.jpg' style="zoom:67%;" ><p>跳不出循环后，继续delete，就会报错，虽然提示<code>unKnown signal</code>，实际上是队列为空，无法继续delete</p><p>那么怎么解决呢，我将出列函数改写，放到析构函数里，这样子在删除最后一个节点时就能跳出循环，结束析构</p><img src='https://jaydenchang.gitee.io/images/images/0x0025-3.JPG'><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template &lt;class DataType&gt;struct Node &#123;    DataType data;    Node&lt;DataType&gt;* next;&#125;;template &lt;class DataType&gt;class LinkQueue &#123;   public:    LinkQueue();    LinkQueue(int[], int);    ~LinkQueue();    void EnQueue(DataType x);    DataType DeQueue();    DataType GetQueue();   private:    Node&lt;DataType&gt;* rear;&#125;;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue(int arr[], int n) &#123;    rear &#x3D; new Node&lt;DataType&gt;;    &#x2F;&#x2F; rear-&gt;data &#x3D; arr[0];    Node&lt;DataType&gt;* p &#x3D; rear;  &#x2F;&#x2F; 储存首地址，最后把尾巴连接到首部    for (int i &#x3D; 0; i &lt; n; i++) &#123;        rear-&gt;next &#x3D; new Node&lt;DataType&gt;;  &#x2F;&#x2F; 不断开辟空间        rear &#x3D; rear-&gt;next;                &#x2F;&#x2F; rear后移        rear-&gt;data &#x3D; arr[i];    &#125;    rear-&gt;next &#x3D; p;  &#x2F;&#x2F;把尾巴连到首部&#125;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue() &#123;    rear &#x3D; NULL;&#125;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::~LinkQueue() &#123;    Node&lt;DataType&gt;* p;    while (rear !&#x3D; NULL) &#123;                p &#x3D; rear-&gt;next;        if (rear &#x3D;&#x3D; p) &#123;            delete rear;            break;        &#125; else &#123;            rear-&gt;next &#x3D; p-&gt;next;        &#125;        delete p;    &#125;&#125;template &lt;class DataType&gt;void LinkQueue&lt;DataType&gt;::EnQueue(DataType x) &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    p &#x3D; new Node&lt;DataType&gt;;    p-&gt;data &#x3D; x;    if (rear &#x3D;&#x3D; NULL) &#123;        rear &#x3D; p;        rear-&gt;next &#x3D; p;    &#125; else &#123;        p-&gt;next &#x3D; rear-&gt;next;  &#x2F;&#x2F; 新建节点连接头指针        rear-&gt;next &#x3D; p;        &#x2F;&#x2F; 尾指针连接新节点        rear &#x3D; p;              &#x2F;&#x2F; 尾指针后移    &#125;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::DeQueue() &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    DataType x;    if (rear &#x3D;&#x3D; NULL)        throw &quot;dive down&quot;;    p &#x3D; rear-&gt;next;    x &#x3D; p-&gt;data;    if (rear &#x3D;&#x3D; p)        rear &#x3D; NULL;    else        rear-&gt;next &#x3D; p-&gt;next;    delete p;    return x;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::GetQueue() &#123;    if (rear !&#x3D; NULL)        return rear-&gt;next-&gt;data;    &#x2F;&#x2F; return rear-&gt;data;    &#x2F;&#x2F; 这里rear已指向队末，返回的是队末元素    else        throw &quot;empty queue&quot;;&#125;int main() &#123;    LinkQueue&lt;int&gt; Queue;    try &#123;        Queue.EnQueue(5);        Queue.EnQueue(10);        Queue.EnQueue(15);        &#x2F;&#x2F; Queue.EnQueue(20);    &#125; catch (char* wrong) &#123;        cout &lt;&lt; wrong &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;get head element&quot; &lt;&lt; endl;    cout &lt;&lt; Queue.GetQueue() &lt;&lt; endl;    try &#123;        Queue.DeQueue();    &#125; catch (char* wrong) &#123;        cout &lt;&lt; wrong &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;get head element&quot; &lt;&lt; endl;    cout &lt;&lt; Queue.GetQueue() &lt;&lt; endl;&#125;</code></pre>]]></content>
    
    
    <summary type="html">记录一次和作业答案bug的对抗过程</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--关于单链表小细节的一些补充</title>
    <link href="https://jaydenchang.top/post/0x0024.html"/>
    <id>https://jaydenchang.top/post/0x0024.html</id>
    <published>2021-10-04T16:00:00.000Z</published>
    <updated>2021-12-11T05:53:22.157Z</updated>
    
    <content type="html"><![CDATA[<p>以下是在做数据结构作业时遇到的一些bug<del>(老师给的答案不太行)</del></p><h4 id="无相应构造函数报错"><a href="#无相应构造函数报错" class="headerlink" title="无相应构造函数报错"></a>无相应构造函数报错</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int MaxSize &#x3D; 10;template &lt;class T&gt;class Seqlist &#123;    public:    Seqlist() &#123; length &#x3D; 0;&#125;    Seqlist(T [],int);    private:    int length;    T data[MaxSize];&#125;;    class B &#123;    public:    B(T);    B() &#123;&#125; &#x2F;&#x2F;这个默认的构造函数十分重要    private:    T data;&#125;;B::B(T n) &#123;    data &#x3D; n;&#125;template &lt;class T&gt;Seqlist&lt;T&gt;::Seqlist(T arr[], int n) &#123;    if (n &gt; MaxSize) throw &quot;invalid num&quot;;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        data[i] &#x3D; arr[i];    &#125;    length &#x3D; n;&#125;int main() &#123;    B b[3] &#x3D; &#123;B(10), B(20), B(30)&#125;;    Seqlist&lt;B&gt; list(b,3);&#125;</code></pre><p>在上面部分代码中，如果把有注释的那一行代码删去，则这部分代码不能正常运行，报错信息是</p><p><code>no matching function for call to &#39;B::B()&#39;[25, 35]</code></p><p>根据这个报错信息找到相应行数，居然在<code>int n</code>这里报错，我寻思着这关n什么事，后面查阅了资料，原因出在第34行的<code>B b[3]</code>这里，定义了一个B类型的数组，没有参数传入，而B类中无适配该成员的构造函数，于是编译器报错</p><p>解决方法是，加上相应的构造函数<code>B() &#123;&#125;</code></p><h4 id="线性链表的反转和复制功能"><a href="#线性链表的反转和复制功能" class="headerlink" title="线性链表的反转和复制功能"></a>线性链表的反转和复制功能</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;template &lt;class T&gt;struct Node &#123;    T data;    Node&lt;T&gt;* next;&#125;;template &lt;class T&gt;class LinkList &#123;    public:     LinkList(); &#x2F;&#x2F; create an empty list    LinkList(T[], int);    &#x2F;&#x2F;~LinkList();        void Reverse(Node&lt;T&gt;* head);    Node&lt;T&gt;* Copy(Node&lt;T&gt;* head);    Node&lt;T&gt;* first;&#125;template &lt;class T&gt;LinkList&lt;T&gt;::LinkList() &#123;    first &#x3D; new Node&lt;T&gt;;    first-&gt;next &#x3D; NULL;&#125;template &lt;class T&gt;LinkList&lt;T&gt;::LinkList(T arr[], int n) &#123;    first &#x3D; new Node&lt;T&gt;;    Node&lt;T&gt;* p &#x3D; first;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        Node&lt;T&gt;* s &#x3D; new Node&lt;T&gt;;        s-&gt;data &#x3D; arr[i];        p-&gt;next &#x3D; s;&#x2F;&#x2F;让first指向第一个节点        p &#x3D; s;&#x2F;&#x2F;虽说把s的地址赋给p，但是first的地址和p不一样，对p操作不会改变first        &#x2F;&#x2F;因此first永远指向链表第一个位置    &#125;    p-&gt;next &#x3D; NULL;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::Reverse(Node&lt;T&gt;* head) &#123;    Node&lt;T&gt;* pre, *cur;    cur &#x3D; head-&gt;next;    head-&gt;next &#x3D; NULL;    while (cur) &#123;        pre &#x3D; cur;&#x2F;&#x2F;让当前节点的上一节点移动到当前节点位置        cur &#x3D; cur-&gt;next;&#x2F;&#x2F;当前节点移动到下一个位置        pre-&gt;next &#x3D; head-&gt;next;&#x2F;&#x2F;这一操作就是让pre不断指向前一个节点        head-&gt;next &#x3D; pre;&#x2F;&#x2F;更新节点，让head的next指向pre    &#125;    &#x2F;&#x2F;在画图理解时，要让cur和pre同时向后移动    &#x2F;&#x2F;这一部分，建议自己在纸上画出若干个节点和用三个小部件(代表三个指针)模拟一边才能够真正地理解&#125;&#x2F;&#x2F;复盘时自己有个小细节没注意到，这里都是指针变量的赋值操作，这里的赋值只是赋予地址，给予者的值改变，接收者的值不会改变template &lt;class T&gt;Node&lt;T&gt;* LinkList&lt;T&gt;::Copy(Node&lt;T&gt;* head) &#123;    Node&lt;T&gt;* headB &#x3D; new Node&lt;T&gt;;    Node&lt;T&gt;* pb &#x3D; headB;    Node&lt;T&gt;* pa &#x3D; head-&gt;next;    while (pa !&#x3D; NULL) &#123;        Node&lt;T&gt;* temp &#x3D; new Node&lt;T&gt;;        temp-&gt;data &#x3D; pa-&gt;data;        temp-&gt;next &#x3D; NULL;&#x2F;&#x2F;这里用到了一个临时指针变量        pb-&gt;next &#x3D; temp;&#x2F;&#x2F;让pb连上temp        pb &#x3D; pb-&gt;next;        pa &#x3D; pa-&gt;next;        &#x2F;&#x2F;这里向后移动    &#125;    return headB;    &#x2F;&#x2F;注意这里返回的是headB，在调用时记得再加一个&quot;-&gt;next&quot;&#125;int main() &#123;    int arr[] &#x3D; &#123;1, 2, 3, 4, 5&#125;;    LinkList&lt;int&gt; list(arr,5);    cout &lt;&lt; &quot;the origin state: &quot; &lt;&lt; endl;    list.PrintList();        cout &lt;&lt; endl &lt;&lt; &quot;copy list a to list b\n&quot;;    Node&lt;int&gt;* ptr &#x3D; new Node&lt;int&gt;;    ptr &#x3D; list.copy(list.first)-&gt;next;    while (ptr !&#x3D; NULL) &#123;        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;;        ptr &#x3D; ptr-&gt;next;    &#125;        cout &lt;&lt; endl &lt;&lt; &quot;reverse the list a\n&quot;;    list.Reverse(list.first);    list.PrintList();&#125;</code></pre><h4 id="链表反转参考视频"><a href="#链表反转参考视频" class="headerlink" title="链表反转参考视频"></a>链表反转参考视频</h4><p><a href="https://www.bilibili.com/video/BV1KZ4y157Up?from=search&seid=15845376229805622503&spm_id_from=333.337.0.0">LeetCode力扣刷题 | 剑指Offer 24. 反转链表_哔哩哔哩_bilibili</a> [小姐姐声音很温柔doge]</p><p><a href="https://www.bilibili.com/video/BV1CW411N7mg?from=search&seid=15845376229805622503&spm_id_from=333.337.0.0">一分钟教你链表反转_哔哩哔哩_bilibili</a> [这个动画模拟比较贴合代码框的函数]</p><p>//谁知道我当时居然还去断点debug把每个节点以及他们的next的地址抄下来去对比</p>]]></content>
    
    
    <summary type="html">记录一次和老师给的答案的bug的对抗过程</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>旧手机改造成web服务器并实现内网穿透</title>
    <link href="https://jaydenchang.top/post/0x0023.html"/>
    <id>https://jaydenchang.top/post/0x0023.html</id>
    <published>2021-08-27T16:00:00.000Z</published>
    <updated>2021-12-11T05:53:51.507Z</updated>
    
    <content type="html"><![CDATA[<p>前几天由于gitee的审核引擎一通乱杀，使得gitee pages停止提供服务，心生更换服务器或者其他pages托管的想法，看了看价格感人的云服务器以及空空的钱包，这时，脑子有个奇怪的想法飘过，自己搞一个服务器，忽然想起来，我有一台root的旧手机，刚好拿来做测试</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>需要的工具：一台旧安卓手机(能获取root权限)，能联网的电脑，并装有Git</p><p>需要安装的软件：Linux Deploy，BusyBox，JuiceSSH (可选)，KSWEB (可选)</p><blockquote><p>JuiceSSH执行命令速度比电脑快，不过是手机操作，可能需要外接键盘</p><p>以下操作全在电脑端操作，不演示JuiceSSH与Linux Deploy的连接 (教程见文末第三个链接)</p></blockquote><p>需要的经验：部署过hexo博客，有一定git (或linux)基础，灵活运用关键字搜索，vim编辑器的使用语法</p><p><em>旧手机的基本信息</em></p><blockquote><ul><li>手机型号：Redmi 3</li><li>Android版本：5.1.1</li><li>Linux发行版：CentOS 7 (AltArch) [running via Linux Deploy]</li><li>RAM：2.0GiB</li><li>CPU：8核1.5GHz</li><li>储存空间：10GiB，可用4GiB</li></ul></blockquote><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-1.jpg' style="zoom: 25%;border-radius:2em" ><h3 id="配置Linux环境"><a href="#配置Linux环境" class="headerlink" title="配置Linux环境"></a>配置Linux环境</h3><p>首先打开BusyBox，点击安装 (需要root权限)</p><p>然后打开Linux Deploy，点击右下方的配置，设置系统相关信息，容器类型选chroot，发行版选CentOS，如果选其他发行版，架构一定要选对，不然会安装出错，或者无法使用，安装之前一定要知道手机CPU的架构；源地址建议切换为国内源，这里放上中科大的镜像源 <a href="http://mirrors.ustc.edu.cn/centos-altarch/">http://mirrors.ustc.edu.cn/centos-altarch/</a> ，国内还有其他源可选择，例如清华源，阿里源等</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-2.jpg' style="zoom: 25%;border-radius:2em" ><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-3.jpg' style="zoom: 25%;border-radius:2em" ><p>这里的设置很重要，一定要启用ssh，后面的步骤会用到 (SSH默认端口是22，此端口用于JuiceSSH连接)</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-4.jpg' style="zoom: 25%;border-radius:2em" ><p>然后返回主界面，点击左上，打开设置，建议前三个选项都勾上，往下滑，看到<code>PATH变量</code>，输入<code>/system/xbin</code>，再往下拉，把 调试模式 也勾上</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-5.jpg' style="zoom: 25%;border-radius:2em" ><p>再回到主界面，点击右上角，开始安装，大约要半小时</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-6.jpg' style="zoom: 25%;border-radius:2em" ><p>a few thousand years later……</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-7.jpg' style="zoom: 25%;border-radius:2em" ><p>看到手机输出<code>&lt;&lt;&lt;deploy</code>时说明安装完成，启动前先点击一次停止按钮，看见<code>&lt;&lt;&lt;stop</code>时再点击启动，看见输出如图内容时即成功启动。</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-8.jpg' style="zoom: 25%;border-radius:2em" ><p>然后打开KSWEB，查看当前手机的局域网ip，例如我手机的ip是192.168.101.10</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-9.jpg' style="zoom: 25%;border-radius:2em" ><p>然后打开电脑终端(cmd，git，wsl都可)，输入<code>ssh admin@192.168.101.10</code>，按照要求输入密码(前面的Linux Deploy配置里有密码的选项)，如下图所示即成功连接手机</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-10.jpg' style="zoom: 100%;border-radius:0.5em" ><h3 id="在服务器上部署"><a href="#在服务器上部署" class="headerlink" title="在服务器上部署"></a>在服务器上部署</h3><h4 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h4><p>在服务器端安装git和node.js</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y gitcurl -sL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_12.x | bash -yum -y install nodejs</code></pre><p>:::tip</p><p>如果出现没做任何操作，下载自行终止并出现<code>Exiting on user cancel</code>，可尝试输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum clean metadatayum clean allyum upgrade</code></pre><p>如果出现<code>Failed to set locale, defaulting to C.UTF-8</code>，是没有正确设置语言环境或者没安装相关语言包导致的，可尝试用两种解决方法</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;export LC_ALL&#x3D;en_US.UTF-8&quot; &gt;&gt; &#x2F;etc&#x2F;profilesource &#x2F;etc&#x2F;profile</code></pre><p>执行完后<strong>重新登陆</strong>再试安装，若还出现这个情况，安装相应语言包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install glibc-langpack-zh &#x2F;&#x2F;中文包&#x2F;&#x2F;英文包dnf install glibc-langpack-en 或dnf install langpacks-en glibc-all-langpacks -y</code></pre><p>:::</p><p>创建用户并配置其仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">useradd gitpasswd git &#x2F;&#x2F; 设置密码su git &#x2F;&#x2F; 这步很重要，不切换用户后面会很麻烦cd &#x2F;home&#x2F;git&#x2F;mkdir -p projects&#x2F;blog &#x2F;&#x2F; 项目存在的真实目录mkdir repos &amp;&amp; cd reposgit init --bare blog.git &#x2F;&#x2F; 创建一个裸露的仓库cd blog.git&#x2F;hooksvi post-receive &#x2F;&#x2F; 创建 hook 钩子函数，输入了内容如下</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;shgit --work-tree&#x3D;&#x2F;home&#x2F;git&#x2F;projects&#x2F;blog --git-dir&#x3D;&#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git checkout -f</code></pre><p>添加完毕修改权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod +x post-receiveexit &#x2F;&#x2F; 退出到 root 登录chown -R git:git &#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git &#x2F;&#x2F; 添加权限</code></pre><p>测试<code>git仓库</code>是否可用，另找空白文件夹，在电脑端右键git bash here，输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone git@server_ip:&#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git</code></pre><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-11.jpg' style="zoom:50%;border-radius:0.7em" ><p>如果能clone空仓库，说明git仓库搭建成功</p><p>建立ssh信任关系，在电脑输入以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-copy-id -i C:&#x2F;Users&#x2F;yourname&#x2F;.ssh&#x2F;id_rsa.pub git@server_ip&#x2F;&#x2F;如果用户名有空格，路径用引号括起来ssh git@server_ip &#x2F;&#x2F; 测试能否登录</code></pre><p><strong>注：此时的 ssh 登录 git 用户不需要密码！否则就有错，请仔细重复步骤 3-5</strong></p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-12.jpg' style="zoom:50%;border-radius:0.7em" ><p>如图即成功添加信任</p><p>为了安全起见禁用 git 用户的 shell 登录权限，从而只能用 git clone，git push </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;etc&#x2F;shells &#x2F;&#x2F; 查看 git-shell 是否在登录方式里面which git-shell &#x2F;&#x2F; 查看是否安装vi &#x2F;etc&#x2F;shells添加上2步显示出来的路劲，通常在 &#x2F;usr&#x2F;bin&#x2F;git-shell</code></pre><p>修改<code>/etc/passwd</code>中的权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F; 将原来的git:x:1000:1000::&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash&#x2F;&#x2F; 修改为git:x:1000:1000:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</code></pre><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-13.jpg' style="zoom:45%;" ><blockquote><p>需修改的内容一般在最后一行，数字不用改，只需添加半角逗号和改路径即可</p></blockquote><h4 id="搭建nginx服务器"><a href="#搭建nginx服务器" class="headerlink" title="搭建nginx服务器"></a>搭建nginx服务器</h4><p>下载并安装nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;usr&#x2F;local&#x2F;srcwget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.15.2.tar.gztar xzvf nginx-1.15.2.tar.gzcd nginx-1.15.2&#x2F;&#x2F; 执行之前先检查是否有安装gcc gdb gcc-c++ make wget这五个软件，没有的话不能进行下一步，可直接用yum命令安装.&#x2F;configure &#x2F;&#x2F; 如果后面还想要配置 SSL 协议，就执行后面一句！.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_modulemake &amp;&amp; make installalias nginx&#x3D;&#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx&#39; &#x2F;&#x2F; 为 nginx 取别名，后面可直接用，重新登陆后失效</code></pre><p>配置nginx文件</p><p>先启动是否安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx &#x2F;&#x2F; 直接来！浏览器查看 server_ip，默认是 80 端口</code></pre><p>修改配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -s stop &#x2F;&#x2F; 先停止nginxcd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;confvi nginx.conf修改 root 解析路径，如下图同时将 user 改为 root 如下图，不然nginx无法访问 &#x2F;home&#x2F;git&#x2F;projects&#x2F;blognginx -s reload</code></pre><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-14.jpg' style="zoom:50%;border-radius:0.7em" ><blockquote><p>需要修改第一个箭头所指的nobody，第二个箭头所指的是会产生bug的文件</p></blockquote><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-15.jpg' style="zoom:50%;border-radius:0.7em" ><blockquote><p>需要修改root的路径为博客位置，例如我之前设置的位置是<code>/home/git/projects/blog</code>，就把这个路径替换进去，注意不要漏了句尾的分号</p></blockquote><p>:::tip</p><p>在修改配置文件这里目测有坑，会出现<code>/usr/local/nginx/logs/nginx.pid failed</code>这样的字眼，打开<code>/usr/local/nginx/logs</code>，输入<code>ls -al</code>，没看见有<code>nginx.pid</code>，我的解决方法是输入这个<br><code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code>，再输入<code>ls -al</code>，发现<code>nginx.pid</code>出现了，再次运行<code>nginx -s reload</code>，没有报错。</p><p>:::</p><p>在这里，可以测试下部署在服务器的网页，不过只能实现局域网查。注意上图中有一个<code>listen  80</code>，这是一个设置在localhost的端口，可尝试在浏览器打开预览，不过建议换成其他端口，避免端口被占用无法预览，这里我换成800，可成功预览</p><p>:::warning</p><p>别忘了启动nginx，不然不能预览页面</p><p>:::</p><p>在手机浏览器输入<code>127.0.0.1:800</code>或<code>192.168.101.10:800</code>可以预览</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-19.jpg' style="zoom: 40%;border-radius:0.8em" ><p>在同一局域网的电脑输入<code>192.168.101.10:800</code>即可预览</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-20.jpg' style="zoom: 50%;border-radius:0.8em" ><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><h4 id="配置-config-yml文件"><a href="#配置-config-yml文件" class="headerlink" title="配置_config.yml文件"></a>配置<code>_config.yml</code>文件</h4><p>编辑deploy属性</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-17.jpg' style="zoom: 67%;border-radius:0.8em" ><blockquote><p>repo是推送到的目的地地址</p></blockquote><p>推送到服务器</p><p>使用<code>hexo d -g</code>或<code>hexo g- d</code>均可，如图即成功推送</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-18.jpg' style="zoom:67%;border-radius:0.7em" ><h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p>内网穿透有很多工具，常见的有花生壳，FRP，ngork。由于花生壳的价格过于感人，FRP需要另一台有公网ip的服务器，这里使用基于ngork的<a href='natapp.cn'>natapp</a> </p><p>官网：<a href="https://natapp.cn/">https://natapp.cn</a> <del>(快来打钱doge)</del> </p><p>这里需要在Linux安装，安装方法用wget + Linux安装包，由于我不知道wget会保存到哪里，所以我在wget后加了一个指定路径</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget -P &#x2F;home&#x2F;git&#x2F; https:&#x2F;&#x2F;cdn.natapp.cn&#x2F;assets&#x2F;downloads&#x2F;clients&#x2F;2_3_9&#x2F;natapp_linux_arm64&#x2F;natapp?version&#x3D;20190730</code></pre><p>下载之后对安装包重命名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv natapp?version&#x3D;20190730 natapp</code></pre><p>在root下先给予执行权限再执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod a+x natapp.&#x2F;natapp</code></pre><p>直接运行<code>./natapp</code>还不能运行程序，这里需要加上创建的隧道的authtoken参数才能打开</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;natapp -authtoken&#x3D;&lt;your token&gt;</code></pre><p>运行程序后，图中的网址已穿透内网，可对外访问 (这是个临时链接)</p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-21.jpg' style="zoom:50%;border-radius:0.8em" ><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-22.jpg' style="zoom:40%;border-radius:0.8em" ><p>到这里，一个web私人服务器就搭好了。</p><p>另外，关于穿透的网址，natapp有一个付费隧道可以绑定自定义域名，每个月9￥，而花生壳那边的价格比较感人 (还花了6￥开启https穿透的认证，发现没什么luan用，我*&amp;%@)，最终还是选择了natapp</p><p>不过，我还是选择GitHub Pages + Netlify 来配置我的网站，私人服务器跑网页，需要让服务器24h保持运作状态 (感觉也废不了什么电费)，毕竟通过隧道来访问网站的速度和直接托管在GitHub Pages差不多，干脆直接用GitHub Pages比较省事</p><p>除了网页服务器，旧手机理论上也可以建一个私人网盘 <del>(感觉也没时间整了)</del></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ii.do/24.html">旧手机搭建网站以及内网穿透 - Dark’s blog (ii.do)</a></p><p><a href="https://blog.csdn.net/qq_35561857/article/details/81590953">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器_jeffery5461的博客-CSDN博客_</a></p><p><a href="https://www.cnblogs.com/sw-code/p/14990229.html">使用Linux Deploy将闲置的安卓手机改造简易服务器 - sw-code - 博客园 (cnblogs.com)</a></p><p><a href="https://segmentfault.com/a/1190000017986794">超详细Hexo+Github Page搭建技术博客教程【持续更新】 - SegmentFault 思否</a></p><p>[<a href="https://blog.csdn.net/qq_41502780/article/details/104064975">解决nginx: [error] open() ＂/usr/local/nginx/logs/nginx.pid＂ failed错误_三也先生的博客-CSDN博客]</a></p><p><a href="https://developer.aliyun.com/article/387493">centos 7 升级后yum install出现Exiting on user cancel-阿里云开发者社区 (aliyun.com)</a></p><p><a href="https://www.cnblogs.com/h2285409/p/14745010.html">Failed to set locale, defaulting to C.UTF-8 - 天军 - 博客园 (cnblogs.com)</a></p><p><a href="https://mx142.cn/2020/12/22/11/">把hexo博客部署到服务器 | MX (mx142.cn)</a></p>]]></content>
    
    
    <summary type="html">我用半个月做了一个&quot;服务器&quot;</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="整活" scheme="https://jaydenchang.top/tags/%E6%95%B4%E6%B4%BB/"/>
    
    <category term="Linux" scheme="https://jaydenchang.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>迁移博客</title>
    <link href="https://jaydenchang.top/post/0x0022.html"/>
    <id>https://jaydenchang.top/post/0x0022.html</id>
    <published>2021-08-19T16:00:00.000Z</published>
    <updated>2021-12-11T05:54:15.728Z</updated>
    
    <content type="html"><![CDATA[<p>本站点已由<a href='https://jaydenchang.gitee.io'>旧站点</a>迁往<a href='https://jaydenchang.top'>jaydenchang.top</a>，旧站点已废弃</p><p>前几天准备更博客时，发现gitee的站点被ban了，了解到我的站点有违规内容 <del>(一脸懵逼)</del>，具体就不吐槽了，<strong>果然免费的是最贵的</strong>。后来心里冒出个想法，迁博客到别的服务器，gitee就当作图床了doge。</p><p>最终还是选择了GitHub pages，云服务器太贵了，自己搭的服务器内网穿透效果一般般<del>(先挖个坑)</del></p>]]></content>
    
    
    <summary type="html">记录一次站点迁移</summary>
    
    
    
    <category term="随笔" scheme="https://jaydenchang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://jaydenchang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>为博客添加评论邮件提醒功能(踩坑全过程)</title>
    <link href="https://jaydenchang.top/post/0x0021.html"/>
    <id>https://jaydenchang.top/post/0x0021.html</id>
    <published>2021-08-15T16:00:00.000Z</published>
    <updated>2021-12-11T05:55:03.852Z</updated>
    
    <content type="html"><![CDATA[<p>在很早之前，我就想过要给博客加一个邮件评论提醒功能，上个月折腾了三天愣是没折腾出什么，这几天学不进去，刚好来折腾这个。</p><p>因为懒，需要加载到图床的图片太多，这次不插入图片。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>注册一个 leancloud 国际版账户(国内的需要备案等一系列复杂的操作)</li><li>去GitHub fork项目，开启GitHub Action功能</li></ul><h3 id="为hexo博客添加评论valine系统"><a href="#为hexo博客添加评论valine系统" class="headerlink" title="为hexo博客添加评论valine系统"></a>为hexo博客添加评论valine系统</h3><p>这一步可参考以下链接，此处不再赘述，包括</p><ul><li>注册leancloud</li><li>配置hexo博客根目录下的<code>_config.(the name of your theme).yml</code> (这里需要修改的是对应主题的yml文件，不是<code>_config.yml</code>)</li></ul><p><a href='https://blog.csdn.net/blue_zy/article/details/79071414'>为你的Hexo加上评论系统-Valine – blue_zy</a></p><p><a href='https://blog.csdn.net/jiunian_2761/article/details/97388997'>Hexo博客进阶：为Next主题添加Valine评论系统– 千帆过烬</a></p><p>前两步，csdn，博客园大多数帖子都有教程，剩下的步骤有些难度，需要大量阅读相关帖子</p><h3 id="为hexo博客添加valine评论邮件提醒功能"><a href="#为hexo博客添加valine评论邮件提醒功能" class="headerlink" title="为hexo博客添加valine评论邮件提醒功能"></a>为hexo博客添加valine评论邮件提醒功能</h3><p>这一步包括</p><ul><li>自定义云引擎的变量 <del>(可选择氪还是不氪，不氪的选择体验版)</del></li><li>添加定时任务，定期唤醒和检查补发邮件</li></ul><p><a href='https://blog.csdn.net/Aoman_Hao/article/details/105323917'>Hexo博客Next主题valine评论系统邮件提醒 – AomanHao</a></p><p>完成这一步并且测试后，我心满意足，开始写博客，一开始还是有收到评论邮件的，过几天更新时发现有新评论却没有邮件提醒，回到leancloud后台一看，我%￥#&amp;*，引擎自动休眠了，再看日志，现实云函数报错，马上去必应一下这个情况，找不到有效解决方案，那就先搁着；过了几天来看，我去，提示我这个信息</p><p>“因为流控问题，通过定时任务唤醒体验版实例失败，建议升级至标准版引擎实例避免休眠”</p><p>好家伙，这明摆着要我去氪。不过，本着我多年不氪金<del>(白嫖)</del>的习惯，又去必应了下解决方案</p><h3 id="解决leancloud流控问题-最难"><a href="#解决leancloud流控问题-最难" class="headerlink" title="解决leancloud流控问题(最难)"></a>解决leancloud流控问题(最难)</h3><p>有三个常见的唤醒功能</p><ul><li>cron-job</li><li>Github+Action</li><li>Ajax请求唤醒</li></ul><p>csdn上大多数是去阿里云等网站申请唤醒功能，不过这些感觉需要花很多大洋的样子，就没去理会，后来发现GitHub+Action这个貌似不错，然后就去必应了下，雀食有很多帖子教GitHub+Action的，不过他们fork的项目已经不能访问了，就是这个： <code>https://github.com/blogimg/WakeLeanCloud</code></p><p>下面这两个帖子的</p><p><a href='https://hiram.wang/leancloud-timer-github-actions/#原有方案'>使用Github Actions模拟评论解决LeanCloud的流控限制 – Hiram’s Blog</a></p><p><a href='https://www.aimtao.net/slef-wake-leancloud/'>Gtihub Action｜一行命令解决 LeanCloud 流控问题 – AimTao’s Blog</a></p><p>以上两个博客提到的GitHub建议fork到本地仓库</p><p>按照上面两个博客其中之一设置完就差不多设置好了</p><h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><ul><li>怎么进入leancloud国际版评论后台网站：参照这个博客来设置user变量 <a href='https://www.fezhu.top/2020/07/02/liukong/'>解决Leancloud流控问题 – Uncleacc’s Blog</a></li><li>为什么提示云函数报错：是因为没有在云引擎处设置变量<code>ADMIN_URL</code>，这里填leancloud评论后台管理网址</li><li>云引擎中的变量<code>SMTP_PASS</code>不是邮箱密码，是邮箱SMTP的授权码</li><li>GitHub Action那里的<code>SITE</code>应该填评论后台管理网址</li></ul><p>写到这里，总算把折腾的全过程写出来了<del>(无用的知识增加了)</del></p>]]></content>
    
    
    <summary type="html">记录一次整活，完善博客的评论提醒功能</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="整活" scheme="https://jaydenchang.top/tags/%E6%95%B4%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>单链表(Java)</title>
    <link href="https://jaydenchang.top/post/0x0020.html"/>
    <id>https://jaydenchang.top/post/0x0020.html</id>
    <published>2021-08-06T16:00:00.000Z</published>
    <updated>2021-12-11T05:56:35.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>大体结构和C++的链表差不多，参考之前写过的博客 <a href='https://jaydenchang.gitee.io/post/0x0006'>单链表图书管理系统实例</a> <a href='https://jaydenchang.gitee.io/post/0x000B'>基于类的单链表实例</a></p><p>补充之前不知道的：链表分两类，带和不带头结点的链表  <del>现在才知道，Java没有像C/C++那样的指针</del></p><p>首先创建一个<code>LinkList</code>类，然后把链表的各个功能添加进去</p><h4 id="创建结点"><a href="#创建结点" class="headerlink" title="创建结点"></a>创建结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;当不考虑编号顺序时，找到当前链表最后节点，将最后节点next指向新节点public void add(PersonNode node) &#123;    &#x2F;&#x2F;因为头节点不能动，先需要一个辅助遍历节点temp    PersonNode temp &#x3D; head;            while (true) &#123;&#x2F;&#x2F;遍历链表，找到最后        if (temp.next &#x3D;&#x3D; null) &#123;            break;        &#125;                    temp &#x3D; temp.next;&#x2F;&#x2F;如果没到最后，就继续找下去    &#125;&#x2F;&#x2F;当退出while循环时，temp指向链表的最后    temp.next &#x3D; node;&#125;</code></pre><h4 id="添加结点-乱序"><a href="#添加结点-乱序" class="headerlink" title="添加结点(乱序)"></a>添加结点(乱序)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void addByOrder(PersonNode node) &#123;    &#x2F;&#x2F;因为头节点不移动，仍通过一个辅助变量来找添加的位置    &#x2F;&#x2F;因为是单链表，所以找的temp时位于添加位置的前一个结点，否则不能插入    PersonNode temp &#x3D; head;    boolean flag &#x3D; false;&#x2F;&#x2F;标识添加的编号是否存在    while (true) &#123;        if (temp.next &#x3D;&#x3D; null) &#x2F;&#x2F;说明temp在链表最后            break;        if (temp.next.no &gt; node.no) &#123;&#x2F;&#x2F;位置找到了，就在temp后面            break;        &#125; else if (temp.next.no &#x3D;&#x3D; node.no) &#123;&#x2F;&#x2F;希望添加的编号已存在            flag &#x3D; true;            break;        &#125;        temp &#x3D; temp.next;    &#125;    if (flag) &#123;&#x2F;&#x2F;编号已存在，不能添加        System.out.println(&quot;already exist no.&quot; + node.no + &quot;, you can&#39;t add it.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125; else &#123;        node.next &#x3D; temp.next;        temp.next &#x3D; node;    &#125;&#125;&#x2F;&#x2F;最终还是按照序号来排列</code></pre><h4 id="编辑结点"><a href="#编辑结点" class="headerlink" title="编辑结点"></a>编辑结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void edit(PersonNode node) &#123;&#x2F;&#x2F;这里直接引入外部结点，根据node.no来寻找需要修改的结点    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    PersonNode temp;    temp &#x3D; head.next;    boolean flag &#x3D; false;&#x2F;&#x2F;判断是否找到该结点    while (true) &#123;        if (temp &#x3D;&#x3D; null)            break;&#x2F;&#x2F;到了链表最后        if (temp.no &#x3D;&#x3D; node.no) &#123;            flag &#x3D; true;&#x2F;&#x2F;找到            break;        &#125;        temp &#x3D; temp.next;    &#125;    &#x2F;&#x2F;根据flag判断是否找到    if (flag) &#123;        temp.name &#x3D; node.name;        temp.score &#x3D; node.score;    &#125; else &#123;        System.out.println(&quot;not found no.&quot; + node.no + &quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#125;</code></pre><h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void delete(int no) &#123;    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    PersonNode temp &#x3D; head;&#x2F;&#x2F;temp指向待删除结点的前一个结点    boolean flag &#x3D; false;    while (true) &#123;        if (temp.next &#x3D;&#x3D; null) &#123;                            break;&#x2F;&#x2F;已经到链表最后        &#125;        if (temp.next.no &#x3D;&#x3D; no) &#123;            flag &#x3D; true;&#x2F;&#x2F;找到了待删除结点的前一个结点temp            break;        &#125;        temp &#x3D; temp.next;    &#125;    if (flag) &#123;        temp.next &#x3D; temp.next.next;    &#x2F;&#x2F;Java会自动回收未被访问的数据            &#125; else &#123;        System.out.println(&quot;not found&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#125;</code></pre><h4 id="打印链表"><a href="#打印链表" class="headerlink" title="打印链表"></a>打印链表</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void list() &#123;    &#x2F;&#x2F;判断链表是否为空    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    &#x2F;&#x2F;头节点不动，需要一个辅助变量来遍历    PersonNode temp &#x3D; head.next;    while (true) &#123;        &#x2F;&#x2F;判断是否到链表最后        if (temp &#x3D;&#x3D; null) &#123;            break;        &#125;        &#x2F;&#x2F;输出节点信息        System.out.println(temp);        &#x2F;&#x2F;由于之前重写了toString，这里直接打印temp就可以打印出节点的所有信息        temp &#x3D; temp.next;    &#125;&#125;</code></pre><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;    PersonNode person1 &#x3D; new PersonNode(1, &quot;Jordan&quot;, 56);    PersonNode person2 &#x3D; new PersonNode(2, &quot;Kobe&quot;, 81);    PersonNode person3 &#x3D; new PersonNode(3, &quot;James&quot;, 61);    PersonNode person4 &#x3D; new PersonNode(4, &quot;Melo&quot;, 60);    LinkList list &#x3D; new LinkList();&#x2F;&#x2F;按照顺序添加    &#x2F;&#x2F; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#x2F;&#x2F; list.add(person1);    &#x2F;&#x2F; list.add(person2);    &#x2F;&#x2F; list.add(person3);    &#x2F;&#x2F; list.add(person4);&#x2F;&#x2F;不按照顺序添加    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add by order&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    list.addByOrder(person1);    list.addByOrder(person4);    list.addByOrder(person3);    list.addByOrder(person2);    list.list();    &#x2F;&#x2F; list.addByOrder(person2);    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;edit&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    PersonNode newNode &#x3D; new PersonNode(3, &quot;Ivring&quot;, 57);    list.edit(newNode);    list.list();&#x2F;&#x2F;删除结点    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;delete&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    list.delete(4);    list.list();&#125;</code></pre><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;SingleLinkList.javapublic class SingleLinkList &#123;    public static void main(String[] args) &#123;        PersonNode person1 &#x3D; new PersonNode(1, &quot;Jordan&quot;, 56);        PersonNode person2 &#x3D; new PersonNode(2, &quot;Kobe&quot;, 81);        PersonNode person3 &#x3D; new PersonNode(3, &quot;James&quot;, 61);        PersonNode person4 &#x3D; new PersonNode(4, &quot;Melo&quot;, 60);        LinkList list &#x3D; new LinkList();    &#x2F;&#x2F;按照顺序添加        &#x2F;&#x2F; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#x2F;&#x2F; list.add(person1);        &#x2F;&#x2F; list.add(person2);        &#x2F;&#x2F; list.add(person3);        &#x2F;&#x2F; list.add(person4);    &#x2F;&#x2F;不按照顺序添加        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add by order&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        list.addByOrder(person1);        list.addByOrder(person4);        list.addByOrder(person3);        list.addByOrder(person2);        list.list();        &#x2F;&#x2F; list.addByOrder(person2);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;edit&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        PersonNode newNode &#x3D; new PersonNode(3, &quot;Ivring&quot;, 57);        list.edit(newNode);        list.list();    &#x2F;&#x2F;删除结点        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;delete&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        list.delete(4);        list.list();    &#125;&#125;&#x2F;&#x2F;定义一个成员点class PersonNode &#123;    String name;    public int no;    public int score;    public PersonNode next;&#x2F;&#x2F;指向下一个结点    public PersonNode(int no, String name, int score) &#123;        this.no &#x3D; no;        this.name &#x3D; name;        this.score &#x3D; score;    &#125;    &#x2F;&#x2F;为了显示方便，重写toString    @Override    public String toString() &#123;        return &quot;[no&#x3D;&quot; + no + &quot;,name&#x3D;&quot; + name + &quot;,score&#x3D;&quot; + score + &quot;]&quot;;    &#125;&#125;&#x2F;&#x2F;定义LinkList管理personclass LinkList &#123;    &#x2F;&#x2F;初始化头节点，头节点不能动    private PersonNode head &#x3D; new PersonNode(0, &quot;&quot;, 0);    public PersonNode getHead()&#123;        return head;&#x2F;&#x2F;返回私有成员head    &#125;    &#x2F;&#x2F;当不考虑编号顺序时，找到当前链表最后节点，将最后节点next指向新节点    public void add(PersonNode node) &#123;        &#x2F;&#x2F;因为头节点不能动，先需要一个辅助遍历节点temp        PersonNode temp &#x3D; head;                while (true) &#123;&#x2F;&#x2F;遍历链表，找到最后            if (temp.next &#x3D;&#x3D; null) &#123;                break;            &#125;                        temp &#x3D; temp.next;&#x2F;&#x2F;如果没到最后，就继续找下去        &#125;&#x2F;&#x2F;当退出while循环时，temp指向链表的最后        temp.next &#x3D; node;    &#125;    public void addByOrder(PersonNode node) &#123;        &#x2F;&#x2F;因为头节点不移动，仍通过一个辅助变量来找添加的位置        &#x2F;&#x2F;因为是单链表，所以找的temp时位于添加位置的前一个结点，否则不能插入        PersonNode temp &#x3D; head;        boolean flag &#x3D; false;&#x2F;&#x2F;标识添加的编号是否存在        while (true) &#123;            if (temp.next &#x3D;&#x3D; null) &#x2F;&#x2F;说明temp在链表最后                break;            if (temp.next.no &gt; node.no) &#123;&#x2F;&#x2F;位置找到了，就在temp后面                break;            &#125; else if (temp.next.no &#x3D;&#x3D; node.no) &#123;&#x2F;&#x2F;希望添加的编号已存在                flag &#x3D; true;                break;            &#125;            temp &#x3D; temp.next;        &#125;        if (flag) &#123;&#x2F;&#x2F;编号已存在，不能添加            System.out.println(&quot;already exist no.&quot; + node.no + &quot;, you can&#39;t add it.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125; else &#123;            node.next &#x3D; temp.next;            temp.next &#x3D; node;        &#125;    &#125;    public void edit(PersonNode node) &#123;        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        PersonNode temp;        temp &#x3D; head.next;        boolean flag &#x3D; false;&#x2F;&#x2F;判断是否找到该结点        while (true) &#123;            if (temp &#x3D;&#x3D; null)                break;&#x2F;&#x2F;到了链表最后            if (temp.no &#x3D;&#x3D; node.no) &#123;                flag &#x3D; true;&#x2F;&#x2F;找到                break;            &#125;            temp &#x3D; temp.next;        &#125;        &#x2F;&#x2F;根据flag判断是否找到        if (flag) &#123;            temp.name &#x3D; node.name;            temp.score &#x3D; node.score;        &#125; else &#123;            System.out.println(&quot;not found no.&quot; + node.no + &quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;        public void delete(int no) &#123;        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        PersonNode temp &#x3D; head;&#x2F;&#x2F;temp指向待删除结点的前一个结点        boolean flag &#x3D; false;        while (true) &#123;            if (temp.next &#x3D;&#x3D; null) &#123;                                break;&#x2F;&#x2F;已经到链表最后            &#125;            if (temp.next.no &#x3D;&#x3D; no) &#123;                flag &#x3D; true;&#x2F;&#x2F;找到了待删除结点的前一个结点temp                break;            &#125;            temp &#x3D; temp.next;        &#125;        if (flag) &#123;            temp.next &#x3D; temp.next.next;        &#125; else &#123;            System.out.println(&quot;not found&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#x2F;&#x2F;Java会自动回收未被访问的数据    &#125;    &#x2F;&#x2F;显示链表(遍历)    public void list() &#123;        &#x2F;&#x2F;判断链表是否为空        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        &#x2F;&#x2F;头节点不动，需要一个辅助变量来遍历        PersonNode temp &#x3D; head.next;        while (true) &#123;            &#x2F;&#x2F;判断是否到链表最后            if (temp &#x3D;&#x3D; null) &#123;                break;            &#125;            &#x2F;&#x2F;输出节点信息            System.out.println(temp);            &#x2F;&#x2F;由于之前重写了toString，这里直接打印temp就可以打印出节点的所有信息            temp &#x3D; temp.next;        &#125;    &#125;&#125;</code></pre><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="求单链表中有效结点个数"><a href="#求单链表中有效结点个数" class="headerlink" title="求单链表中有效结点个数"></a>求单链表中有效结点个数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;如果带头节点的链表，不统计头节点public static int getLength(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null)        return 0;    int length &#x3D; 0;    PersonNode current &#x3D; head.next;&#x2F;&#x2F;定义辅助变量    while (current !&#x3D; null) &#123;        length++;        current &#x3D; current.next;    &#125;    return length;&#125;</code></pre><p>在主函数中测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(getLength(list.getHead()));</code></pre><h4 id="查找单链表中倒数第n个结点-新浪"><a href="#查找单链表中倒数第n个结点-新浪" class="headerlink" title="查找单链表中倒数第n个结点(新浪)"></a>查找单链表中倒数第n个结点(新浪)</h4><p>思路</p><ul><li>编写一个方法，接收head结点，同时接收一个index</li><li>index表示是倒数第index个结点</li><li>先把链表从头到尾遍历，得到链表的总长度 getLength</li><li>得到size后，我们从链表第一个开始遍历<code>(size-index)</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static PersonNode findLastIndexNode(PersonNode head, int index)&#123;    if (head.next &#x3D;&#x3D; null)        return null;    int size &#x3D; getlength(head);&#x2F;&#x2F;第一次遍历，获取链表大小    if (index &lt;&#x3D; 0 || index &gt; size)&#x2F;&#x2F;判断倒数的序号是否超出容量        return null;    PersonNode current &#x3D; head.next;    for (int i &#x3D; 0; i &lt; size - index; i++) &#123;        current &#x3D; current.next;&#x2F;&#x2F;遍历size-index次    &#125;    return current;&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">PersonNode res &#x3D; findLastIndexNode(list.getHead(), 1);System.out.println(res);</code></pre><h4 id="单链表反转-腾讯"><a href="#单链表反转-腾讯" class="headerlink" title="单链表反转(腾讯)"></a>单链表反转(腾讯)</h4><p>思路</p><ul><li>先定义一个结点<code>reverseHead = new PersonNode();</code></li><li>从头到尾遍历原来的链表，每遍历一个链表，就将其取出，放在新链表最前端</li><li>原来链表的<code>head.next = reverseHead.next;</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void reverseList(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)        return;    &#x2F;&#x2F; 定义一个辅助遍历，帮助遍历原来的链表    PersonNode current &#x3D; head.next;    PersonNode next &#x3D; null;&#x2F;&#x2F;指向当前结点[current]的下一个结点    PersonNode reverseHead &#x3D; new PersonNode(0, &quot;&quot;, 0);    while (current !&#x3D; null) &#123;        next &#x3D; current.next;&#x2F;&#x2F;先暂时保存当前结点的下一个结点，后面会用到        current.next &#x3D; reverseHead.next;&#x2F;&#x2F;把current的下一个结点指向新链表最前端        reverseHead.next &#x3D; current;&#x2F;&#x2F;将current连接到新链表        current &#x3D; next;&#x2F;&#x2F;让current后移&#x2F;*每一次循环，reverseHead.next都会按照原链表的顺序定位到current，遍历结束，刚到reverseHead.next定位到链表最后一个，此时把reverseHead.next地址赋给head.next，这样就可以倒着来遍历链表*&#x2F;    &#125;    head.next &#x3D; reverseHead.next;&#x2F;&#x2F;头结点拼接，实现反转&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">reverseList(list.getHead());list.list();</code></pre><h4 id="从尾到头打印单链表-百度"><a href="#从尾到头打印单链表-百度" class="headerlink" title="从尾到头打印单链表(百度)"></a>从尾到头打印单链表(百度)</h4><p>思路</p><ul><li>1.先反转后再打印(有个问题：只要求逆序打印，不要求反转，这样会破坏原链表结构)</li><li>2.用栈的方法，利用栈先进后出的特点，实现逆序打印的效果</li></ul><blockquote><p><code>stack.java</code></p></blockquote><p>下面是栈的实例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Stack;public class stack&#123;    public static void main(String[] args)&#123;        Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();        stack.add(&quot;James&quot;);        stack.add(&quot;Kboe&quot;);        stack.add(&quot;Jordan&quot;);        while(stack.size() &gt; 0)&#123;            System.out.println(stack.pop());        &#125;    &#125;&#125;</code></pre><p>用栈的方法实现从头到尾打印单链表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void reversePrint(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null)        return;    &#x2F;&#x2F;创建一个栈，将各个结点压入栈    Stack&lt;PersonNode&gt; stack &#x3D; new Stack&lt;PersonNode&gt;();    PersonNode current &#x3D; head.next;    while (current !&#x3D; null) &#123;        stack.push(current);        current &#x3D; current.next;    &#125;    while (stack.size() &gt; 0) &#123;        System.out.println(stack.pop());    &#125;&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">reversePrint(list.getHead());</code></pre>]]></content>
    
    
    <summary type="html">Java版的链表</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组和队列(数组)</title>
    <link href="https://jaydenchang.top/post/0x001F.html"/>
    <id>https://jaydenchang.top/post/0x001F.html</id>
    <published>2021-08-05T16:00:00.000Z</published>
    <updated>2021-12-11T06:06:16.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>当一个数组中大部分元素是0时，或者为同一个值的数组时，可以用稀疏数组来保存该数组，节省储存空间(二维数组储存太浪费空间了)</p><!--more>应用场景- 五子棋、围棋记录黑白子，无占位处记为0，黑白分别记为1，2- 扫雷- 象棋类，跳棋等处理方法：- 记录数组有几行几列，有多少个不同的值- 把有不同值的元素的行列及值记录在一个小规模的数组里，从而缩小程序的规模二维数组转化稀疏数组的思路- 遍历原始二维数组，得到有效数据的个数- 根据sum就可以创建稀疏数组 `int spareseArr[sum + 1][3]`- 将二维数组的有效数据的个数sum存入稀疏数组稀疏数组转原始二维数组- 先读稀疏数组第一行，根据第一行数据创建原始二维数组- 在读取稀疏数组后几行的数据，并赋予原始的二维数组`int originArr[size][size]`即可#### 代码<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;spareseArray.javaimport java.util.Scanner;public class spareseArray&#123;    public static void main(String[] args)&#123;        public static void main(String[] args) &#123;        Scanner scan &#x3D; new Scanner(System.in);        int size &#x3D; scan.nextInt();        scan.close();        int chessArr[][] &#x3D; new int[size][size];&#x2F;&#x2F;创建一个11*11的棋盘        chessArr[1][2] &#x3D; 1;        chessArr[2][3] &#x3D; 2;        chessArr[4][6] &#x3D; 1;        int sum &#x3D; 0;        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                if (chessArr[i][j] !&#x3D; 0)                    sum++;            &#125;        &#125;        &#x2F;&#x2F;创建稀疏数组        int spareseArr[][] &#x3D; new int[sum + 1][3];        &#x2F;&#x2F;给稀疏数组赋值        spareseArr[0][0] &#x3D; size;        spareseArr[0][1] &#x3D; size;        spareseArr[0][2] &#x3D; sum;        &#x2F;&#x2F;遍历二维数组，把非0的值存放在稀疏数组中        int count &#x3D; 0;&#x2F;&#x2F;计数器，记录非0数据个数        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                if (chessArr[i][j] !&#x3D; 0) &#123;                    count++;                    spareseArr[count][0] &#x3D; i;                    spareseArr[count][1] &#x3D; j;                    spareseArr[count][2] &#x3D; chessArr[i][j];                &#125;            &#125;        &#125;        &#x2F;&#x2F;输出稀疏数组的形式        System.out.println(&quot;the sparese Array:&quot;);        for (int i &#x3D; 0; i &lt; sum + 1; i++) &#123;            System.out.printf(&quot;%d %d %d\n&quot;, spareseArr[i][0], spareseArr[i][1], spareseArr[i][2]);        &#125;        &#x2F;&#x2F;稀疏数组恢复二维数组        int originArr[][] &#x3D; new int[spareseArr[0][0]][spareseArr[0][1]];        &#x2F;&#x2F;输出恢复后的二维数组        for (int i &#x3D; 1; i &lt; spareseArr.length; i++) &#123;            originArr[spareseArr[i][0]][spareseArr[i][1]] &#x3D; spareseArr[i][2];        &#125;        System.out.println(&quot;the origin array:&quot;);        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                System.out.print(originArr[i][j] + &quot; &quot;);            &#125;            System.out.println();        &#125;        &#125;&#125;</code></pre><p>参考链接：<a href='https://www.bilibili.com/video/BV1E4411H73v?from=search&seid=10722391219764061578'>尚硅谷–Java数据结构p7-p9  bilibili</a></p><h3 id="队列-数组"><a href="#队列-数组" class="headerlink" title="队列(数组)"></a>队列(数组)</h3><p>队列是一个有序列表，可以用数组或者链表来实现。遵循先入先出原则，这一部分用数组来模拟</p><p>应用场景：银行排队案例</p><p>队列本身是有序列表，需要两个变量front和rear分别标记队列前后端，front随着数据输出而改变，rear随着数据输入而改变。还有需要一个maxSize来标记队列的最大容量。</p><p>当存数据入列时</p><ul><li>把尾指针后移：rear+1，当front=rear [ 空 ]</li><li>若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。<code>rear == maxSize-1</code> =&gt; 队列满</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;import java.util.Scanner;public class Queue &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;创建一个队列        ArrayQueue queue &#x3D; new ArrayQueue(3);        char key &#x3D; &#39; &#39;;        Scanner scan &#x3D; new Scanner(System.in);        boolean loop &#x3D; true;        &#x2F;&#x2F;输出一个菜单        while (loop) &#123;            System.out.println(&quot;s(show queue)&quot;);            System.out.println(&quot;e(exit)&quot;);            System.out.println(&quot;a(add)&quot;);            System.out.println(&quot;g(get)&quot;);            System.out.println(&quot;h(head)&quot;);            key &#x3D; scan.next().charAt(0);            switch (key) &#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;output a num:&quot;);                    int value &#x3D; scan.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.printf(&quot;get the num is: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                        break;                    &#125;                    break;                case &#39;h&#39;:                    &#x2F;&#x2F;查看队列头数据                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.printf(&quot;head data: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:&#x2F;&#x2F;退出                    scan.close();                    loop &#x3D; false;&#x2F;&#x2F;退出while循环                    break;                default:                    break;            &#125;        &#125;    &#125;&#125;class ArrayQueue &#123;    private int maxSize;&#x2F;&#x2F;数组最大容量    private int front;&#x2F;&#x2F;队列头    private int rear;&#x2F;&#x2F;队列尾    private int[] arr;&#x2F;&#x2F;该数组用于存放数据，模拟队列    &#x2F;&#x2F;创建队列的构造器    public ArrayQueue(int arrMaxSize) &#123;        maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];        front &#x3D; -1;&#x2F;&#x2F;指向队列头部，指向数据头部前一个位置        rear &#x3D; -1;&#x2F;&#x2F;指向队列尾，指向队列尾的数据(即队列最后一个数据)    &#125;    &#x2F;&#x2F;判断队列是否满    public boolean isFull() &#123;        return rear &#x3D;&#x3D; maxSize - 1;    &#125;    &#x2F;&#x2F;判断队列是否空    public boolean isEmpty() &#123;        return rear &#x3D;&#x3D; front;    &#125;    &#x2F;&#x2F;添加数据到队列    public void addQueue(int n) &#123;        &#x2F;&#x2F;判断队列是否满        if (isFull()) &#123;            System.out.println(&quot;the queue is full~~&quot;);            return;        &#125;        &#x2F;&#x2F;rear++;&#x2F;&#x2F;rear后移        &#x2F;&#x2F;arr[rear] &#x3D; n;        arr[++rear] &#x3D; n;&#x2F;&#x2F;这是上两行代码简写    &#125;    &#x2F;&#x2F;获取队列数据，出队列    public int getQueue() &#123;        &#x2F;&#x2F;判断是否为空        if (isEmpty()) &#123;            &#x2F;&#x2F;抛出异常            throw new RuntimeException(&quot;empty queue~~&quot;);        &#125;        front++;        return arr[front];    &#125;    &#x2F;&#x2F;显示队列所有数据    public void showQueue() &#123;        if (isEmpty()) &#123;            System.out.println(&quot;empty queue~~&quot;);            return;        &#125;        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i, arr[i]);        &#125;    &#125;    &#x2F;&#x2F;显示队列的头数据，不是取出数据    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty queue~~&quot;);        &#125;        return arr[front + 1];&#x2F;&#x2F;使front指向头数据    &#125;&#125;</code></pre><p>缺点：</p><ul><li>数组只能用一次</li></ul><p>优化：</p><ul><li>改进成为环形队列 算法思想：取模%</li></ul><h3 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h3><p>思路：</p><ul><li>front变量含义做一个调整：front指向队列第一个元素，也就是<code>arr[front]</code>就是队列第一个元素</li><li>rear变量含义做一个调整：rear指向队列最后一个元素的后一个位置。留出一个空间来判断队列是空或满</li><li>当队列满时，条件是：<code>(rear+1)&amp;maxSize == front</code>  =&gt;队列满</li></ul><p>队列中有效数据的个数 <code>(rear + maxSize - front) % maxSize</code></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class CircleArrayQueue &#123;    public static void main(String[] args) &#123;        CircleArray queue &#x3D; new CircleArray(4);&#x2F;&#x2F;队列有效数据是3        char key &#x3D; &#39; &#39;;        Scanner scan &#x3D; new Scanner(System.in);        boolean loop &#x3D; true;        &#x2F;&#x2F;输出一个菜单        while (loop) &#123;            System.out.println(&quot;s(show queue)&quot;);            System.out.println(&quot;e(exit)&quot;);            System.out.println(&quot;a(add)&quot;);            System.out.println(&quot;g(get)&quot;);            System.out.println(&quot;h(head)&quot;);            key &#x3D; scan.next().charAt(0);            switch (key) &#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;output a num:&quot;);                    int value &#x3D; scan.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.printf(&quot;get the num is: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                        break;                    &#125;                    break;                case &#39;h&#39;:                    &#x2F;&#x2F;查看队列头数据                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.printf(&quot;head data: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:                    scan.close();                    loop &#x3D; false;                    break;                default:                    break;            &#125;        &#125;    &#125;&#125;class CircleArray &#123;    private int maxSize;&#x2F;&#x2F;数组最大容量    private int front;&#x2F;&#x2F;队列头，队列的第一个元素，不一定是0    private int rear;&#x2F;&#x2F;队列尾    private int[] arr;&#x2F;&#x2F;该数组用于存放数据，模拟队列    public CircleArray(int arrMaxSize) &#123;        maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];        front &#x3D; 0;        rear &#x3D; 0;    &#125;    public boolean isFull() &#123;        return (rear + 1) % maxSize &#x3D;&#x3D; front;&#x2F;&#x2F;+1是利用了留出的空位来判断队列是否为满    &#125;    public boolean isEmpty() &#123;        return rear &#x3D;&#x3D; front;&#x2F;&#x2F;初始化时rear和front都是0，如果没有add，即可判断为空    &#125;    public void addQueue(int n) &#123;        if (isFull()) &#123;            System.out.println(&quot;full array~~&quot;);            return;        &#125;        arr[rear] &#x3D; n;&#x2F;&#x2F;直接把n赋给arr        rear &#x3D; (rear + 1) % maxSize;&#x2F;&#x2F;考虑取模    &#125;    public int getQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty array~~&quot;);        &#125;        &#x2F;&#x2F;这里要分析出front是指向队列的第一个元素        &#x2F;&#x2F;1.先把front对应的值保留到一个临时变量        &#x2F;&#x2F;2.把front后移        &#x2F;&#x2F;3.把临时保存的变量返回        int value &#x3D; arr[front];            front &#x3D; (front + 1) % maxSize;        return value;    &#125;    public void showQueue() &#123;        if (isEmpty()) &#123;            System.out.println(&quot;empty array~~&quot;);            return;        &#125;        for (int i &#x3D; front; i &lt; front + size(); i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i % maxSize, arr[i % maxSize]);        &#125;    &#125;    &#x2F;&#x2F;求出当前队列有效数据个数    public int size() &#123;        return (rear + maxSize - front) % maxSize;    &#125;    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty array~~&quot;);        &#125;        return arr[front];    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">简单记录稀疏数组的用法</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>js简单实现拦截访问指定网页</title>
    <link href="https://jaydenchang.top/post/0x001E.html"/>
    <id>https://jaydenchang.top/post/0x001E.html</id>
    <published>2021-08-03T16:00:00.000Z</published>
    <updated>2021-12-11T06:06:47.305Z</updated>
    
    <content type="html"><![CDATA[<p>最近闲的无事，写个脚本玩玩，实现拦截访问指定网址</p><h3 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h3><p>要想实现这个功能，就要自定义一个浏览器插件</p><p>最简单的浏览器插件有两个文件，分别是<code>manifest.json</code>和<code>**.js</code>。首先新建一个文件夹，然后在文件夹目录新建上述两个文件。</p><h4 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a><code>manifest.json</code></h4><p><a href='https://ask.dcloud.net.cn/article/94'> <code>manifest.json</code> </a>是插件的配置文件，用于描述插件的元数据，插件的配置信息</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;name&quot;: &quot;hello&quot;,    &quot;description&quot;: &quot;hello&quot;,    &quot;version&quot;: &quot;1.0&quot;,    &quot;manifest_version&quot;: 2,    &quot;content_scripts&quot;: [&#123;        &quot;matches&quot;: [            &#39;http:&#x2F;&#x2F;*&#x2F;*&#39;, &quot;https:&#x2F;&#x2F;*&#x2F;*&quot;        ],        &quot;js&quot;: [            &quot;test.js&quot;        ]    &#125;]&#125;</code></pre><p>这里的matches通配http和https，js对应的文件名一定要和自己命名的js相同(包括路径)</p><h4 id="test-js"><a href="#test-js" class="headerlink" title="test.js"></a><code>test.js</code></h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">var url;url &#x3D; window.location.host;&#x2F;&#x2F;获取当前网页urlif(url &#x3D;&#x3D; &#39;www.google.com.hk&#39; || url &#x3D;&#x3D; &#39;www.google.com&#39;)&#123;    alert(&quot;反正你就是打不开这个页面doge&quot;);    window.location.href &#x3D; &#39;cn.bing.com&#39;;&#x2F;&#x2F;跳转到指定页面&#125;</code></pre><h3 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h3><p>edge用户在浏览器输入<code>edge://extensions</code>，chrome用户在浏览器输入<code>chrome://extensions</code> <del>(其他浏览器没用过)</del> ，然后把刚才装json和js的文件夹拖动到刚才打开的页面，重启浏览器就好了。</p>]]></content>
    
    
    <summary type="html">写了一个脚本来拦截网页</summary>
    
    
    
    <category term="FrontEnd" scheme="https://jaydenchang.top/categories/FrontEnd/"/>
    
    
    <category term="JavaScript" scheme="https://jaydenchang.top/tags/JavaScript/"/>
    
    <category term="技术" scheme="https://jaydenchang.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>练字时我在想什么</title>
    <link href="https://jaydenchang.top/post/0x001C.html"/>
    <id>https://jaydenchang.top/post/0x001C.html</id>
    <published>2021-07-19T16:00:00.000Z</published>
    <updated>2021-12-11T06:07:22.127Z</updated>
    
    <content type="html"><![CDATA[<p>最近几天在练字，在练字时，脑子里有些奇怪的想法，趁着现在有时间，把自己的想法记录下</p><h4 id="小学"><a href="#小学" class="headerlink" title="小学"></a>小学</h4><p>犹记得是在四年级时，我看着爸妈、老师写连笔字很帅，于是也自己尝试写，就在我开始写连笔字的第二天，班主任发现不对，马上私信我爸妈，在我爸妈的连哄带骗下，我开始练字，练的啥呢，正楷，每天中午放学回家恰饭前就拿出字帖来练，字帖嘛，照着描，当时我给老师看了，嗯，写出来还是不错的，当字帖换成作业本时，他傻了，差点嘴吐芬芳，于是我又开始练字，就这样我练到了小学毕业，感觉也没什么长进，写出来有时候我都不知道自己在写啥 (<del>年代久远，小学的作业本找不到就不放图了</del>)</p><h4 id="初中"><a href="#初中" class="headerlink" title="初中"></a>初中</h4><p>刚进班级，我的班主任就注意到了我的字，马上找我和我爸妈谈话，毕竟我现在的字在中考上很吃亏，不过班主任没有让我去练正楷，让我去学一点行楷。好在我初中老师和我一些同学的字都比较好看，我时不时去模仿他们的字迹。</p><p>在初二时，我偶然知道，井柏然的字很好看，于是我去搜索他的微博，我勒个去，这是神仙写的字吧</p><p><a href='https://weibo.com/boranjing?is_all=1&is_search=1&key_word=手写'>井柏然的微博–#手写微博</a></p><p>正巧，当时小米收录了井柏然的字，我咬咬牙，省了几天生活费，买了下来装到手机上，在此之后我的字和以前有一些不一样了，虽然带有一点点点文艺范，但字本质上还是很潦草，特别是是写语文和政治时，心疼改卷老师φ(゜▽゜*)♪</p><p><del>(感觉也找不到以前的作业本了)</del></p><h4 id="高中"><a href="#高中" class="headerlink" title="高中"></a>高中</h4><p>让我的字开始定型是在我高一文理分科时，我注意到了我舍友的字，哎呀word麻鸭，这恰到好处的布局，word麻鸭，这刚劲有力的笔锋，word麻鸭，这行云流水的笔顺……真是妙到了米奇妙妙屋</p><p>放一张我高一的字</p><img src='https://jaydenchang.gitee.io/images/images/0x001C-1.jpg' style="border-radius: 5em; zoom: 20%;"><p>当时的我，觉得自己写的比初中好些了，不过，每到语文考试40min极限作文时，我的字又打回原形。</p><p>大概是在高三吧，那时候我开始写日记，经常和我舍友交流问题，两人在讨论过程就开始练字，在这个阶段了，我的字又有了质的飞跃<del>(感觉也就那样)</del>。</p><h4 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h4><p>大学里，关于练字这个话题，我身边比较少有人练字，都程序员了，练什么字，敲代码不香吗。曾经我试过3天没摸笔，果然，提笔忘字，这让我很是头疼，没办法，只能减少打代码时间，每天抽出10分钟写点字。然后就是大一下的思想汇报，写了大概几千字吧，是一个很好的练字机会，很庆幸当时自己能把自己摁下来乖乖一笔一划写好每个字<del>(有错字整页无了)</del>。</p><p>大一暑假，终于有时间练字了，还是照着井柏然的微博来练，坐在书桌前，听着周杰伦和林俊杰的歌，一笔一划，有种坐在咖啡厅里的感觉。</p><img src='https://jaydenchang.gitee.io/images/images/0x001C-2.jpg' style='border-radius:5em;zoom:20%;border-color:lightskyblue;'><img src='https://jaydenchang.gitee.io/images/images/0x001C-3.jpg' style='border-radius:5em;zoom:20%;border-color:lightskyblue;'><p>练字也有一周了，练字时我在想什么呢，答案是，什么也没想，看着别人的字，自己一笔一划照着写一遍，那种成就感、新鲜感无法形容，另外再配上林俊杰的歌，那环境简直惬意到起飞，那段时间，也是最容易迸发灵感的。</p><p>截止要到截稿时，我再回过头去看看我前几天写的字，突然感觉也没那么好看了，人嘛，就是在这样不断批判以前的自己中成长，寻之错并改之。练字真的是非常畅快的体验<del>(前提是内心要平静)</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近几天在练字，在练字时，脑子里有些奇怪的想法，趁着现在有时间，把自己的想法记录下&lt;/p&gt;
&lt;h4 id=&quot;小学&quot;&gt;&lt;a href=&quot;#小学&quot; class=&quot;headerlink&quot; title=&quot;小学&quot;&gt;&lt;/a&gt;小学&lt;/h4&gt;&lt;p&gt;犹记得是在四年级时，我看着爸妈、老师写连笔字很帅，于是也自己尝试写，就在我开始写连笔字的第二天，班主任发现不对，马上私信我爸妈，在我爸妈的连哄带骗下，我开始练字，练的啥呢，正楷，每天中午放学回家恰饭前就拿出字帖来练，字帖嘛，照着描，当时我给老师看了，嗯，写出来还是不错的，当字帖换成作业本时，他傻了，差点嘴吐芬芳，于是我又开始练字，就这样我练到了小学毕业，感觉也没什么长进，写出来有时候我都不知道自己在写啥 (&lt;del&gt;年代久远，小学的作业本找不到就不放图了&lt;/del&gt;)&lt;/p&gt;
&lt;h4 id=&quot;初中&quot;&gt;&lt;a href=&quot;#初中&quot; class=&quot;headerlink&quot; title=&quot;初中&quot;&gt;&lt;/a&gt;初中&lt;/h4&gt;&lt;p&gt;刚进班级，我的班主任就注意到了我的字，马上找我和我爸妈谈话，毕竟我现在的字在中考上很吃亏，不过班主任没有让我去练正楷，让我去学一点行楷。好在我初中老师和我一些同学的字都比较好看，我时不时去模仿他们的字迹。&lt;/p&gt;
&lt;p&gt;在初二时，我偶然知道，井柏然的字很好看，于是我去搜索他的微博，我勒个去，这是神仙写的字吧&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://weibo.com/boranjing?is_all=1&amp;is_search=1&amp;key_word=手写&quot;&gt;井柏然的微博–#手写微博&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正巧，当时小米收录了井柏然的字，我咬咬牙，省了几天生活费，买了下来装到手机上，在此之后我的字和以前有一些不一样了，虽然带有一点点点文艺范，但字本质上还是很潦草，特别是是写语文和政治时，心疼改卷老师φ(゜▽゜*)♪&lt;/p&gt;
&lt;p&gt;&lt;del&gt;(感觉也找不到以前的作业本了)&lt;/del&gt;&lt;/p&gt;
&lt;h4 id=&quot;高中&quot;&gt;&lt;a href=&quot;#高中&quot; class=&quot;headerlink&quot; title=&quot;高中&quot;&gt;&lt;/a&gt;高中&lt;/h4&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://jaydenchang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://jaydenchang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>接口和包</title>
    <link href="https://jaydenchang.top/post/0x001B.html"/>
    <id>https://jaydenchang.top/post/0x001B.html</id>
    <published>2021-07-17T16:00:00.000Z</published>
    <updated>2021-12-06T12:31:35.097Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="定义及基础用法"><a href="#定义及基础用法" class="headerlink" title="定义及基础用法"></a>定义及基础用法</h4><p>interface定义：没有字段的抽象类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface person&#123;    void hello();    String getName();&#125;&#x2F;*接口本质上就是抽象类abstract class person&#123;public abstract void fun();public abstract String getName();&#125;*&#x2F;</code></pre><p>如上代码，方法没有具体化，在需要调用的类里面通过覆写来实现具体功能，多个类之间重新覆写的功能相互不影响。继承接口时，一定要覆写接口里的所有方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class student implements person&#123;    private String name;    public student(String name)&#123;        this.name &#x3D; name;    &#125;    @override    public void hello()&#123;        System.out.print(&quot;hello, &quot; + this.name);    &#125;    @override    public String getName()&#123;        return this.name;    &#125;&#125;class teacher implements person&#123;    private String name;    public student(String name)&#123;        this.name &#x3D; name;    &#125;    @override    public void hello()&#123;        System.out.print(&quot;hello, Mr&#x2F;Mrs.&quot; + this.name);    &#125;    @override    public String getName()&#123;        return this.name;    &#125;&#125;</code></pre><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>普通类继承中，只能继承一个类，而接口可实现多继承</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class teacher implements person, parents&#123;&#x2F;**&#x2F;&#125;</code></pre><p>一个interface可以继承自另一个interface</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface hello&#123;    void hello();&#125;interface person extends hello&#123;    void fun();    String getName();    &#x2F;&#x2F;此时，person接口实际上有三个抽象方法前面，其中一个继承自hello&#125;</code></pre><h4 id="abstract和interface对比"><a href="#abstract和interface对比" class="headerlink" title="abstract和interface对比"></a>abstract和interface对比</h4><blockquote><p>abstract</p><ul><li>定义实例字段</li><li>定义抽象方法</li><li>定义非抽象方法</li><li>but，只能extends一个class</li></ul></blockquote><blockquote><p>interface</p><ul><li>可以implements多个interface</li><li>定义抽象方法</li><li>定义default方法</li><li>but，不能定义实例字段</li></ul></blockquote><br><h4 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa &#123;    public static void main(String[] args) &#123;        person p &#x3D; new student(&quot;aaaaa&quot;);        p.fun();    &#125;&#125;interface person &#123;    String getName();    default void fun() &#123;        System.out.println(getName() + &quot; fun()&quot;);    &#125;&#x2F;&#x2F;default修饰具体方法&#125;class student implements person &#123;    private String name;    public student(String name) &#123;        this.name &#x3D; name;    &#125;    public String getName() &#123;        return this.name;    &#125;    &#x2F;&#x2F;在这个例子中，student类就没有去重新覆写fun()函数&#125;</code></pre><p>当接口新增一个方法时，会涉及到修改全部子类，如果新增的是default方法，子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法</p><p>default和抽象类的普通方法是不太一样的，interface没有字段，default无法访问字段，而抽象类的普通方法可以访问实例字段。不过在interface中，default可以修饰具体方法</p><h4 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa &#123;    public static void main(String[] args) &#123;        person.setNumber(99);        System.out.println(person.number);    &#125;&#125;class person &#123;    public static int number;    public static void setNumber(int value) &#123;        number &#x3D; value;    &#125;&#125;</code></pre><p>静态方法属于class不属于实例，可以直接通过类名来调用</p><h4 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h4><p>尽管interface是纯抽象类，但它可以有静态字段，静态字段必须是final类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;person.javapublic interface person&#123;    public static final int male &#x3D; 1;    public static final int female &#x3D; 2;&#125;</code></pre><p>实际上，因为interface的字段只能是<code>public static final</code>类型，所以我们可以把int前面的修饰符去掉</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;person.javapublic interface person&#123;    int male &#x3D; 1;    int female &#x3D; 2;    &#x2F;&#x2F;编译器会自动把该字段变为public static final类型&#125;</code></pre><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>例如，在同一文件夹下，a写了一个person类，b也写了一个person类，c想用a和b的person类，这时候引入包(package)的概念</p><blockquote><p>aa.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;class person&#123;&#125;public class aa&#123;&#125;</code></pre><blockquote><p>bb.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;class person&#123;&#125;public class bb&#123;&#125;</code></pre><p>包可以是多层结构，用<code>.</code>隔开，例如<code>java.util</code></p><p>:::tip</p><p>包没有父子关系，<code>java.util</code>和<code>java.util.zip</code>是不同的包，两者没有继承关系</p><p>:::</p><h4 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h4><p>:::tip</p><p>例如，如果想要定义包hello，则需要新建一个文件夹并命名为hello，文件夹下存放有hello包的Java文件</p><p>:::</p><blockquote><p><code>hello\person.java</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;public class person&#123;    void hello()&#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;</code></pre><blockquote><p><code>hello\main.java</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;public class main&#123;    public static void main(String[] args)&#123;        person p &#x3D; new person();        p.hello();&#x2F;&#x2F;result: hello    &#125;&#125;</code></pre><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>在一个class中，我们会引用其他的class，例如，Jay的<code>person.jay</code>类，如果要引用jjlin的<code>hello.jjlin</code>类，需要引入这个包</p><blockquote><p><code>hello\jjlin.java</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;jjlin.javapackage hello;public class jjlin&#123;    public void fun()&#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;</code></pre><blockquote><p><code>person\jay.java</code></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;jay.javapackage person;import hello.jjlin;&#x2F;&#x2F;表示引入hello文件夹下的jjlin文件public class jay&#123;    public void run()&#123;        jjlin temp &#x3D; new jjlin();    &#125;&#125;</code></pre><p>除了引入包下的具体类，也可以使用*，把包下的所有class都导入进来(不辨认子包的class)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package person;import jay.*;&#x2F;&#x2F;引入jay文件夹下所有classpublic class jay&#123;    public void run()&#123;        jjlin temp &#x3D; new jjlin();    &#125;&#125;</code></pre><h4 id="import-static"><a href="#import-static" class="headerlink" title="import static"></a>import static</h4><p>此方法可以导入一个类的静态字段和静态方法，此语法比较少用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;package main;import static java.lang.System.*;&#x2F;&#x2F;导入System类的所有静态字段和静态方法public class main&#123;    public static void main(String[] args)&#123;        out.println(&quot;hello&quot;);        &#x2F;&#x2F;如果不引用System包，则要写成下面形式        &#x2F;&#x2F;System.out.println(&quot;hello&quot;);            &#125;&#125;</code></pre><p>Java编译器最终编译出的<code>.class</code>文件只是用完整类名，因此，在代码中，当编译器遇到一个class名称时：</p><ul><li>如果是完整类名，就直接根据完整类名来查找这个class</li><li>如果是简单类名，依次按照下面的顺序依次查找<ul><li>查找当前package是否存在这个class</li><li>查找import包是否含有这个class</li><li>查找<code>java.lang</code>包是否含有这个class</li></ul></li></ul><p>如果按照上面规则还无法确定类名，则编译报错</p><p>下面是一个例子</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;main.javapackage test;import java.text.Format;public class main&#123;    public static void main(String[] args)&#123;        java.util.list list;&#x2F;&#x2F;ok，使用完整类名        Format format &#x3D; null;&#x2F;&#x2F;ok，使用import的类        String s &#x3D; &quot;hi&quot;;&#x2F;&#x2F;ok，使用java.lang的包的String        System.out.println(s);&#x2F;&#x2F;ok，使用java.lang的包的System        MessageFormat mf &#x3D; null;&#x2F;&#x2F;错误，无法找到MessageFormat    &#125;&#125;</code></pre><p>因此在编写class时，编译器会自动帮我们做两个import动作</p><ul><li>默认自动import当前package的其他class</li><li>默认<code>import java.lang.*</code></li></ul><p>:::tip</p><p>自动导入的是<code>java.lang</code>的包，但类似<code>java.lang.reflect</code>这些包还需要手动导入</p><p>:::</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>为避免名字冲突，我们需要确定唯一的包名，推荐使用倒置的域名来确保唯一性</p><ul><li><code>org.apache</code>，本质上是<code>/org/apache/</code>路径下的class，下同</li><li><code>org.apache.commons.log</code></li><li><code>com.jayden.sample</code></li></ul><p>子包就可以根据功能自行命名</p><p>注意不要和<code>java.lang</code>的包的类重名</p><ul><li><code>String</code></li><li><code>System</code></li><li><code>Runtime</code></li><li>…</li></ul><p>也不要和jdk常用的类重名</p><ul><li><code>java.util.List</code></li><li><code>java.text.Format</code></li><li><code>java.math.BigInteger</code></li><li>…</li></ul><p><a href='https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816'>参考链接-廖雪峰-Java-面向对象编程-接口</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976">参考链接-廖雪峰-Java-面向对象编程-包</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h3&gt;&lt;h4 id=&quot;定义及基础用法&quot;&gt;&lt;a href=&quot;#定义及基础用法&quot; class=&quot;headerlink&quot; title=&quot;定义及基础用法&quot;&gt;&lt;/a&gt;定义及基础用法&lt;/h4&gt;&lt;p&gt;interface定义：没有字段的抽象类&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;interface person&amp;#123;
    void hello();
    String getName();
&amp;#125;
&amp;#x2F;*接口本质上就是抽象类
abstract class person&amp;#123;
	public abstract void fun();
	public abstract String getName();
&amp;#125;
*&amp;#x2F;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码，方法没有具体化，在需要调用的类里面通过覆写来实现具体功能，多个类之间重新覆写的功能相互不影响。继承接口时，一定要覆写接口里的所有方法&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;class student implements person&amp;#123;
    private String name;
    public student(String name)&amp;#123;
        this.name &amp;#x3D; name;
    &amp;#125;
    @override
    public void hello()&amp;#123;
        System.out.print(&amp;quot;hello, &amp;quot; + this.name);
    &amp;#125;
    @override
    public String getName()&amp;#123;
        return this.name;
    &amp;#125;
&amp;#125;
class teacher implements person&amp;#123;
    private String name;
    public student(String name)&amp;#123;
        this.name &amp;#x3D; name;
    &amp;#125;
    @override
    public void hello()&amp;#123;
        System.out.print(&amp;quot;hello, Mr&amp;#x2F;Mrs.&amp;quot; + this.name);
    &amp;#125;
    @override
    public String getName()&amp;#123;
        return this.name;
    &amp;#125;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;多继承&quot;&gt;&lt;a href=&quot;#多继承&quot; class=&quot;headerlink&quot; title=&quot;多继承&quot;&gt;&lt;/a&gt;多继承&lt;/h4&gt;&lt;p&gt;普通类继承中，只能继承一个类，而接口可实现多继承&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;class teacher implements person, parents&amp;#123;&amp;#x2F;**&amp;#x2F;&amp;#125;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个interface可以继承自另一个interface&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于面向对象编程</title>
    <link href="https://jaydenchang.top/post/0x001A.html"/>
    <id>https://jaydenchang.top/post/0x001A.html</id>
    <published>2021-07-13T16:00:00.000Z</published>
    <updated>2021-12-06T12:31:35.097Z</updated>
    
    <content type="html"><![CDATA[<p>暑假预习Java，这里总结下面向对象中Java和C++一些不一样的地方</p><h3 id="super"><a href="#super" class="headerlink" title="super();"></a><code>super();</code></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">class person &#123;    protected int age;    public person(int age) &#123;        this.age &#x3D; age;    &#125;&#125;class student extends person &#123;    protected int score;    public student(int age,int score) &#123;        &#x2F;&#x2F;super(age);        this.score &#x3D; score;    &#125;&#125;</code></pre><p>如果没有使用super，会得到一个编译错误，在student的构造方法中，无法调用person的构造方法</p><p>在java里，任何class的构造方法，第一行必须调用父类的构造方法，如果没有明确地调用父类的构造方法，编译器会自动加一句<code>super();</code>，but，这个super里没有参数，父类里没有无参数的构造方法，故编译失败，因此，需要把注释去掉，加上正确的super语句</p><h3 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h3><h4 id="官方版"><a href="#官方版" class="headerlink" title="官方版"></a>官方版</h4><blockquote><p>aa.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class aa&#123;&#x2F;* code *&#x2F;&#125;</code></pre><p>用<code>final</code>来修饰指定类</p><blockquote><p>bb.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class bb extends aa&#123;&#x2F;* code *&#x2F;&#125;</code></pre><p>编译完第一个类后再编译第二个类，JDK编译器会报错，编译器会在extends处提示错误</p><h4 id="非官方版"><a href="#非官方版" class="headerlink" title="非官方版"></a>非官方版</h4><blockquote><p>aa.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa&#123;    private aa()&#123;&#x2F;**&#x2F;&#125;    public static aa fun()&#123;        return new aa();    &#125;&#125;</code></pre><p>Java在继承时必须在构造器里的第一行调用super class的构造器。当父类构造器设为private权限时，其他类继承这个类时，编译器会尝试调用一个默认的super构造器，而super构造器时private的，就不能被调用，也就是不能被继承。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote><p>aa.java</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa&#123;    public static void main(String[] args)&#123;        person p &#x3D; new student();        p.run();        &#x2F;&#x2F;result: student.run    &#125;&#125;class person&#123;    public void fun()&#123;        System.out.println(&quot;person.run&quot;);    &#125;&#125;class student&#123;@override    &#x2F;&#x2F;override后面不要加分号    public void fun()&#123;        System.out.print(&quot;student.run&quot;);    &#125;&#125;</code></pre><p>下面是一个报税的例子</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa &#123;    public static void main(String[] args) &#123;        income[] incomes &#x3D; new income[] &#123; new income(3000), new salary(7000), new allowance(10000) &#125;;        System.out.println(totalTax(incomes));        &#x2F;&#x2F;打印的结果是income，salary，allowance折扣后的总值    &#125;    public static double totalTax(income... incomes) &#123;        double total &#x3D; 0;        for (income in : incomes) &#123;            total +&#x3D; in.getTax();        &#125;        return total;    &#125;&#125;class income &#123;    &#x2F;&#x2F;收入    protected double in;    public income(double in) &#123;        this.in &#x3D; in;    &#125;    public double getTax() &#123;        return in * 0.1;    &#125;&#125;class salary extends income &#123;    &#x2F;&#x2F;工资    public salary(double in) &#123;        super(in);    &#125;    @Override    public double getTax() &#123;        if (in &lt;&#x3D; 5000)            return 0;        return (in-5000)*0.2;    &#125;&#125;class allowance extends income &#123;    &#x2F;&#x2F;特殊津贴    public allowance(double in) &#123;        super(in);    &#125;    @Override    public double getTax() &#123;        return 0;    &#125;&#125;</code></pre><h3 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">class person&#123;    protected String name;    public String hello()&#123;        return &quot;hello, &quot; + name;    &#125;&#125;class student extends person&#123;    @override    public String hello()&#123;        &#x2F;&#x2F;调用父类的hello()方法        return super.hello() + &quot;!&quot;;    &#125;&#125;</code></pre><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">class aa&#123;    public final String fun()&#123;&#x2F;**&#x2F;&#125;&#125;class bb&#123;@override    public String fun()&#123;&#x2F;**&#x2F;&#125;    &#x2F;&#x2F;父类成员用final修饰，子类不能重写    &#x2F;&#x2F;final修饰类，类不能被继承，final修饰变量，变量必须初始化&#125;</code></pre><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;定义一个抽象类class person&#123;    public abstract void fun();&#125;</code></pre><p>把一个方法声明为abstract，提示编译错误，无法编译person类，因为它包含抽象方法，所以必须把person也声明为abstract，这就叫抽象类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">abstract class person&#123;    public abstract void fun();&#125;</code></pre><p>但是，对于person类，我们无法使他实例化，即在main中执行<code>person p = new person();</code></p><p>因此，抽象类一般被设计来继承</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class aa &#123;    public static void main(String[] args) &#123;        person p &#x3D; new student();        person t &#x3D; new teacher();        p.fun();        t.fun();    &#125;&#125;abstract class person &#123;    public abstract void fun();&#125;class student extends person &#123;    @Override    public void fun() &#123;        System.out.println(&quot;student.fun&quot;);    &#125;&#125;class teacher extends person&#123;    @override    public void fun()&#123;        System.out.println(&quot;teacher.fun&quot;);    &#125;&#125;</code></pre><p>如上例子，person定义了抽象方法<code>fun()</code>，那么在实现子类时，就必须覆写<code>run()</code></p><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>刚才定义了抽象类<code>person()</code>，以及具体的student、teacher的子类，我们可以通过抽象类person去引用具体的子类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">person s &#x3D; new student();person t &#x3D; new teacher();</code></pre><p>这种引用抽象类的好处在于，我们调用其方法，并不关心person类型变量的具体子类型</p><pre class="line-numbers language-none"><code class="language-none">s.fun();t.fun();</code></pre><p>同样的，我们再用用一个新的子类，我们仍不关心具体类型。</p><p>因此，这种尽量引用高层类型，避免引用实际子类型的方式，叫面向对象编程</p><p>三个本质</p><ul><li>上层代码只定义规范(例如<code>abstract class person;</code>)；</li><li>不需要子类就可以实现业务逻辑(正常编译)</li><li>实现的业务逻辑由不同的子类实现，调用者并不关心</li></ul><p>:::tip</p><p>一个java文件里只能有一个public类</p><p>:::</p><p><del>感觉我的面向对象编程是在Java里学的</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;暑假预习Java，这里总结下面向对象中Java和C++一些不一样的地方&lt;/p&gt;
&lt;h3 id=&quot;super&quot;&gt;&lt;a href=&quot;#super&quot; class=&quot;headerlink&quot; title=&quot;super();&quot;&gt;&lt;/a&gt;&lt;code&gt;super();&lt;/code&gt;&lt;/h3&gt;&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;class person &amp;#123;
    protected int age;

    public person(int age) &amp;#123;
        this.age &amp;#x3D; age;
    &amp;#125;
&amp;#125;

class student extends person &amp;#123;
    protected int score;

    public student(int age,int score) &amp;#123;
        &amp;#x2F;&amp;#x2F;super(age);
        this.score &amp;#x3D; score;
    &amp;#125;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有使用super，会得到一个编译错误，在student的构造方法中，无法调用person的构造方法&lt;/p&gt;
&lt;p&gt;在java里，任何class的构造方法，第一行必须调用父类的构造方法，如果没有明确地调用父类的构造方法，编译器会自动加一句&lt;code&gt;super();&lt;/code&gt;，but，这个super里没有参数，父类里没有无参数的构造方法，故编译失败，因此，需要把注释去掉，加上正确的super语句&lt;/p&gt;
&lt;h3 id=&quot;阻止继承&quot;&gt;&lt;a href=&quot;#阻止继承&quot; class=&quot;headerlink&quot; title=&quot;阻止继承&quot;&gt;&lt;/a&gt;阻止继承&lt;/h3&gt;&lt;h4 id=&quot;官方版&quot;&gt;&lt;a href=&quot;#官方版&quot; class=&quot;headerlink&quot; title=&quot;官方版&quot;&gt;&lt;/a&gt;官方版&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;aa.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public final class aa&amp;#123;&amp;#x2F;* code *&amp;#x2F;&amp;#125;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&lt;code&gt;final&lt;/code&gt;来修饰指定类&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于css的一些动画</title>
    <link href="https://jaydenchang.top/post/0x0018.html"/>
    <id>https://jaydenchang.top/post/0x0018.html</id>
    <published>2021-07-07T16:00:00.000Z</published>
    <updated>2021-12-11T05:57:02.470Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为期末复习周，博客更新鸽了很久，趁着考完试还记得这件事，把之前的大作业里出现过的css动画总结一下</p><h3 id="页脚的联系方式图标"><a href="#页脚的联系方式图标" class="headerlink" title="页脚的联系方式图标"></a>页脚的联系方式图标</h3><p>这个图片原型是一个静态图</p><img src='https://jaydenchang.gitee.io/images/images/footer-sprit.png'><p>动画效果如下</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-3.gif' style="zoom:67%;" ><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div class&#x3D;&#39;footer&#39;&gt;    &lt;div class&#x3D;&#39;container&#39;&gt;        &lt;div class&#x3D;&#39;footer-main&#39;&gt;            &lt;div class&#x3D;&#39;col-md-6 footer-left&#39;&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;a href&#x3D;&#39;#&#39;&gt;&lt;span class&#x3D;&#39;fb&#39;&gt; &lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                    &lt;li&gt;&lt;a href&#x3D;&#39;#&#39;&gt;&lt;span class&#x3D;&#39;twit&#39;&gt; &lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                    &lt;li&gt;&lt;a href&#x3D;&#39;#&#39;&gt;&lt;span class&#x3D;&#39;in&#39;&gt; &lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                &lt;&#x2F;ul&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">.footer&#123;    background: #3193d1;&#x2F;*可选，动画的父级div的背景颜色*&#x2F;    padding: 2em 0;    width: 100%;&#x2F;*decide by yourself*&#x2F;    margin-left: 0;&#125;.footer-left ul&#123;    padding: 0;&#125;.footer-left ul li&#123;    list-style: none;    display: inline-block;&#125;.footer-left ul li span&#123;    background-image: url(..&#x2F;img&#x2F;footer-sprit.png);    width: 30px;    height: 30px;    &#x2F;*这样设置行高考虑到图片的大小，只展现这么大的方块来显示图标*&#x2F;    display: block;    &#x2F;*以块形式呈现元素*&#x2F;    transition: 0.5s all;    -webkit-transition:0.5s all;-moz-transition:0.5s all;-o-transition:0.5s all;-ms-transition:0.5s all;    &#x2F;*display on different browsers*&#x2F;&#125;.footer-left ul li span.fb&#123;    background-position: 0 0;&#125;.footer-left ul li span.twit&#123;    background-position: -30px 0;    &#x2F;*向右移动30px，显示中上位置的图标*&#x2F;&#125;.footer-left ul li span.in&#123;    background-position: -60px 0;&#125;.footer-left ul li span.fb:hover&#123;background-position:0px -30px;    &#x2F;*第一个参数是向左偏移，第二个是向下偏移，取负数则向相反的方向移动*&#x2F;&#125;.footer-left ul li span.twit:hover&#123;background-position:-30px -30px;&#125;.footer-left ul li span.in:hover&#123;background-position:-60px -30px;&#125;</code></pre><h3 id="展示板块"><a href="#展示板块" class="headerlink" title="展示板块"></a>展示板块</h3><p>该展示板块用css过渡，鼠标指针悬浮出现动画</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-1.gif'><h4 id="html-1"><a href="#html-1" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div class&#x3D;&#39;mg&#39; style&#x3D;&#39;margin-left: 20px&#39;&gt;    &lt;div class&#x3D;&#39;tile&#39; style&#x3D;&#39;margin-left: 120px&#39;&gt;        &lt;div class&#x3D;&#39;text11&#39;&gt;            &lt;h1&gt;text&lt;&#x2F;h1&gt;            &lt;!--&lt;img src&#x3D;&#39;#&#39;&gt; 方块的背景图--&gt;            &lt;h2 class&#x3D;&#39;animate-text&#39;&gt;text&lt;&#x2F;h2&gt;            &lt;p class&#x3D;&#39;animate-text&#39;&gt;text&lt;&#x2F;p&gt;            &lt;div class&#x3D;&#39;dots&#39;&gt;                &lt;span&gt;&lt;&#x2F;span&gt; &lt;span&gt;&lt;&#x2F;span&gt; &lt;span&gt;&lt;&#x2F;span&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">.mg .tile&#123;margin-left: 120px&#125;.tile &#123;    width: 570px;    height: 300px;    margin: 20px;    background-color: #99aeff;&#x2F;*加载动画后的方块的颜色*&#x2F;    display: inline-block;    &#x2F;*block和inline-block的区别，前者独占一行，后者可以并排*&#x2F;    background-size: cover;&#x2F;*把图片放大到元素容器合适的尺寸*&#x2F;    &#x2F;*如果设置一个100%，平铺x轴，两个100%铺满容器，图片可能会被拉伸*&#x2F;    position: relative;    cursor: pointer;    transition: all 0.4s ease-out;    &#x2F;*默认值为all 0 ease    all是设置过渡效果 第一个数字是过渡时间 ease是一个函数，用来控制过渡的快慢状态*&#x2F;    box-shadow: 0px 35px 77px -17px rgba(0, 0, 0, 0.44);    &#x2F;*四个数字，水平阴影位置，垂直阴影位置，模糊距离(可选)，阴影大小(可选)，阴影颜色*&#x2F;    overflow: hidden;&#x2F;*隐藏溢出部分*&#x2F;    color: white;    font-family: &#39;HPE&#39;;&#125;</code></pre><h3 id="read-more"><a href="#read-more" class="headerlink" title="read more"></a>read more</h3><p>同上一个，也是通过指针悬浮来显示动画</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-2.gif'><h4 id="html-2"><a href="#html-2" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div class&#x3D;&#39;tool&#39;&gt;    &lt;a class&#x3D;&#39;tooltips&#39; href&#x3D;&#39;#&#39;&gt;&lt;span&gt;Read more&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="css-2"><a href="#css-2" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">.tool&#123;position: relative; display: inline;&#125;a.tooltips span &#123;position: absolute;width: 168px;background: #FFFFFF;border: 2px solid #ea5b60;height: 42px;text-align: center;color: #000;padding: 14px 0px 0px 0px;&#125;a.tooltips span:hover &#123;background: #ea5b60;color: #fff;transition: 0.5s all;-webkit-transition: 0.5s all;-moz-transition: 0.5s all;-o-transition: 0.5s all;-ms-transition: 0.5s all;&#125;a.tooltips span:before &#123;content: &#39;&#39;;position: absolute;top: 22%;left: 81%;margin-left: -12px;width: 0;height: 0;border-top: 29px solid #ea5b60;border-right: 28px solid transparent;border-left: 28px solid transparent;transform: rotate(90deg);&#125;a.tooltips span:after &#123;content: &#39;&#39;;position: absolute;top: 21%;left: 79%;margin-left: -8px;width: 0;height: 0;border-top: 30px solid #FFFFFF;border-right: 31px solid transparent;border-left: 30px solid transparent;transform: rotate(90deg);&#125;.container1&#123;    padding-right: 15px;    padding-left: 15px;    margin-left: auto;    margin-right: auto;&#125;</code></pre><h3 id="划线动态"><a href="#划线动态" class="headerlink" title="划线动态"></a>划线动态</h3><p>在文字上下方加动态划线</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-4.gif'><h4 id="html-3"><a href="#html-3" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div class&#x3D;&#39;text1&#39;&gt;    &lt;a href&#x3D;&#39;#&#39;&gt;text&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="css-3"><a href="#css-3" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">.text1&#123;    position: relative;&#125;.text1::before,.text1::after&#123;  content: &quot;&quot;;  z-index: -1;  position: absolute;  left: 0;  right: 0;  height: 2px;  background: lightskyblue;  transform: scaleX(0);  transition: transform 0.2s ease-in-out;&#125;.text1::before&#123;    top: 0;    tranform-origin: center right;&#125;.text1::after&#123;    bottom: 0;    transform-origin: center left;&#125;.text1:hover&#123;cursor: pointer;&#125;.text1:hover::before&#123;    transform-origin: center left;    transform: scaleX(1);&#125;.text:hover::after&#123;    transform-origin: center right;    transform: sclaeX(1);&#125;</code></pre><h3 id="划线动画-升级版"><a href="#划线动画-升级版" class="headerlink" title="划线动画(升级版)"></a>划线动画(升级版)</h3><p>在上一个的基础上，对相关元素重写，呈现如下图效果</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-5.gif'><h4 id="html-4"><a href="#html-4" class="headerlink" title="html"></a>html</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div class&#x3D;&quot;row&quot;&gt;    &lt;div class&#x3D;&quot;type both clock&quot;&gt;text        &lt;div class&#x3D;&quot;inner&quot;&gt;&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="css-4"><a href="#css-4" class="headerlink" title="css"></a>css</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">.type &#123;    position: relative;    &#x2F;* font-size: 1em; *&#x2F;    &#x2F;* 不加relative会显示全屏划线 *&#x2F;&#125;.type .inner &#123;    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;&#125;&#x2F;* 如果说只要上下或者左右划线动画，可以不用加.inner标签，如果需要四条边，则需要加上.inner标签的before和after，并设置相关属性 *&#x2F;.type::before, .type::after, .type .inner::before, .type .inner::after&#x2F;* 这里有个一定要设置四个对象，一个对象对应一条边，before对应左和上，after对应右和下 *&#x2F;    &#123;    position: absolute;    content: &#39;&#39;;    display: block;    background: lightskyblue;    -webkit-transition: -webkit-transform 1s;    transition: -webkit-transform 1s;    transition: transform 1s;    transition: transform 1s, -webkit-transform 1s;&#125;.type.both::before, .type.both::after &#123;    left: 0;    width: 100%;    height: 2px;    -webkit-transform: scaleX(0);    transform: scaleX(0);&#125;.type.both .inner::after, .type.both .inner::before &#123;    top: 0;    width: 2px;    height: 100%;    -webkit-transform: scaleY(0);    transform: scaleY(0);&#125;.type.both .inner::before &#123;    left: 0;&#125;.type.both .inner::after &#123;    right: 0;&#125;.type.both .inner:hover::before, .type.both .inner:hover::after &#123;    transform: scaleY(1);    -webkit-transform: scaleY(1);&#125;.type.both::before &#123;    top: 0;&#125;.type.both::after &#123;    bottom: 0;&#125;.type.both:hover::before, .type.both:hover::after &#123;    transform: scaleX(1);    -webkit-transform: scaleX(1);&#125;.type.both:hover .inner::before, .type.both:hover .inner::after &#123;    transform: scaleY(1);    -webkit-transform: scaleY(1);&#125;&#x2F;* 关于transform-origin属性top left | left top 等价于 0 0；top | top center | center top 等价于 50% 0right top | top right 等价于 100% 0left | left center | center left 等价于 0 50%center | center center 等价于 50% 50%（默认值）right | right center | center right 等价于 100% 50%bottom left | left bottom 等价于 0 100%bottom | bottom center | center bottom 等价于 50% 100%bottom right | right bottom 等价于 100% 100%*&#x2F;.type.both.clock .inner::before &#123;    transform-origin: top center;    -webkit-transform-origin: top center;&#125;.type.both.clock .inner::after &#123;    transform-origin: bottom center;    -webkit-transform-origin: bottom center;&#125;.type.both.clock::before &#123;    transform-origin: right center;    -webkit-transform-origin: right center;&#125;.type.both.clock::after &#123;    transform-origin: left center;    -webkit-transform-origin: left center;&#125;.type.both.clock:hover .inner::before &#123;    transform-origin: bottom center;    -webkit-transform-origin: bottom center;&#125;.type.both.clock:hover .inner::after &#123;    transform-origin: top center;    -webkit-transform-origin: top center;&#125;.type.both.clock:hover::before &#123;    transform-origin: left center;    -webkit-transform-origin: left center;&#125;.type.both.clock:hover::after &#123;    transform-origin: right center;    -webkit-transform-origin: right center;&#125;.row &#123;    &#x2F;* padding: 0.5em 1em 0.65em; *&#x2F;    width: 50px;    height: 20px;&#125;.type &#123;    padding: 0.5em 1em 0.5em;    &#x2F;* margin: 0 10px; *&#x2F;    width: 22px;    height: 20px;&#125;</code></pre><p>如果不设置<code>transform-origin</code>属性，将会变为这种形式</p><img src='https://jaydenchang.gitee.io/images/images/0x0018-6.gif'><p>css</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">.type &#123;    position: relative;    &#x2F;* font-size: 1em; *&#x2F;    &#x2F;* 不加relative会显示全屏划线 *&#x2F;&#125;.type .inner &#123;    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;&#125;&#x2F;* 如果说只要上下或者左右划线动画，可以不用加.inner标签，如果需要四条边，则需要加上.inner标签的before和after，并设置相关属性 *&#x2F;.type::before, .type::after, .type .inner::before, .type .inner::after&#x2F;* 这里有个一定要设置四个对象，一个对象对应一条边，before对应左和上，after对应右和下 *&#x2F;    &#123;    position: absolute;    content: &#39;&#39;;    display: block;    background: lightskyblue;    -webkit-transition: -webkit-transform 1s;    transition: -webkit-transform 1s;    transition: transform 1s;    transition: transform 1s, -webkit-transform 1s;&#125;.type.both::before, .type.both::after &#123;    left: 0;    width: 100%;    height: 2px;    -webkit-transform: scaleX(0);    transform: scaleX(0);&#125;.type.both .inner::after, .type.both .inner::before &#123;    top: 0;    width: 2px;    height: 100%;    -webkit-transform: scaleY(0);    transform: scaleY(0);&#125;.type.both .inner::before &#123;    left: 0;&#125;.type.both .inner::after &#123;    right: 0;&#125;.type.both .inner:hover::before, .type.both .inner:hover::after &#123;    transform: scaleY(1);    -webkit-transform: scaleY(1);&#125;.type.both::before &#123;    top: 0;&#125;.type.both::after &#123;    bottom: 0;&#125;.type.both:hover::before, .type.both:hover::after &#123;    transform: scaleX(1);    -webkit-transform: scaleX(1);&#125;.type.both:hover .inner::before, .type.both:hover .inner::after &#123;    transform: scaleY(1);    -webkit-transform: scaleY(1);&#125;.row &#123;    &#x2F;* padding: 0.5em 1em 0.65em; *&#x2F;    width: 50px;    height: 20px;&#125;.type &#123;    padding: 0.5em 1em 0.5em;    &#x2F;* margin: 0 10px; *&#x2F;    width: 22px;    height: 20px;&#125;</code></pre><h3 id="其他总结"><a href="#其他总结" class="headerlink" title="其他总结"></a>其他总结</h3><blockquote><ul><li>一个div里套了多个div，如果浏览器在低分辨率下，子div换行，除了检查子div有没有设置<code>display: inline-block;</code>，还要看看父div有没有设置具体宽度</li><li>如果很多时候如果样式的效果和图片不符，不妨检查下div的相关css参数，如长宽、<code>display</code> ，<code>position</code>等</li><li>浏览器f12里的element一栏里可对css进行实时调试</li><li><code>transform-origin</code>的方向，决定了动画线条的移动方向，在设置参数时自己在脑里演示一遍</li></ul></blockquote><blockquote><p>参考链接</p><p><a href="https://blog.csdn.net/llll789789/article/details/98383686">https://blog.csdn.net/llll789789/article/details/98383686</a></p><p><a href="https://www.jq22.com/yanshi20783">https://www.jq22.com/yanshi20783</a></p></blockquote>]]></content>
    
    
    <summary type="html">一些css动画的整理</summary>
    
    
    
    <category term="FrontEnd" scheme="https://jaydenchang.top/categories/FrontEnd/"/>
    
    
    <category term="html" scheme="https://jaydenchang.top/tags/html/"/>
    
    <category term="css" scheme="https://jaydenchang.top/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js轮播图改进版</title>
    <link href="https://jaydenchang.top/post/0x0017.html"/>
    <id>https://jaydenchang.top/post/0x0017.html</id>
    <published>2021-06-20T16:00:00.000Z</published>
    <updated>2021-12-11T05:57:50.061Z</updated>
    
    <content type="html"><![CDATA[<p>在肝前端大作业时，产生了使用轮播图的想法，翻阅了之前自己发过的一篇帖子，发现完全不能满足现在的需求，发现csdn上一篇帖子的代码写的不错，于是摘录下来学习</p><blockquote><p>实现的效果：</p><ul><li>自动播放</li><li>鼠标停留时停止播放，显示左右切换</li><li>点击左右切换、下方圆形可以手动切换</li><li>图片无缝切换，首位切换无违和感</li></ul></blockquote><p>采用胶片播放方式来切换图片</p><img src='https://jaydenchang.gitee.io/images/images/0x0017-2.gif'><p>经过css修饰后</p><img src='https://jaydenchang.gitee.io/images/images/0x0017-1.gif'><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;box&quot;&gt;        &lt;div id&#x3D;&quot;slider&quot;&gt;            &lt;ul class&#x3D;&quot;slieder-item-container&quot;&gt;                &lt;li&gt;                    &lt;a href&#x3D;&quot;#&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;index1.jpg&quot; &#x2F;&gt;&lt;&#x2F;a&gt;                &lt;&#x2F;li&gt;                &lt;li&gt;                    &lt;a href&#x3D;&quot;#&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;index2.jpg&quot; &#x2F;&gt;&lt;&#x2F;a&gt;                &lt;&#x2F;li&gt;                &lt;li&gt;                    &lt;a href&#x3D;&quot;#&quot;&gt;&lt;img src&#x3D;&quot;img&#x2F;index3.jpg&quot; &#x2F;&gt;&lt;&#x2F;a&gt;                &lt;&#x2F;li&gt;            &lt;&#x2F;ul&gt;            &lt;div class&#x3D;&quot;arrow-container&quot;&gt;                &lt;span class&#x3D;&quot;left-arrow&quot;&gt;&lt;&lt;&#x2F;span&gt;                &lt;span class&#x3D;&quot;right-arrow&quot;&gt;&gt;&lt;&#x2F;span&gt;                &lt;!-- 这个是左右箭头，用于切换图片 --&gt;            &lt;&#x2F;div&gt;            &lt;div class&#x3D;&quot;indicator-container&quot;&gt;                &lt;span class&#x3D;&quot;indicator active&quot;&gt;&lt;&#x2F;span&gt;                &lt;span class&#x3D;&quot;indicator&quot;&gt;&lt;&#x2F;span&gt;                &lt;span class&#x3D;&quot;indicator&quot;&gt;&lt;&#x2F;span&gt;                &lt;!-- 这个是图片下方的小圆点，定位第几张图 --&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;</code></pre><h4 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css">#slider,#slider ul,#slider ul li a &#123;    width: 800px;    height: 400px;    margin: 0;    padding: 0;&#125;#slider &#123;    position: absolute;    &#x2F;* position: relative; *&#x2F;    border: 2px solid black;    &#x2F;*padding: 3px;*&#x2F;    margin: 10px 0 0 10px;    &#x2F;* z-index: 1; *&#x2F;    overflow: hidden;    &#x2F;* 隐藏显示区域外的图片 *&#x2F;    -webkit-user-select: none;    -moz-user-select: none;    -ms-user-select: none;    user-select: none;&#125;#slider ul &#123;    position: absolute;    list-style-type: none;    width: 6000px;    &#x2F;* 设置图片列表的长度 *&#x2F;    &#x2F;*transition-duration: 0.3s;*&#x2F;&#125;#slider li &#123;    float: left;&#125;#slider a &#123;    &#x2F;* display: inline-block; *&#x2F;    display: block;&#125;img &#123;    width: 100%;    height: 100%;&#125;#slider:hover .arrow-container &#123;    display: block;&#125;.arrow-container &#123;    position: absolute;    width: 100%;    height: 50px;    top: 50%;    margin-top: -25px;    display: none;&#125;&#x2F;* 箭头的样式设计 *&#x2F;.arrow-container span &#123;    position: absolute;    width: 50px;    height: 50px;    font-size: 40px;    &#x2F;*display: inline-block;*&#x2F;    text-align: center;    line-height: 50px;    background: rgba(0, 0, 0, 0.2);    color: white;&#125;.left-arrow &#123;    left: 0px;    cursor: pointer;&#125;.right-arrow &#123;    right: 0px;    cursor: pointer;&#125;&#x2F;* 小圆点的样式设计 *&#x2F;.indicator-container &#123;    position: absolute;    width: 150px;    height: 30px;    line-height: 30px;    bottom: 0;    left: 50%;    margin-left: -75px;    text-align: center;&#125;.indicator &#123;    display: inline-block;    width: 15px;    height: 15px;    border-radius: 100%;    background: white;    cursor: pointer;&#125;.indicator.active &#123;    background: lightskyblue;&#125;</code></pre><h4 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">var autoplay &#x3D; true;var autoplay_Delay &#x3D; 2000; &#x2F;&#x2F; msvar autoplayId;var intervalId;var slider;var slider_item_container;var slider_items;var indicator_container;var slider_item_width;var curIndex &#x3D; 0;window.onload &#x3D; function() &#123;    initElement();    initEvent();    if (autoplay) &#123;        startAnimation(slider_item_container);    &#125;&#125;&#x2F;&#x2F; 初始化元素function initElement() &#123;    slider &#x3D; document.getElementById(&quot;slider&quot;);    slider_items &#x3D; slider.getElementsByTagName(&quot;li&quot;);    slider_item_container &#x3D; slider.getElementsByClassName(&quot;slieder-item-container&quot;)[0];    indicator_container &#x3D; slider.getElementsByClassName(&quot;indicator-container&quot;)[0];        var firstItem &#x3D; slider_items[0].cloneNode(true);    slider_item_container.appendChild(firstItem);        slider_item_width &#x3D; slider_items[0].offsetWidth;&#125;&#x2F;&#x2F; 初始化相关事件function initEvent() &#123;    slider.addEventListener(&quot;mouseover&quot;, function () &#123;        clearTimeout(autoplayId);        autoplay &#x3D; false;    &#125;);    slider.addEventListener(&quot;mouseout&quot;, function () &#123;        autoplay &#x3D; true;        startAnimation(slider_item_container);    &#125;);        var indicators &#x3D; indicator_container.children;    for (var i &#x3D; 0; i &lt; indicators.length; i++) &#123;        indicators[i].setAttribute(&quot;index&quot;, i);        indicators[i].addEventListener(&quot;click&quot;, function () &#123;            var index &#x3D; parseInt(this.getAttribute(&quot;index&quot;));            next(index);        &#125;);    &#125;        var left_arrow &#x3D; slider.getElementsByClassName(&quot;left-arrow&quot;)[0];    var right_arrow &#x3D; slider.getElementsByClassName(&quot;right-arrow&quot;)[0];    left_arrow.addEventListener(&quot;click&quot;, function () &#123;        prev();    &#125;);    right_arrow.addEventListener(&quot;click&quot;, function () &#123;        next();    &#125;);&#125;&#x2F;&#x2F; 动画效果，传入的形参未要移动的元素以及移动的目标值&#x2F;&#x2F; 默认每10ms移动10px，手动翻页时，移动事件缩短，每次移动step值增大function animate(element, target) &#123;    var step &#x3D; 10;    var time &#x3D; 10;    var gap &#x3D; (Math.abs(target - element.offsetLeft) &#x2F; slider_item_width);    if (gap &gt; 1) &#123;        step &#x3D; step * gap;        time &#x3D; time &#x2F; gap;    &#125;    if (element) &#123;        step &#x3D; (element.offsetLeft &gt; target) ? -step : step;        clearInterval(intervalId);        setCurrentActiveIndicator(curIndex);        intervalId &#x3D; setInterval(function () &#123;            if ((step &lt; 0) &amp;&amp; (Math.abs(element.offsetLeft + step) &lt; Math.abs(target))) &#123;                element.style.left &#x3D; element.offsetLeft + step + &quot;px&quot;;            &#125; else &#123;                if (Math.abs(target - element.offsetLeft) &gt; Math.abs(step)) &#123;                    element.style.left &#x3D; element.offsetLeft + step + &quot;px&quot;;                &#125; else &#123;                    clearInterval(intervalId);                    intervalId &#x3D; -1;                    element.style.left &#x3D; target + &quot;px&quot;;                    if (autoplay) &#123;                        startAnimation(element);                    &#125;                &#125;            &#125;        &#125;, time);    &#125;&#125;&#x2F;*&#x2F; 左右翻页，改变轮播图的left值，改变当前显示的图片，再进行翻页动作，使用户感受不到过明显的跳转变化，*&#x2F;function prev() &#123;    var element &#x3D; slider_item_container;    var li &#x3D; element.children;    curIndex &#x3D; curIndex - 1;    if (curIndex &lt; 0) &#123;        element.style.left &#x3D; -((li.length-1)*slider_item_width) + &quot;px&quot;;        curIndex &#x3D; li.length-2;    &#125;    animate(element, -(curIndex*slider_item_width));&#125;&#x2F;&#x2F; 点击小圆点，也就是单词调用next()，但需要将要跳转的下标值传入function next(nextIndex) &#123;    var element &#x3D; slider_item_container;    var li &#x3D; element.children;    if ((nextIndex !&#x3D; null) &amp;&amp; (typeof(nextIndex) !&#x3D; &quot;undefined&quot;)) &#123;        curIndex &#x3D; nextIndex;    &#125; else &#123;        curIndex &#x3D; curIndex + 1;        if (curIndex &gt; (li.length-1)) &#123;            element.style.left &#x3D; 0 + &quot;px&quot;;            curIndex &#x3D; 1;        &#125;    &#125;    animate(element, -(curIndex*slider_item_width));&#125;&#x2F;&#x2F; 自动播放，每次轮播图移动到目标位置后，持续调用startAnimation()，内部也是调用next()function startAnimation(element) &#123;    if (autoplayId) &#123;        clearTimeout(autoplayId);    &#125;    autoplayId &#x3D; setTimeout(function () &#123;        next();    &#125;, autoplay_Delay);&#125;function setCurrentActiveIndicator(index) &#123;    var indicators &#x3D; indicator_container.children;    if (index &#x3D;&#x3D; indicators.length) &#123;        index &#x3D; 0;    &#125;    for (var i &#x3D; 0; i &lt; indicators.length; i++) &#123;        if (i &#x3D;&#x3D; index) &#123;            indicators[i].className &#x3D; &quot;indicator active&quot;;        &#125; else &#123;            indicators[i].className &#x3D; &quot;indicator&quot;;        &#125;        &#x2F;&#x2F; 判断当前是第几张图并对小圆点加颜色    &#125;&#125;</code></pre><blockquote><p>总结以上一些小细节</p><ul><li>span设置宽高无效，但设置<code>position: absolute;</code>或<code>display: inline-block;</code>就有效了</li><li>子元素设置了<code>float: left</code>，父元素的<code>text-align</code>就失效了</li><li>圆形<code>border-radius: 50%;</code></li><li>文字上下居中：<code>line-height</code>设置和<code>height</code>一样的值</li><li>水平文字居中<code>text-align: center;</code></li></ul></blockquote><p><a href='https://blog.csdn.net/u013347241/article/details/107054441/'>JS实现无缝切换轮播图(自动+手动)-f清风q的博客</a></p>]]></content>
    
    
    <summary type="html">实现一个基于JavaScript的轮播图效果</summary>
    
    
    
    <category term="FrontEnd" scheme="https://jaydenchang.top/categories/FrontEnd/"/>
    
    
    <category term="html" scheme="https://jaydenchang.top/tags/html/"/>
    
    <category term="JavaScript" scheme="https://jaydenchang.top/tags/JavaScript/"/>
    
  </entry>
  
</feed>
