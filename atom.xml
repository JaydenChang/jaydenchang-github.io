<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jayden&#39;s Blog</title>
  
  
  <link href="https://jaydenchang.top/atom.xml" rel="self"/>
  
  <link href="https://jaydenchang.top/"/>
  <updated>2022-09-21T00:25:53.760Z</updated>
  <id>https://jaydenchang.top/</id>
  
  <author>
    <name>Jayden Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java swing实现应用程序对数据库的访问</title>
    <link href="https://jaydenchang.top/post/0x0030.html"/>
    <id>https://jaydenchang.top/post/0x0030.html</id>
    <published>2022-09-18T16:00:00.000Z</published>
    <updated>2022-09-21T00:25:53.760Z</updated>
    
    <content type="html"><![CDATA[<p>最近在完成软件体系结构上机实验时，遇到一个有点点小难度的选做题，题目信息如下：</p><blockquote><p>利用套接字技术实现应用程序中对数据库的访问。应用程序只是利用套接字连接向服务器发送一个查询的条件，而服务器负责对数据库的查询，然后服务器再将查询的结果利用建立的套接字返回给客户端，如下图所示。</p></blockquote><p><img src="https://jaydenchang.gitee.io/images/images/0x0030/0x0030_1.png"></p><p>本来吧，选做题，不太想做的，但是考虑到以后工作的方向和后端相关，那还是做吧。</p><p>本次实验需要做一个GUI界面和一个连接查询功能，在论坛上借鉴了其他大佬获取网站内容的部分代码，然后自己做了一个及其简陋的swing界面，算是把这个实验完成了。</p><p>本次实验项目结构如下</p><pre class="line-numbers language-none"><code class="language-none">--socketProject    |--Client.java    |--GUI.java    |--SearchInfo.java    |--Server.java    |--ServerThread.java</code></pre><h4 id="client.java"><code>Client.java</code></h4><p>客户端使用<code>dis.readUTF()</code>时，要注意再发送个字符或者空字符，这里发送<code>end</code>，表示关闭连接。不然会出现<code>EOFException</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package socketProject;import java.io.*;import java.net.*;public class Client &#123;    String studentNum &#x3D; null;    String result &#x3D; null;    public void setStudentNum(String num) &#123;        this.studentNum &#x3D; num;        System.out.println(&quot;stu: &quot; + studentNum);    &#125;    public void run() throws IOException &#123;        Socket ss &#x3D; new Socket(&quot;127.0.0.1&quot;, 8888);        System.out.println(&quot;Socket: &quot; + ss);        try &#123;            DataInputStream dis &#x3D; new DataInputStream(ss.getInputStream());            DataOutputStream dos &#x3D; new DataOutputStream(ss.getOutputStream());            &#x2F;&#x2F; the interaction            dos.writeUTF(studentNum); &#x2F;&#x2F; 向服务器发送学号            dos.flush();            result &#x3D; dis.readUTF().toString(); &#x2F;&#x2F; 获得客户端的json字符串            System.out.println(result);            dos.writeUTF(&quot;end&quot;); &#x2F;&#x2F; 不加这句会报错            dos.flush();            if (dos !&#x3D; null)                dos.close();            if (dis !&#x3D; null)                dis.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (ss !&#x3D; null)                ss.close();        &#125;    &#125;&#x2F;&#x2F; gui界面用于获取json结果    public String getResult() &#123;        return result;    &#125;&#125;</code></pre><h4 id="server.java"><code>Server.java</code></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package socketProject;import java.io.*;import java.net.*;public class Server extends Thread &#123;    public static final int PORT &#x3D; 8888;    &#x2F;&#x2F; public static void main(String[] args) throws IOException &#123;    public void run() &#123;        try (ServerSocket serverSocket &#x3D; new ServerSocket(PORT)) &#123;            System.out.println(&quot;ServerSocket: &quot; + serverSocket);            try &#123;                while (true) &#123;                    Socket socket &#x3D; serverSocket.accept();                    System.out.println(&quot;Socket accept: &quot; + socket);                    Thread thread &#x3D; new Thread(new ServerThread(socket));                    thread.start(); &#x2F;&#x2F; 开启一个线程，使之支持接收多个客户端的请求                &#125;            &#125; finally &#123;                serverSocket.close();            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="serverthread.java"><code>ServerThread.java</code></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package socketProject;import java.io.*;import java.net.*;public class ServerThread extends Thread &#123;    Socket socket &#x3D; null;    public ServerThread(Socket socket) &#123;        this.socket &#x3D; socket;    &#125;    public void run() &#123;        try &#123;            DataInputStream dis &#x3D; new DataInputStream(socket.getInputStream());            DataOutputStream dos &#x3D; new DataOutputStream(socket.getOutputStream());            while (true) &#123;                String str &#x3D; dis.readUTF().toString();                String data &#x3D; new SearchInfo().run(str);                if (str.equals(&quot;end&quot;))                    break;                dos.writeUTF(data);            &#125;            dos.close();            dis.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="searchinfo.java"><code>SearchInfo.java</code></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package socketProject;import java.io.*;import java.net.*;public class SearchInfo &#123;    public String run(String s) &#123;        String url &#x3D; &quot;your database interface&quot;;        String param &#x3D; s;        String sendGET &#x3D; GetUrl(url, param);        return sendGET;    &#125;        public static String GetUrl(String url, String param) &#123;        String result &#x3D; &quot;&quot;; &#x2F;&#x2F; define the result str        BufferedReader read &#x3D; null; &#x2F;&#x2F; define the access result                try &#123;            URL realUrl &#x3D; new URL(url + param);            URLConnection connection &#x3D; realUrl.openConnection();                        connection.setRequestProperty(&quot;accept&quot;, &quot;*&#x2F;*&quot;);            connection.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);            connection.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;);            &#x2F;&#x2F; 这里补充通用的请求属性            connection.connect(); &#x2F;&#x2F; 建立实际的连接                        read &#x3D; new BufferedReader(new InputStreamReader(connection.getInputStream(), &quot;UTF-8&quot;));            String line;            while ((line &#x3D; read.readLine()) !&#x3D; null) &#123;                result +&#x3D; line;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (read !&#x3D; null) &#123;&#x2F;&#x2F; 关闭流                try &#123;                    read.close();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return result;    &#125;        public String getJSON(String param) &#123;        return param;    &#125;&#125;</code></pre><h4 id="gui.java"><code>GUI.java</code></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package socketProject;import java.awt.*;import java.awt.event.*;import java.io.IOException;import javax.swing.*;public class GUI extends JFrame &#123;    private JButton connectDataBase;    private JLabel entryStudentNum;    private JTextField studentNum;    private JButton sendRequest;    private JLabel showResponseMsg;    private JPanel northPanel;    private JPanel southPanel;    public GUI() &#123;        init();    &#125;    public void init() &#123;        setTitle(&quot;没啥技术含量的东西&quot;);        &#x2F;&#x2F; define the component for the window        connectDataBase &#x3D; new JButton(&quot;连接数据库&quot;);        entryStudentNum &#x3D; new JLabel(&quot;输入学号&quot;);        studentNum &#x3D; new JTextField();        sendRequest &#x3D; new JButton(&quot;发送&quot;);        showResponseMsg &#x3D; new JLabel();        &#x2F;&#x2F; add the component to the panel        this.setLayout(new GridLayout(2, 1));        northPanel &#x3D; new JPanel(new GridLayout(1, 4));        northPanel.add(connectDataBase);        northPanel.add(entryStudentNum);        northPanel.add(studentNum);        northPanel.add(sendRequest);        southPanel &#x3D; new JPanel(new GridLayout(1, 1));        southPanel.add(showResponseMsg);        setButtons();        this.add(northPanel);        this.add(southPanel);        &#x2F;&#x2F; initial the window        setBounds(400, 200, 600, 120);        setResizable(false);        setDefaultCloseOperation(EXIT_ON_CLOSE);        setVisible(true);    &#125;    public void setButtons() &#123;        connectDataBase.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                &#x2F;&#x2F; 这里初始化服务端                Server server1 &#x3D; new Server();                Thread th1 &#x3D; new Thread(server1);                th1.start();                &#x2F;&#x2F; 这里一定要开启服务端线程，否则在点击此按钮后，整个界面会卡住，无法进行下一步操作            &#125;        &#125;);        sendRequest.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                Client client1 &#x3D; new Client();                client1.setStudentNum(studentNum.getText());                &#x2F;&#x2F; 获取文本框的文字，并赋给客户端的studentNum保存                try &#123;                    client1.run();                &#125; catch (IOException e1) &#123;                    e1.printStackTrace();                &#125;                showResponseMsg.setText(client1.getResult());                &#x2F;&#x2F; 将得到的数据显示在界面上            &#125;        &#125;);    &#125;    public static void main(String[] args) &#123;        new GUI();    &#125;&#125;</code></pre><p>最终效果如下：</p><p><img src="https://jaydenchang.gitee.io/images/images/0x0030/0x0030_2.png"></p><p>使用时，先点击连接数据库，然后根据学校提供的接口，输入自己的学号，点击发送，即可查询个人信息。</p><p>不过由于项目工作区非maven以及未来方向非Java的缘故，没有去深究如何提取json的值 <del>(偷个懒)</del>。</p><h4 id="参考链接">参考链接</h4><p><a href="https://blog.csdn.net/dmkaadmk/article/details/52679925">Java请求一个URL，获取返回的数据_杜岚特的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_34697393/article/details/114620733">java.io.datainputstream.readunsignedshort_socket编程报异常java.io.EOFException_窦月汐的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">用Java swing实现一个套接字访问数据库</summary>
    
    
    
    <category term="BackEnd" scheme="https://jaydenchang.top/categories/BackEnd/"/>
    
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>七天用go实现一个web框架</title>
    <link href="https://jaydenchang.top/post/0x002F.html"/>
    <id>https://jaydenchang.top/post/0x002F.html</id>
    <published>2022-08-06T16:00:00.000Z</published>
    <updated>2022-09-30T09:15:50.827Z</updated>
    
    <content type="html"><![CDATA[<hr/><h3 id="前言">前言</h3><p>本文学习自<a href="https://geetktutu.com">geektutu</a> , 大部分内容摘自 <a href="https://geektutu.com/post/gee.html">7天用Go从零实现Web框架Gee教程 | 极客兔兔 (geektutu.com)</a>，并在此基础上稍加个人的学习历程和理解。</p><p>作者仓库地址：<a href="https://github.com/geektutu/7days-golang">geektutu/7days-golang: 7 days golang programs from scratch (web framework Gee, distributed cache GeeCache, object relational mapping ORM framework GeeORM, rpc framework GeeRPC etc) 7天用Go动手写/从零实现系列 (github.com)</a></p><h3 id="day0.-设计一个框架">day0. 设计一个框架</h3><p>大部分时候 , 实现一个Web应用 , 第一反应是用哪个框架 , 在Golang中 , 新框架层出不穷 , 例如<code>Beego</code> , <code>Gin</code> , <code>Iris</code> 等 , 那为什么不用标准库 , 而必须使用框架呢 ? 在设计一个框架时 , 我们需要知道核心框架为我们解决了什么问题 , 只有明白这一点 , 才能想明白我们要在框架内实现什么功能。</p><p>刚好最近学院开展了一个软件实训课程 , 在五天之内搭好了一个Java游戏框架 , 基本框架搭好之后 , 只需要替换配置文档和游戏元素 , 就可以做出另一款新的游戏 , 当然 , 在理解这个框架的搭建思路的背后是异常痛苦的 (前后花了6天左右去看课程视频 , 各种修bug) , 在做出作品那一刻，虽然运行起来的会让人莫名想笑 , 心情舒畅，不过总算实现了代码和人一个能跑了bushi , 很敬佩游戏框架设计师的奇思妙想 <del>(脑洞)</del> 。</p><p>有点扯远了 , 我们先看看Golang标准库<code>net/http</code>如何处理一个请求。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;net&#x2F;http&quot;    &quot;fmt&quot;)func main() &#123;    http.HandleFunc(&quot;&#x2F;&quot;, handler)    http.HandleFunc(&quot;&#x2F;count&quot;, handler)    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))&#125;func handler(w http.ResponseWriter, r *http.Request) &#123;    fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, r.URL.Path)&#125;</code></pre><h5 id="基础知识">基础知识</h5><h6 id="interface">interface</h6><p>首先定义一个<code>Animal</code>的接口</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Animal interface &#123;    Speak() string&#125;</code></pre><p>golang中没有 implements 关键字，那么如何实现接口呢？</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Dog struct &#123;&#125;func (d Dog) Speak() string &#123;    return &quot;Woof!&quot;&#125;type Cat struct &#123;&#125;func (c Cat) Speak() string &#123;    return &quot;Meow!&quot;&#125;&#x2F;&#x2F; 只要实现了Speak()，就算是实现了Animal接口</code></pre><h6 id="interface-1">interface</h6><p>interface{} 类型，空接口，很容易和interface弄混。interface{} 是没有方法的接口。由于没有 implements 关键字，所以所有类型都至少实现了0个方法，所以 <strong>所有类型都实现了空接口</strong>。这意味着，如果在写一个函数以 interface{} 为参数，那么可以为该函数提供任何值。例如</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func DoSomething(v interface&#123;&#125;) &#123;    &#x2F;&#x2F; ...&#125;</code></pre><p>在DoSomething 内部，开始我也认为v时任意类型，但这是错误的，v 不是任意类型，它的静态类型是<code>interface&#123;&#125;</code>类，动态类型由传入的参数的类型决定，当然返回参数时，就不要返回<code>interface&#123;&#125;</code>类了。</p><p><code>interface&#123;&#125;</code>可以承载任意值，但不代表任意类型就可以承接空接口类型的值。当将值传递给DoSomething 函数时，golang将执行类型转换 (if necessary)，并将值转换为<code>interface&#123;&#125;</code>类型的值。</p><blockquote><p>题外话，<code>interface&#123;&#125;</code>动态类型慎用，特别是面对需求容易改动的项目，另外，一般不要对动态类型的值进行比较操作</p></blockquote><h6 id="http.responsewriter">http.ResponseWriter</h6><p>首先需要了解<code>HandleFunc</code>这个函数的一些信息，其声明如下。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;    DefaultServeMux.HandleFunc(pattern, handler)&#125;</code></pre><p>在main函数中，字符串部分容易理解，那handler呢，来看看它的参数的源码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type ResponseWriter interface &#123;    Header() Header    Write([]byte) (int, error)    WriteHeader(statusCode int)&#125;</code></pre><p>还是不太清楚，再点击<code>Header</code>看看。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Header map[string][]string</code></pre><p>http.Header结构包含请求头信息，常见信息实例如下。</p><pre class="line-numbers language-none"><code class="language-none">Host: example.comaccept-encoding: gzip, deflateAccept-Language: en-usfoo: Bar</code></pre><p>接下来看看<code>Write([]byte) (int, error)</code>，这是一个接口，实现通用的<code>io.Writer</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Writer interface &#123;    Write(p []byte) (n int, err error)    &#x2F;&#x2F; 这个byte其实是个切片,而Write方法在server.go里被重写了,具体先不贴代码,本身含有Fprintf方法,后文会用到&#125;</code></pre><p>最后到<code>WriteHeader(statusCode int)</code>。</p><p><code>WriteHeader</code>这个方法名有点误导，并不是来设置响应头的，该方法支持传入一个整形数据表示响应状态码，不调用该方法的话，默认值是<code>200 OK</code>。</p><h6 id="http.request">http.Request</h6><p>直接看源码的声明。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Request struct &#123;    Method string    URL *url.URL    Proto string   &#x2F;&#x2F;eg &quot;HTTP&#x2F;1.0&quot;    ProtoMajor int      ProtoMinor int    Header Header    Body io.ReaderCloser    GetBody func() (io.ReadCloser, error)    ContentLength int64    TransferEncoding []string    Close bool    Host string    Form url.Values    PostForm url.Values    MultipartForm *multipart.Form    Trailer Header    RemoteAddr string    RequestURI string    TLS *tls.ConnectionState    Cancel &lt;-chan struct&#123;&#125;    Response *Response    ctx context.Context&#125;</code></pre><p>常见的Request报文段信息如下：</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day0_2.jpg'></p><h6 id="http.listenandserve">http.ListenAndServe</h6><pre class="line-numbers language-go" data-language="go"><code class="language-go">func ListenAndServe(addr string, handler Handler) error &#123;    server :&#x3D; &amp;Server&#123;Addr: addr, Handler: handler&#125;    return server.ListenAndServe()&#125;</code></pre><p>在<code>ListenAndServe</code>中，再查看<code>Server</code>和<code>ListenAndServe()</code>的源码</p><blockquote><p>http.Server</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Server struct &#123;Addr string   &#x2F;&#x2F; 服务器的IP地址和端口信息    Handler Handler  &#x2F;&#x2F; 请求处理函数的路由复用器    ReadTimeout time.Duration    WriteTimeout time.Duration    MaxHeaderBytes int    TLSConfig *tls.Config    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)    ConnState func(net.Conn, ConnState)    ErrorLog *log.Logger    disableKeepAlives int32&#125;</code></pre><blockquote><p>http.ListenAndServe()</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (srv *Server) ListenAndServe() error &#123;    if srv.shuttingDown() &#123;        return ErrServerClosed  &#x2F;&#x2F; 如果Server已关闭，直接返回ErrServerClosed    &#125;    addr :&#x3D; srv.Addr    if addr &#x3D;&#x3D; &quot;&quot; &#123;        addr &#x3D; &quot;:http&quot;    &#125;    ln, err :&#x3D; net.Listen(&quot;tcp&quot;, addr)     if err !&#x3D; nil &#123;        return err    &#125;    return srv.Serve(ln)&#125;</code></pre><p>在本例中，传入了端口号和handler，如果不指定ip就用本机地址 (localhost)，如果不指定服务器地址信息，则默认以<code>:http</code>作为地址信息</p><h6 id="fmt.fprintf">fmt.Fprintf</h6><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Fprintf(w io.Writer, format string, a ...any) (n int, err error) &#123;    p :&#x3D; newPrinter()    p.doPrintf(format, a)    n, err &#x3D; w.Write(p.buf)    p.free()    return&#125;</code></pre><h6 id="log.fatal">log.Fatal</h6><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Fatal(v ...any) &#123;    std.Output(2, fmt.Sprint(v...))    os.Exit(1)&#125;</code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (l *Logger) Fatal(v ...any) &#123;    l.Output(2, fmt.Sprint(v...))    os.Exit(1)&#125;</code></pre><p>在函数上面的定义，Fatal等价于<code>Print()</code>，执行完打印直接退出程序，之前通过<code>defer</code>设置延迟的函数不会被运行</p><h5 id="框架说明">框架说明</h5><p><code>net/http</code>提供了基础的Web功能 , 即监听端口 , 解析HTTP报文。一些Web开发中简单的需求并不支持，需要手工实现。</p><ul><li>动态路由 : 例如<code>hello/:name</code> , <code>hello/*</code>这类的规则</li><li>鉴权 (authentication) : 没有分组/统一鉴权的能力 , 需要在每个路由映射的handler中实现</li><li>模板 : 没有统一简化的HTML机制</li><li>...</li></ul><p>可以发现，当我们离开框架，使用基础库时，需要频繁手工处理的地方，就是框架的价值所在。</p><h3 id="day1.-http.handler">day1. http.Handler</h3><h4 id="base1">base1</h4><h5 id="标准库启动web服务">标准库启动Web服务</h5><p>Golang内置了<code>net/http</code>库 , 封装了HTTP网络编程的基础的接口 , 本次复刻的<code>Gee</code> Web框架便是基于<code>net/http</code>的 , 下面通过一个例子 , 简单介绍下这个库的使用。</p><blockquote><p>day1/base1/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;fmt&quot;    &quot;net&#x2F;http&quot;    &quot;log&quot;)func main() &#123;    http.HandleFunc(&quot;&#x2F;&quot;, indexHandler)    http.HandleFunc(&quot;&#x2F;hello&quot;, helloHandler)    log.Fatal(http.ListenAndServe(&quot;:9999&quot;, nil))&#125;func indexHandler(w.http.ResponseWriter, req *http.Request) &#123;    fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, req.URL.Path)&#125;func helloHandler(w http.ResponseWriter, req *http.Request) &#123;    for k, v :&#x3D; range req.Header &#123;        fmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\n&quot;, k, v)    &#125;&#125;</code></pre><p>在上面 , 设置了两个路由 , <code>/</code>和<code>/hello</code> , 分别绑定<code>indexHandler</code>和<code>helloHandler</code> , 根据不同的HTTP请求会调用不同的处理函数 , 访问<code>/</code> , 响应是<code>URL.Path=/</code> , 而<code>/hello</code>的相应则是请求头 (header)中键值对信息。</p><p>用curl工具测试 , 会得到以下结果。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;URL.Path &#x3D; &quot;&#x2F;&quot;$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloHeader[&quot;User-Agent&quot;]&#x3D;[&quot;curl&#x2F;7.68.0&quot;]Header[&quot;Accept&quot;]&#x3D;[&quot;*&#x2F;*&quot;]$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloWorldURL.Path &#x3D; &quot;&#x2F;helloWorld&quot;</code></pre><p>main函数的最后一行 , 是来启动服务的 , 第一个是参数地址 , <code>:9999</code>表示在<code>9999</code>端口监听 , 而第二个参数则代表处理所有的HTTP请求的实例 , <code>nil</code>代表使用标准库中的实例处理 , 也是我们基于<code>net/http</code>标准库实现Web框架的入口。</p><p>这里第三个命令 , 访问了<code>/helloWorld</code> , 而在文件中未定义<code>/helloWorld</code>这个路由 , 用curl工具仅从测试 , 得到的却是<code>URL.Path</code> , 关于这个bug , 后文会进行修改。</p><h5 id="实现http.handler接口">实现http.Handler接口</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go">package httptype Handler interface &#123;    ServeHTTP(w ResponseWriter, r *Request)&#125;func ListenAndServe(address string, h Handler) error</code></pre><p>查阅<code>net/http</code>源码发现 , <code>Handler</code>是一个接口 , 需要实现方法 ServeHTTP , 也就是说 , 只要传入任何实现了 ServeHTTP接口的实例 , 所有的HTTP请求 , 就都交给了该实例处理。</p><h4 id="base2">base2</h4><blockquote><p>day1/base2/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;fmt&quot;    &quot;log&quot;    &quot;net&#x2F;http&quot;)type Engine struct&#123;&#125;&#x2F;&#x2F; 定义一个空的结构体,并命名为Engine,后期可以直接用Engine加&#39;.&#39;加成员名的方式调用func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;    &#x2F;&#x2F; 这里engine作为Engine类型的对象,拥有Engine的所有方法    switch req.URL.Path &#123;        case &quot;&#x2F;&quot;:            fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, req.URL.Path)        case &quot;&#x2F;hello&quot;:            for k, v :&#x3D; range req.Header &#123;                fmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\n&quot;, k, v)            &#125;        default:            fmt.Fprintf(w, &quot;404 NOT FOUND: %s\n&quot;, req.URL)    &#125;&#125;func main() &#123;    engine :&#x3D; new(Engine)    log.Fatal(http.ListenAndServe(&quot;:9999&quot;, engine))&#125;</code></pre><p>后面复盘时，有一点一直搞不懂，究竟<code>ServeHTTP</code>是怎么被调用的？在这个go文件里面，感觉还是得从<code>ListenAndServe</code>下手，<code>ListenAndServe</code>的定义是这样的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func ListenAndServe(addr string, handler Handler) error &#123;    serve :&#x3D; &amp;Server&#123;Addr: addr, Handler: handler&#125; &#x2F;&#x2F; 创建一个Server结构体    return server.ListenAndServe()    &#x2F;&#x2F; 这里开始也还是没怎么看懂,后面也去查了下资料,这里返回的ListenAndServe,传入到Fatal里,如果不报错的话,是正常打印switch中的内容,有错误就打印错误信息&#125;</code></pre><p>继续追溯<code>server.ListenAndServe()</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (srv *Server) ListenAndServe() error &#123;    addr :&#x3D; srv.Addr    if addr &#x3D;&#x3D; &quot;&quot; &#123;        addr &#x3D; &quot;:http&quot;    &#125;    ln, err :&#x3D; net.Listen(&quot;tcp&quot;, addr)    if err !&#x3D; nil &#123;        return err    &#125;    return srv.Serve(ln)&#125;</code></pre><p>此方法只是开始侦听给定的地址,并用新创建的侦听器调用<code>Server</code>方法</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (srv *Server) Serve(l net.Listener) error &#123;    defer l.close()    ...    for&#123;        rw, e :&#x3D; l.Accept()        ...        c :&#x3D; srv.newConn(rw)        c.setState(c.rwc, StateNew)        go c.serve(ctx)    &#125;&#125;</code></pre><p>从<code>Serve</code>方法我们可以看到 , 这是我们接受新连接并开始在它自己的<code>goroutine</code>中处理它的地方</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (c *Conn) serve(ctx context.Context) &#123;    ...    for &#123;        w, err :&#x3D; c.readRequest(ctx)        ...        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)        ...    &#125;&#125;</code></pre><p>在这里 , 才调用了<code>ServeHTTP</code>方法 , 正如我们在上面看到的 , 我们对这个ServeHTTP方法进行重写 , 打印输出HTTP请求的信息</p><hr><p>回到<code>main.go</code> , 这里定义了一个空的结构体<code>Engine</code> , 实现了方法<code>ServrHTTP</code> , 这个方法有两个参数 , 第二个参数是Request , 该对象包含了该HTTP请求的所有信息 , 比如请求地址 , Header和Body等信息 ; 第一个参数是ResponseWriter , 利用ResponseWriter可以构造指针对该请求的相应。</p><p>在main函数里 , 我们给ListenAndServe方法的第二个参数传入了刚才创建的<code>engine</code>实例 , 至此已经踏出了实现Web框架的第一步 , 即将所有的HTTP请求转向了我们自己的处理逻辑 。</p><p>在实现<code>Engine</code>之前 , 我们调用<code>http.HandleFunc</code>实现了路由和Handler的映射 , 也就是只能针对具体的路由写处理逻辑 , 比如<code>\hello</code> , 但在实现<code>engine</code>后 , 我们拦截了所有的HTTP请求 , 拥有了统一的控制入口 , 在这里我们可以自由定义路由映射的规则 , 也可以统一添加一些处理逻辑 , 例如日志 , 异常处理等。</p><p>代码运行结果前两行代码的结果一致 , 第三行代码结果如下。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloWorld404 NOT FOUND: &#x2F;helloWorld</code></pre><h4 id="base3">base3</h4><h5 id="gee框架的雏形">Gee框架的雏形</h5><p>下面重新来组织上面的代码 , 搭建整个框架的雏形。</p><pre class="line-numbers language-none"><code class="language-none">gee&#x2F;  |--gee.go  |--go.modmain.gogo.mod</code></pre><blockquote><p>day1/base3/go.mod</p></blockquote><pre class="line-numbers language-none"><code class="language-none">module examplego 1.18require gee v1.0.0replace gee &#x3D;&gt; .&#x2F;gee</code></pre><blockquote><p>day1/base3/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;fmt&quot;    &quot;net&#x2F;http&quot;    &quot;gee&quot;)func main() &#123;    r :&#x3D; gee.New()    r.GET(&quot;&#x2F;&quot;, func(w http.ResponseWriter, req *http.Request) &#123;        fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, req.URL.Path)    &#125;)        r.GET(&quot;&#x2F;hello&quot;, func(w http.RequestWriter, req *http.Request) &#123;        for k, v :&#x3D; range req.Header &#123;            fmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\n&quot;, k, v)        &#125;    &#125;)        r.Run(&quot;:9999&quot;)&#125;</code></pre><p>在这里 , 使用<code>GET()</code>方法添加路由 , 最后使用<code>Run()</code>启动Web服务 , 这里的路由 , 只是静态路由 , 不支持<code>/hello/:name</code>这样的动态路由 , 动态路由将在下一次实现。</p><blockquote><p>day1/base3/gee/go.mod</p></blockquote><pre class="line-numbers language-none"><code class="language-none">module geego 1.18</code></pre><p>因为我是用vscode进行代码编辑，工作区选择gee的根目录，而不是<code>src</code>，这里的<code>go.mod</code>管理需要做一点额外工作，按照教程写好mod后，会提示无法导入gee模块，查了各种帖子，对<code>Go111Module</code>进行设置也没效果，后面查到了一篇帖子，要在设置里搜 <strong>go.useLanguageServer</strong>，并将其关闭</p><blockquote><p>day1/base3/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package geeimport (    &quot;fmt&quot;    &quot;net&#x2F;http&quot;)type HandlerFunc func(http.ResponseWriter, *http.Request) &#x2F;&#x2F; 定义了一个HandlerFunc的函数类型,其签名必须符合输入为 http.ResponseWriter和*http.Requesttype Engine struct &#123;    router map[string]HandlerFunc&#125;func New() *Engine &#123;    return &amp;Engine&#123;router: make(map[string]HandlerFunc)&#125;&#125;func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) &#123;    key :&#x3D; method + &quot;-&quot; +pattern    engine.router[key] &#x3D; router&#125;func (engine *Engine) GET(pattern string, handler HandlerFunc) &#123;    engine.addRoute(&quot;GET&quot;, pattern, handler)&#125;func (engine *Engine) POST(pattern string, handler HandlerFunc) &#123;    engine.addRoute(&quot;POST&quot;, pattern, handler)&#125;func (engine *Engine) Run(addr string) (err error) &#123;    return http.ListenAndServe(addr, engine)&#125;func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;    key :&#x3D; req.Method + &quot;-&quot; + req.URL.Path    if handlerm ok :&#x3D; engine.router[key]; ok &#123;        hanlder(w, req)    &#125; else &#123;        fmt.Fprintf(w, &quot;404 NOT FOUND: %s\n&quot;, req.URL)    &#125;&#125;</code></pre><p>在<code>gee.go</code> , 介绍下这几部分的实现。</p><ul><li>定义了类型<code>HandlerFunc</code> , 这是提供给框架用户的 , 用来定义路由映射的基本方法。我们在<code>Engine</code>中，添加了一张路由映射表<code>router</code>，key由请求方法和静态路由地址构成，例如<code>GET-/</code>，<code>GET-/hello</code>，<code>POST-/hello</code>，这样针对相同的路由，如果请求方式不同，可以映射不同的处理方法(Handler)，value是用户映射的处理方法。</li><li>当用户调用<code>(*Engine).Run()</code>方法，会将路由和处理方法注册到映射表router中，<code>(*Engine).Run()</code>，是 ListenAndServe的包装。</li><li><code>Engine</code>实现的ServeHTTP方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法，如果查不到，就返回404 NOT FOUND。</li></ul><p>执行<code>go run main.go</code>，再用curl访问，结果和base2的结果一致</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;URL.Path &#x3D; &quot;&#x2F;&quot;$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloHeader[&quot;Accept&quot;] &#x3D; [&quot;*&#x2F;*&quot;]Header[&quot;User-Agent&quot;] &#x3D; [&quot;curl&#x2F;7.68.0&quot;]$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloWorld404 NOT FOUND: &#x2F;helloWorld</code></pre><p>至此，整个Gee框架的原型就已经出来了。有了基本路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。当然到目前为止，我们还没有实现比<code>net/http</code>标准库更强大的能力，这些会在后面将动态路由、中间件等功能添加上去。</p><h3 id="day2.-上下文-context">day2. 上下文 Context</h3><ul><li>将 路由(router) 独立出来 , 方便之后改进。</li><li>设计 上下文 (Context)，封装 Request和 Response，提供对JSON、HTML等返回类型的支持。</li><li>第二天的框架内容，代码约140行，新增约90行。</li><li>后面每一天贴出的代码基本为原文件基础上新增的内容或修改后的内容</li></ul><h4 id="设计context">设计Context</h4><h5 id="必要性">必要性</h5><ol type="1"><li>对Web服务来说，无非是根据请求<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的相应，需要考虑消息头(Header)和消息体(Body)，而Header包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写大量重复、繁冗的代码，且容易出错。针对常用场景，能够高效地构造出HTTP相应是一个好的框架必须考虑的点。</li></ol><p>用返回JSON数据作比较，对比封装前后的差异：</p><blockquote><p>封装前</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">obj &#x3D; map[string]interface&#123;&#125; &#123;    &quot;name&quot;: &quot;abc&quot;,    &quot;password&quot;: &quot;1234&quot;,&#125;w.Header().Set(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)w.WriteHeader(http.StatusOK)encoder :&#x3D; json.NewEncoder(w)if err :&#x3D; encoder.Encode(obj); err !&#x3D; nil &#123;    http.Error(w, err.Error(), 500)&#125;</code></pre><blockquote><p>封装后</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">c.JSON(http.StatusOK, gee.H&#123;    &quot;username&quot;: c.PostForm(&quot;username&quot;),    &quot;password&quot;: c.PostForm(&quot;password&quot;),&#125;)</code></pre><ol start="2" type="1"><li>针对使用场景，封装<code>*http.Request</code>和<code>http.ResponseWriter</code>的方法，简化相关接口的调用，只是设计Context的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由<code>/hello/:name</code>，参数<code>name</code>的值放在哪？再比如，框架需要支持中间件，那中间件产生的信息放在哪？Context随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由Context承载。因此，设计Context结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都统一使用Context实例</li></ol><h5 id="具体实现">具体实现</h5><blockquote><p>day2/gee/context.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type H map[string]interface&#123;&#125;type Context struct &#123;    &#x2F;&#x2F; origin objects    Writer http.ResponseWriter    Req *http.Request    &#x2F;&#x2F; request info    Path string    Method string    &#x2F;&#x2F; response info    StatusCode int&#125;func newContext(w http.ResponseWriter, req *http.Request) *Context &#123;    return &amp;Context &#123;        Writer: w,        Req req,        Path: req.URL.Path,        Method: req.Method,    &#125;&#125;func (c *Context) PostForm(key string) string &#123;    return c.Req.FormValue(key)&#125;func (c *Context) Query(key string) string &#123;    return c.Req.URL.Query().Get(key)&#125;func (c *Context) Status(code int) &#123;    c.StatusCode &#x3D; code    c.Writer.WriteHeader(code)&#125;func (c *Context) SetHeader(key string, value string) &#123;    c.Writer.Header().Set(key, value)&#125;func (c *Context) String(code int, format string, values ...interface&#123;&#125;) &#123;    c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;plain&quot;)    c.Status(code)    c.Writer.Write([]byte(fmt.Sprintf(format, values...)))&#125;func (c *Context) JSON(code int, obj interface&#123;&#125;) &#123;    c.SetHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)    c.Status(code)    encoder :&#x3D; json.NewEncoder(c.Writer)    if err :&#x3D; encoder.Encode(obj); err !&#x3D; nil &#123;        http.Error(c.Writer, err.Error(), 500)    &#125;    &#x2F;&#x2F; 这里的obj,在后文的测试中,就是一个map,输出为[&quot;passowrd&quot;:&quot;xxx&quot;,&quot;username&quot;:&quot;xxx&quot;]&#125;func (c *Context) Data(code int, data []byte) &#123;    c.Status(code)    c.Writer.Write(data)&#125;func (c *Context) HTML(code int, html string) &#123;    c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;)    c.Status(code)    c.Writer.Write([]byte(html))&#125;</code></pre><ul><li>代码最开头，给<code>map[string]interface&#123;&#125;</code>起了一个别名<code>gee.H</code>，构建JSON数据时，显得更简洁。</li><li><code>Context</code>目前只包含了<code>http.ResponseWriter</code>和<code>*http.Request</code>，另外提供了对Method和Path这两个常用的属性的直接访问。</li><li>提供了访问Query和PostForm参数的方法。</li><li>提供了快速构造String/Data/JSON/HTML相应的方法。</li></ul><h4 id="路由router">路由(Router)</h4><p>我们将和路由相关的方法和结构提取了出来，放到了一个新的文件<code>router.go</code>，方便下一次对router的功能进行增强，例如提供动态路由的支持。router的handle方法作了一个细微的调整，即handler的参数，变成了Context。</p><blockquote><p>day2/gee/router.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type router struct &#123;    handlers map[string]HandlerFunc&#125;func newRouter() *router &#123;    return &amp;router&#123;handlers: make(map[string]HandlerFunc)&#125;&#125;func (r *router) addRoute(method string, pattern string, handler HandlerFunc) &#123;    log.Printf(&quot;Route %4s - %s&quot;, method, pattern)    key :&#x3D; method + &quot;-&quot; + pattern    r.handlers[key] &#x3D; handler    &#x2F;&#x2F; 注册路由&#125;func (r *router) handle(c *Context) &#123;    key :&#x3D; c.Method + &quot;-&quot; + c.Path    if handler, ok :&#x3D; r.handlers[key]; ok &#123;        &#x2F;&#x2F; 这里根据输入的方法和路径查找handlers中值,返回HandlerFunc,赋给handler,此时handler就是一个带有HandlerFunc签名的函数(http.ResponseWriter和*http.Request),输入的参数类型为*Context,handler再根据输入的Context        handler(c)    &#125; else &#123;        c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\n&quot;, c.Path)    &#125;&#125;</code></pre><h4 id="框架入口">框架入口</h4><blockquote><p>day2/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package geeimport &quot;net&#x2F;http&quot;&#x2F;&#x2F; HandlerFunc defines the request handler used by gee&#x2F;&#x2F; HandlerFunc包含Context所有属性和方法type HandlerFunc func(*Context)&#x2F;&#x2F; Engine implement the interface of ServeHTTPtype Engine struct &#123;    router *router&#125;&#x2F;&#x2F; New is the constructor of gee.Enginefunc New() *Engine &#123;    return &amp;Engine&#123;router: newRouter()&#125;&#125;func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) &#123;    engine.router.addRoute(method, pattern, handler) &#x2F;&#x2F; 调用router的addRoute方法    &#x2F;&#x2F; router的addRoute方法类似于一个私有函数,通过engine的addRoute传入参数再传递给router&#125;&#x2F;&#x2F; 把第一天的addRoute修改为这样,</code></pre><p>将<code>router</code>相关的代码独立后，<code>gee.go</code>简单了不少。最重要的还是通过实现了ServeHTTP接口，接管了所有的HTTP请求。相比第一天的diamond，这个方法也有细微的调整，在调用router.handle之前，构造了一个Context对象。这个对象目前还非常简单，仅仅是包装了原来的两个参数，之后我们会慢慢地给Context加上更多内容。</p><blockquote><p>day2/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport(    &quot;net&#x2F;http&quot;    &quot;gee&quot;)func main() &#123;    r :&#x3D; gee.New()    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;\n&quot;)    &#125;)     &#x2F;&#x2F; 思路: 向GET传入一个&quot;&#x2F;&quot;的路由和一个匿名的HandlerFunc函数,该函数内部含有相关HTTP请求信息(HTML函数),然后GET把这个路由和handler传给engine的addRoute,经过套娃,再到达router的addRoute    &#x2F;&#x2F; 下面的GET也同理,只不过String和HTML传入的切片不同    r.GET(&quot;&#x2F;hello&quot;, func(c *gee.Context) &#123;        &#x2F;&#x2F; expect &#x2F;hello?name&#x3D;abc        c.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Query(&quot;name&quot;), c.Path)    &#125;)    r.POST(&quot;&#x2F;login&quot;, func(c *gee.Context) &#123;        &#x2F;&#x2F; 在服务器端输出的是 &quot;POST - &#x2F;login&quot;        c.JSON(http.StatusOK, gee.H&#123;            &quot;username&quot;: c.PostForm(&quot;username&quot;),            &quot;password&quot;: c.PostForm(&quot;password&quot;),        &#125;)    &#125;)    r.Run(&quot;:9999&quot;)&#125;</code></pre><p>运行<code>main.go</code>，看看day2的成果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">$ curl -i http:&#x2F;&#x2F;localhost:9999&#x2F;HTTP&#x2F;1.1 200 OKContent-Type: text&#x2F;htmlDate: Fri, 08 Jul 2022 08:29:52 GMTContent-Length: 19&lt;h1&gt;Hello Gee&lt;&#x2F;h1&gt;$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;hello?name&#x3D;abchello abc, you&#39;re at&#x2F;hello$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;login -X POST -d &quot;username&#x3D;abc&amp;password&#x3D;1234&quot;&#123;&quot;password&quot;:&quot;1234&quot;,&quot;username&quot;:&quot;abc&quot;&#125;$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;xxx404 NOT FOUND: &#x2F;xxx</code></pre><p>服务器端输出</p><pre class="line-numbers language-none"><code class="language-none">2022&#x2F;07&#x2F;09 11:38:15 Route  GET - &#x2F;2022&#x2F;07&#x2F;09 11:38:15 Route  GET - &#x2F;hello2022&#x2F;07&#x2F;09 11:38:15 Route POST - &#x2F;login</code></pre><h3 id="day3-前缀树路由router">day3 前缀树路由Router</h3><ul><li>使用Trie树实现动态路由(dynamic route)解析。</li><li>支持两种模式<code>:name</code>和<code>*filepath</code>，代码约150行。</li></ul><h4 id="trie树简介">Trie树简介</h4><p>之前，用了一个非常简单的<code>map</code>结构存储了路由表，用<code>map</code>存储键值对，索引非常高效，但是有一个弊端，键值对的存储方式，只能来索引静态路由。如果我们想支持类似于<code>/hello/:name</code>这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类型而并非某一条固定的路由，例如<code>/hello/:name</code>，可以匹配<code>/hello/abc</code>，<code>/hello/jayden</code>等。</p><p>动态路由有很多种实现方式，支持的规则，性能等有很大的差异。例如开源的路由实现<code>gorouter</code>支持在路由规则种嵌入正则表达式，例如<code>/p/[0-9A-Za-z]+</code>，即路径种的参数仅匹配数字和字母；另一个开源实现<code>httprouter</code>就不支持正则表达式。Web开源框架<code>gin</code>在早期的版本没有实现自己的路由，而是直接用了<code>httprouter</code>，后来又放弃了<code>httprouter</code>，自己实现了一个版本。</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day3_trie_tree.jpg'></p><p>实现动态路由最常用的数据结构，被称为前缀树(Trie树)。每个节点的所有子节点都有相同的前缀。这种结构非常适用于路由匹配，例如我们定义了如下路由规则：</p><ul><li><code>/:lang/doc</code></li><li><code>/:lang/tutorial</code></li><li><code>/:lang/intro</code></li><li><code>/about</code></li><li><code>/p/blog</code></li><li><code>/p/related</code></li></ul><p>我们用前缀树表示，是这样的：</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day3_trie_tree_web.jpg'></p><p>HTTP请求的路径恰好是由<code>/</code>分割的多端构成的，因此，每一段可以作为前缀树的一个节点。我们通过树结构查询，如果中间某一层的节点都不满足条件，那么就说明没有匹配到的路由，查询结束。</p><p>接下来我们实现的动态路由具备以下俩功能：</p><ul><li>参数匹配：例如<code>/p/:lang/doc</code>，可以匹配<code>/p/c/doc</code>和<code>p/go/doc</code>。</li><li>通配<code>*</code>，例如<code>/static/*filepath</code>，可以匹配<code>/static/fav.ico</code>，也可以匹配<code>/static/js/jQuery.js</code>，这种模式常用于静态服务器，能够递归地匹配子路径。</li></ul><h4 id="trie树实现">Trie树实现</h4><p>首先需要设计树节点上应存储哪些信息。</p><blockquote><p>day3/gee/trie.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type node struct &#123;    pattern string &#x2F;&#x2F; 待匹配路由，例如 &#x2F;p&#x2F;:lang    part string &#x2F;&#x2F; 路由中一部分，例如 :lang    children []*node &#x2F;&#x2F; 子节点，例如 [doc, tutorial, intro]    isWild bool &#x2F;&#x2F; 是否精确匹配，part含有 : 或 * 时为true&#125;&#x2F;&#x2F; 这里重写String函数,便于后期查看相关参数的值(直接输出n.children是打印地址)func (n node) String() string &#123;    return fmt.Sprintf(&quot;pattern:%s, part:%s, children:%s, isWild:%t&quot;, n.pattern, n.part, n.children, n.isWild)&#125;</code></pre><p>与普通的树不同，为了实现动态路由匹配，加上了<code>isWild</code>这个参数。即当我们匹配<code>/p/go/doc</code>这个路由时 (<code>/</code>算0个节点) ，第一层节点，<code>p</code>精确匹配到了<code>p</code>，第二层节点，<code>go</code>模糊匹配到<code>:lang</code>，那么会将<code>lang</code>这个参数赋值为<code>go</code>，继续下一层匹配。我们将匹配的逻辑，包装为一个辅助函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 第一个匹配成功的节点，用于插入func (n *node) matchChild(part string) *node &#123;    for _, child :&#x3D; range n.children &#123;        &#x2F;&#x2F; 这里之前一直没搞懂为什么要忽略range的第一个参数,查阅资料后发现,第一个参数是索引值index,第二个参数是value,这里第二个参数,就是n的子节点        if child.part &#x3D;&#x3D; part || child.isWild &#123;            return child        &#125;    &#125;    return nil&#125;&#x2F;&#x2F; 所有匹配成功的节点，用于查找func (n *node) matchChildren(part string) []*node &#123;    nodes :&#x3D; make([]*node, 0) &#x2F;&#x2F; new一个长度为0的切片    for _, child :&#x3D; range n.children &#123;        if child.part &#x3D;&#x3D; part || child.isWild &#123;            nodes &#x3D; append(nodes, child)            &#x2F;&#x2F; 将匹配成功的节点加入到nodes中        &#125;    &#125;    return nodes&#125;</code></pre><p>对于路由来说，最重要的当然是注册于匹配了。开发服务时，注册路由规则，映射handler；访问时，匹配路由规则，查找到对应的handler。因此，Trie树需要支持节点的插入与查询。插入功能很简单，递归查找每一层的节点，如果没有匹配到当前<code>part</code>的节点，则新建一个，有一点需要注意，<code>/p/:lang/doc</code>只有在第三层节点，即<code>doc</code>节点，<code>pattern</code>才会设置为<code>/p/:lang/doc</code>。<code>p</code>和<code>:lang</code>节点的<code>pattern</code>属性皆为空。因此，当匹配结束时，我们可以用<code>n.pattern == ""</code>来判断路由规则是否匹配成功。例如，<code>/p/python</code>虽能成功匹配到<code>:lang</code>，但<code>:lang</code>的<code>pattern</code>值为空，因此匹配失败。查询功能，同样也是递归查询每一层的节点，退出规则是，匹配到 * ，匹配失败，或匹配到第<code>len(parts)</code>层节点。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (n *node) insert(pattern string, parts []string, height int) &#123;    if len(parts) &#x3D;&#x3D; height &#123;&#x2F;&#x2F; 这里其实是层层递归        n.pattern &#x3D; pattern        return    &#125;        part :&#x3D; parts[height]    child :&#x3D; n.matchChild(part)    if child &#x3D;&#x3D; nil &#123;        child &#x3D; &amp;node&#123;part: part, isWild: part[0] &#x3D;&#x3D; &#39;:&#39; || part[0] &#x3D;&#x3D; &#39;*&#39;&#125;        n.children &#x3D; append(n.children, child)    &#125;    child.insert(pattern, parts, height + 1)&#125;func (n *node) search(parts []string, height int) *node &#123;    if len(parts) &#x3D;&#x3D; height || strings.HasPrefix(n.part, &quot;*&quot;) &#123;        if n.pattern &#x3D;&#x3D; &quot;&quot; &#123;            return nil        &#125;        &#x2F;&#x2F; 若以*为开头的字串,直接以此节点为当前分支尾节点        return n    &#125;        part :&#x3D; parts[height]    &#x2F;&#x2F; (height+1)的值是当前搜索的层数    children :&#x3D; n.matchChildren(part)    &#x2F;&#x2F; children则含有搜索到每一层的part        for _, child :&#x3D; range children &#123;        result :&#x3D; child.search(parts, height + 1)        if result !&#x3D; nil &#123;            return result        &#125;    &#125;        return nil&#125;func (n *node) travel(list *([]*node)) &#123;    if n.pattern !&#x3D; &quot;&quot; &#123;        *list &#x3D; append(*list, n)    &#125;    for _, child :&#x3D; range n.children &#123;        child.travel(list)    &#125;&#125;</code></pre><h4 id="router">Router</h4><p>Trie树的插入与查找都成功实现了，接下来我们将Trie树应用到路由中。我们用roots来存储每种请求方式的Trie树根节点。使用handlers存储每种请求方式的HandlerFunc。getRoute函数中，还解析了<code>:</code>和<code>*</code>两种匹配符的参数，返回一个 map。例如<code>/p/go/doc</code>匹配到<code>/p/:lang/doc</code>，解析结果为<code>&#123;lang: "go"&#125;</code>，<code>/static/css/gee.css</code>匹配到<code>/static/*filepath</code>，解析结果为<code>&#123;filepath: "css/gee.css"&#125;</code>。</p><blockquote><p>day3/gee/router.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type router struct &#123;    roots map[string]*node    handlers map[string]HandlerFunc&#125;&#x2F;&#x2F; roots key eg, roots[&#39;GET&#39;] roots[&#39;POST&#39;]&#x2F;&#x2F; handlers key eg, handlers[&#39;GET-&#x2F;p&#x2F;:lang&#x2F;doc&#39;], handlers[&#39;POST-&#x2F;p&#x2F;book&#39;]func newRouter() *router &#123;    return &amp;router &#123;        roots: make(map[string]*node),        handlers: make(map[string]HandlerFunc),    &#125;&#125;&#x2F;&#x2F; Only one * is allowedfunc parsePattern(pattern string) []string &#123;    vs :&#x3D; strings.Split(pattern, &quot;&#x2F;&quot;)    &#x2F;&#x2F; 一层层获取并判断是否为有效节点字串    parts :&#x3D; make([]string, 0)    for _, item :&#x3D; range vs &#123;        if item !&#x3D; &quot;&quot; &#123;            parts &#x3D; append(parts, item)            if item[0] &#x3D;&#x3D; &#39;*&#39; &#123;                break                &#x2F;&#x2F; 这里只要当前节点为*,则结束后面的遍历,以*为当前分支尾节点            &#125;        &#125;    &#125;    return parts&#125;func (r *router) addRoute(method string, path string) (*node, map[string]string) &#123;    searchParts :&#x3D; parsePattern(pattern)        key :&#x3D; method + &quot;-&quot; + pattern    _, ok :&#x3D; r.roots[method]&#x2F;&#x2F; 这里卡的比较久,第一个返回值是获取的值,第二个是判断值是否获取成功    if !ok &#123;        r.roots[method] &#x3D; &amp;node&#123;&#125;        &#x2F;&#x2F; 一般来说,对于一个新路由,node默认是空,    &#125;    r.roots[method].insert(pattern, parts, 0)    r.handlers[key] &#x3D; handler&#125;func (r *router) getRoute(method string, path string) (*node, map[string]string) &#123;    searchParts :&#x3D; parsePattern(path)    params :&#x3D; make(map[string]string)    root, ok :&#x3D; r.roots[method]        if !ok &#123;        return nil, nil    &#125;        n :&#x3D; roots.search(searchParts, 0)        if n !&#x3D; nil &#123;        parts :&#x3D; parsePattern(n.pattern)        for index, part :&#x3D; range parts &#123;            &#x2F;&#x2F; getRoute的参数匹配,这里匹配:和*两种字符            if part[0] &#x3D;&#x3D; &#39;:&#39; &#123;                params[part[1:]] &#x3D; searchParts[index]            &#125;            if part[0] &#x3D;&#x3D; &#39;*&#39; &amp;&amp; len(part) &gt;1 &#123;                params[part[1:]] &#x3D; strings.Join(searchParts[index:], &quot;&#x2F;&quot;)                break            &#125;        &#125;        return n, params    &#125;    return nil, nil&#125;func (r *router) getRoutes(method string) []*node &#123;    root, ok :&#x3D; r.roots[method]    if !ok &#123;        return nil    &#125;    nodes :&#x3D; make([]*node, 0)    root.travel(&amp;nodes)    return nodes&#125;</code></pre><h4 id="context与handle的变化">Context与handle的变化</h4><p>在HandleFunc中，希望能够访问到解析的参数，因此，需要对Context对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数储存到<code>Params</code>中，通过<code>c.Param("lang")</code>的方式获取到对应的值。</p><blockquote><p>day3/gee/context.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Context struct &#123;    &#x2F;&#x2F; origin objects    Writer http.ResponseWriter    Req *http.Request    &#x2F;&#x2F; request info    Path string    Method string    Params map[string]string    &#x2F;&#x2F; response info    StatusCode int&#125;func (c *Context) Param(key string) string &#123;    value :&#x3D; c.Params[key]     return value&#125;</code></pre><blockquote><p>day3/gee/router.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (r *router) handle(c *Context) &#123;    n, params :&#x3D; r.getRoute(c.Method, c.Path)    if n !&#x3D; nil &#123;        c.Params &#x3D; params        key :&#x3D; c.Method + &quot;-&quot; +n.pattern        r.handlers[key](c)    &#125; else &#123;        c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\n&quot;, c.Path)    &#125;&#125;</code></pre><p><code>router.go</code>的变化比较小，比较重要的一点是，在调用匹配到的<code>handler</code>前，将解析出来的路由参数赋值给了<code>c.Params</code>。这样就能够在<code>handler</code>中，通过<code>Context</code>对象访问到具体的值了</p><h4 id="单元测试">单元测试</h4><blockquote><p>router_test.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package geeimport (    &quot;fmt&quot;    &quot;reflect&quot;    &quot;testing&quot;)func newTestRouter() *router &#123;    r :&#x3D; newRouter()    r.addRoute(&quot;GET&quot;, &quot;&#x2F;&quot;, nil)    r.addRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;:name&quot;, nil)    r.addRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;b&#x2F;c&quot;, nil)    r.addRoute(&quot;GET&quot;, &quot;&#x2F;hi&#x2F;:name&quot;, nil)    r.addRoute(&quot;GET&quot;, &quot;&#x2F;assets&#x2F;*filepath&quot;, nil)    return r&#125;func TestParsePattern (t *testing.T) &#123;    r :&#x3D; newTestRouter()    ok :&#x3D; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;:name&quot;), []string&#123;&quot;p&quot;, &quot;:name&quot;&#125;)    ok &#x3D; ok &amp;&amp; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;*&quot;), []sring&#123;&quot;p&quot;, &quot;*&quot;&#125;)    ok &#x3D; ok &amp;&amp; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;*name&#x2F;*&quot;), []string&#123;&quot;p&quot;, &quot;*name&quot;&#125;)    if !ok &#123;        t.Fatal(&quot;test parsePattern failed&quot;)    &#125;    &#125;func TestGetRoute(t *testing.T) &#123;    r :&#x3D; newTestRouter()    n, ps :&#x3D; r.getRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;gee&quot;)        if n &#x3D;&#x3D; nil &#123;        t.Fatal(&quot;nil shouldn&#39;t be returned&quot;)    &#125;        if n.pattern !&#x3D; &quot;&#x2F;hello&#x2F;:name&quot; &#123;        t.Fatal(&quot;should match &#x2F;hello&#x2F;:name&quot;)    &#125;        if ps[&quot;name&quot;] !&#x3D; &quot;gee&quot; &#123;        t.Fatal(&quot;should match be equal to gee&quot;)    &#125;        fmt.Printf(&quot;matched path: %s, params[&#39;name&#39;]: %s\n&quot;, n.pattern, ps[&quot;name&quot;])&#125;func TestGetRoute2(t *testing.T) &#123;    r :&#x3D; newTestRouter()    n1, ps1 :&#x3D; r.getRoute(&quot;GET&quot;, &quot;&#x2F;assets&#x2F;file1.txt&quot;)    ok1 :&#x3D; n1.pattern &#x3D;&#x3D; &quot;&#x2F;assets&#x2F;*filepath&quot; &amp;&amp; ps1[&quot;filepath&quot;] &#x3D;&#x3D; &quot;file1.txt&quot;    if !ok1 &#123;        t.Fatal(&quot;pattern should be &#x2F;assets&#x2F;*filepath &amp; filepath should be file1.txt&quot;)    &#125;        n2, ps2 :&#x3D; r.getRoute(&quot;GET&quot;, &quot;&#x2F;assets&#x2F;css&#x2F;test.css&quot;)    ok2 :&#x3D; n2.pattern &#x3D;&#x3D; &quot;&#x2F;assets&#x2F;*filepath&quot; &amp;&amp; ps2[&quot;filepath&quot;] &#x3D;&#x3D; &quot;css&#x2F;test.css&quot;    if !ok2 &#123;        t.Fatal(&quot;pattern should be &#x2F;assets&#x2F;*filepath &amp;filepath should be css&#x2F;test.css&quot;)    &#125;&#125;func TestGetRoutes(t *testing.T) &#123;    r :&#x3D; newTestRouter()    nodes :&#x3D; r.getRoutes(&quot;GET&quot;)    for i, n :&#x3D; range nodes &#123;        fmt.Println(i+1, n)    &#125;        if len(nodes) !&#x3D; 5 &#123;        t.Fatal(&quot;the number of routes should be 4&quot;)    &#125;&#125;</code></pre><h4 id="使用demo">使用DEMO</h4><blockquote><p>day3/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;gee&quot;    &quot;net&#x2F;http&quot;)func main() &#123;    r :&#x3D; gee.New()    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;&lt;h1&gt;Hello gee&lt;&#x2F;h1&gt;&quot;)    &#125;)        r.GET(&quot;&#x2F;hello&quot;, func(c *gee.Context) &#123;        &#x2F;&#x2F; expect &#x2F;hello?name&#x3D;xxx        c.String(http.StatucOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Query(&quot;name&quot;), c.Path)    &#125;)        r.GET(&quot;&#x2F;assets&#x2F;*filepath&quot;, func(c *gee.Context) &#123;        c.JSON(http.StatusOK, gee.H&#123;&quot;filepath&quot;: c.Param(&quot;filepath&quot;)&#125;)    &#125;)        r.Run(&quot;:9999&quot;)&#125;</code></pre><p>使用curl测试</p><pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;hello&#x2F;abchello abd, you&#39;re at &#x2F;hello&#x2F;abc$ curl &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;assets&#x2F;css&#x2F;abc.css&quot;&#123;&quot;filepath&quot;:&quot;css&#x2F;abc.css&quot;&#125;</code></pre><h4 id="day3小结">day3小结</h4><p>之前因为一项暑期实践活动的工作 , 我没有很认真地过一遍 , 也只是草草地敲一遍代码 , 简单地挖几个函数的源码来看 , 后面因为实训项目就先搁置了这个gee框架的学习 , 等做完实训项目后 , 花了半天把代码敲了一遍 , 也运行了一遍 , 但还是觉得心里心里很没底，于是想着，从第一天的内容开始认真看一遍，然后就开始对着前两天的源码一顿操作，开始不断查看源码中函数引用的内容，在关键函数print相关变量，前两天内容并不算很难，到了第三天，可能是跳跃性太大，加上前两天基础不牢，我在这里卡了4天，加上这几天状态不太好，就学的比较慢，这几天意识到事情的严重性，稍微加快了脚步，对第三天的路由部分进行了更多的测试，也对这个路由部分有了更深的认识</p><h3 id="day4.-分组控制group">day4. 分组控制Group</h3><ul><li>本次实现路由分组控制(Route Group Control)，代码约50行。</li></ul><h4 id="分组的意义">分组的意义</h4><p>分组控制(Route Group Control) 是Web框架应提供的基础功能之一。所谓分组，是指的路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如：</p><ul><li>以<code>/post</code>开头的路由匿名可访问</li><li>以<code>/admin</code>开头的路由需要鉴权</li><li>以<code>/api</code>开头的路由时RESTful接口 , 可以对接第三方平台 , 需要三方平台鉴权</li></ul><p>大部分情况下的路由分组 , 是以相同的前缀来区分的。因此，我们今天实现的分组控制也是以前缀来区分，并支持分组的嵌套。例如<code>/post</code>是一个分组，<code>/post/a</code>和<code>/post/b</code>可以是该分组下的子分组。作用在<code>/post</code>分组上 中间件(middleware)，也都会作用在子分组，子分组还可以应用自己特有的中间件。</p><p>中间件可以给框架提供无限的扩展能力，应用在分组上，可以使得分组控制的收益更为明显，而不是共享相同的路由前缀这么简单。例如<code>/admin</code>的分组，可以应用鉴权中间件；<code>/</code>分组应用日志中间件，<code>/</code>是默认的最顶层的分组，也就意味着给所有的路由，即整个框架增加了日志的能力。</p><p><strong>分组嵌套</strong></p><p>一个Group对象需要具备哪些属性呢？首先是前缀(prefix)，比如<code>/</code>，或者<code>/api</code>；要支持分组嵌套，那么需要知道当前分组的父亲(parent)是谁；当然了，按照我们一开始的分析，中间件是应用在分组上的，那还需要储存应用在该分组上的中间件(middlewares)。还记得，我们之前调用函数<code>*(Engine).addRoute()</code>来映射所有的路由规则和 Handler。如果Group对象需要直接映射路由规则的画，比如我们想在使用框架时，这么调用</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r :&#x3D; gee.New()v1 :&#x3D; r.Group(&quot;&#x2F;v1&quot;)v1.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;    c.HTML(http.StatusK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;&quot;)&#125;)</code></pre><p>那么Group对象，还需要有访问<code>Router</code>的能力，为了方便，我们可以在Group中，保存一个指针，指向<code>Engine</code>，整个框架的所有资源都是由<code>Engine</code>统一协调的，那么就可以通过<code>Engine</code>间接地访问各种接口了。</p><p>所以，最后的Group做出以下改动：</p><blockquote><p>day4/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type HandlerFunc func(*Context)type (    RouterGroup struct &#123;        prefix string        middlewares []HandlerFunc        parent *RouterGroup        engine *Engine    &#125;    &#x2F;&#x2F; 进一步抽象，将Engine作为最顶层的分组，也就是说Engine拥有RouterGroup的所有能力    Engine struct &#123;        *RouterGroup        router *router        groups []*RouterGroup    &#125;)&#x2F;&#x2F; 下面是实现和路由有关的函数func New() *Engine &#123;    engine :&#x3D; &amp;Engine&#123;router: newRouter()&#125;    engine.RouterGroup &#x3D; &amp;RouterGroup&#123;engine: engine&#125;    engine.groups &#x3D; []*RouterGroup&#123;engine.RouterGroup&#125;    return engine&#125;func (group *RouterGroup) Group(prefix string) *RouterGroup &#123;    engine :&#x3D; group.engine    newGroup :&#x3D; &amp;RouterGroup &#123;        prefix: group.prefix + prefix,        &#x2F;&#x2F; parent: group,        engine: engine,        &#x2F;&#x2F; 查阅评论区后，作者用gruop.prefix+prefix的方式初始化已经拼接了完整的prefix，不需要parent，于是可以删除    &#125;    engine.groups &#x3D; append(engine.groups, newGroup)    return newGroup&#125;func (group *RouterGroup) addRoute(method string, comp string, handler HandlerFunc) &#123;    pattern :&#x3D; group.prefix + comp    log.Printf(&quot;Route %4s - %s&quot;, method, pattern)    group.engine.router.addRoute(method, pattern, handler)&#125;func (group *RouterGroup) GET(pattern string, handler HandlerFunc) &#123;    group.addRoute(&quot;GET&quot;, pattern, handler)&#125;func (group *RouteGroup) POST(pattern string, handler HandlerFunc) &#123;    gourp.addRoute(&quot;POST&quot;, pattern, handler)&#125;</code></pre><p>在这里可以观察到<code>addRoute</code>函数，调用了<code>group.engine.router.addRoute</code>来实现了路由的映射。由于<code>Engine</code>从某种意义上继承了<code>RouterGroup</code>的所有属性和方法，因为<code>(*Engine).engine</code>是指向自己的。这样实现，我们既可以像原来一样添加路由，也可以通过分组添加路由。</p><h4 id="使用demo-1">使用Demo</h4><blockquote><p>day4/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;    r :&#x3D; gee.New()    r.GET(&quot;&#x2F;index&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;&lt;h1&gt;Index Page&lt;&#x2F;h1&gt;&quot;)    &#125;)    v1 :&#x3D; r.Group(&quot;&#x2F;v1&quot;)    &#123;        v1.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;            c.HTML(http.StatusOK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;&quot;)        &#125;)                v1.GET(&quot;&#x2F;hello&quot;, func(c *gee.Context) &#123;            &#x2F;&#x2F; expect &#x2F;hello?name&#x3D;abc            c.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Query(&quot;name&quot;), c.Path)        &#125;)    &#125;    v2 :&#x3D; r.Group(&quot;&#x2F;v2&quot;)    &#123;        v2.GET(&quot;&#x2F;hello&#x2F;:name&quot;, func(c *gee.Context) &#123;            &#x2F;&#x2F; expect &#x2F;hello&#x2F;abc            c.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Param(&quot;name&quot;), c.Path)        &#125;)        v2.POST(&quot;&#x2F;login&quot;, func(c *gee.Context) &#123;            c.JSON(http.StatusOK, gee.H&#123;                &quot;username&quot;: c.PostForm(&quot;username&quot;),                &quot;password&quot;: c.PostForm(&quot;password&quot;),            &#125;)        &#125;)    &#125;        r.Run(&quot;:9999&quot;)&#125;</code></pre><p>通过curl的简单测试：</p><pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">$ curl &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;v1&#x2F;hello?name&#x3D;abc&quot;hello abc, you&#39;re at &#x2F;v1&#x2F;abc$ curl &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;v2&#x2F;hello&#x2F;abc&quot;hello abc, you&#39;re at &#x2F;hello&#x2F;abc</code></pre><h3 id="day5.-中间件-middleware">day5. 中间件 Middleware</h3><ul><li>设计并实现Web 框架的中间件 (Middlewares)机制</li><li>实现通用的 Logger 中间件，能够记录请求到响应所花费的时间，代码约50行</li></ul><h4 id="中间件是什么">中间件是什么</h4><p>中间件(middlewares)，简单说，就是非业务的技术类组件。Web框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此，框架需要有一个插口，允许用户自定义功能，嵌入到框架中，仿佛这个功能是框架原生支持的一样。因此，对中间件而言，需要考虑2个比较关键的点：</p><ul><li>插入点在哪？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件逻辑就会非常复杂</li><li>中间件的输入是什么？中间件的输入，决定了扩展能力。暴露的参数太少，用户发挥空间有限。</li></ul><p>那对于一个Web框架而言，中间件应该设计成什么样呢？接下来的实现，基本参考了Gin框架。</p><h4 id="中间件设计">中间件设计</h4><p>Gee的中间件的定义与路由映射的Handler一致，处理的是输入的<code>Context</code>对象。插入点是框架接收到请求初始化<code>Context</code>对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对<code>Context</code>进行二次加工。另外通过调用<code>(*Context).Next()</code>函数，中间件可等待用户自己定义的<code>Handler</code>处理结束后，做一些额外的操作，例如计算本次处理所用时间等。即Gee的中间件支持用户在请求被处理的前后，做一些额外的操作。举个例子，我们希望最终能够支持如下定义的中间件，<code>c.Next()</code>表示等待执行其他的中间件或用户的<code>Handler</code>：</p><blockquote><p>day4/gee/logger.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Logger() HandlerFunc &#123;    return func(c *Context) &#123;        &#x2F;&#x2F; start timer        t :&#x3D; time.Now()        &#x2F;&#x2F; process request        c.Next()        &#x2F;&#x2F; calculate resolution time        log.Printf(&quot;[%d] %s in %v&quot;, c.StatusCode, c.Req.RequestURI, time.Since(t))    &#125;&#125;</code></pre><p>另外，支持设置多个中间件，依次进行调用。</p><p>在第四天的 "分组控制 Group Control"讲到，中间件是应用在<code>RouterGroup</code>上的，应用在最顶层的Group，相当于作用域全局，所有的请求都会被中间件处理。那为什么不作用在每一条路由规则上呢？作用在某条路由规则，那还不如用户直接在Handler中调用。只作用在某条路由规则的功能通透性太差，不适合定义为中间件。</p><p>我们之前的框架设计是这样的，当接收到请求后，匹配路由，该请求的所有信息都保存在<code>Context</code>中。中间件也不例外，接收到请求后，应查找所有应作用于该路由的中间件，保存在<code>Context</code>中，依次进行调用。为什么依次调用后，还需要在<code>Context</code>中保存呢？因为在设计中，中间件不仅作用在处理流程前，也可以作用在处理流程后，即在用户定义的Handler处理完毕后，还可以执行剩下的操作。</p><blockquote><p>day4/gee/context.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Context struct &#123;    &#x2F;&#x2F; origin objects    Writer http.ResponseWriter    Req *http.Request    &#x2F;&#x2F; request info    Path string    Method string    Params map[string]string    &#x2F;&#x2F; response info    StatusCode int    &#x2F;&#x2F; middleware    handlers []HandlerFunc    index int&#125;func newContext(w http.RequestWriter, req *http.Request) *Context &#123;    return &amp;Context &#123;        Path: req.URL.Path,        Method: req.Method,        Req: req,        Writer: w,        index: -1,    &#125;&#125;func (c *Context) Next() &#123;    c.index++    s :&#x3D; len(c.handlers)    for ; c.index &lt; s; c.index++ &#123;        c.handlers[c.index](c)    &#125;&#125;</code></pre><p><code>index</code>是记录当前执行到第几个中间件，当在中间件调用<code>Next</code>方法时，控制权交给了下一个中间件，直到调用到最后一个中间件，然后再从后往前，调用每个中间件在<code>Next</code>方法之后定义的部分。如果我们将用户在映射路由时定义的<code>Handler</code>添加到<code>c.handlers</code>列表中，结果会怎么样呢？</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func A(c *Context) &#123;    part1    c.Next()    part2&#125;func B(c *Context) &#123;    part3    c.Next()    part4&#125;</code></pre><p>假设我们应用了中间件A和B，和路由映射的Handler。<code>c.handlers</code>是这样的 <code>[A, B, Handler]</code>，<code>c.index</code>初始化为-1。调用<code>c.Next()</code>，接下来的流程是这样的：</p><ul><li>c.index++ , c.index=0</li><li>0 &lt; 3 , 调用<code>c.handlers[0]</code>，即A</li><li>执行part1，调用<code>c.Next()</code></li><li>c.index++，c.index=1</li><li>1 &lt; 3 , 调用<code>c.handlers[1]</code>，即B</li><li>执行part3，调用<code>c.Next()</code></li><li>c.index++ , c.index=2</li><li>2 &lt; 3 , 调用<code>c.handlers[2]</code>，即Handler</li><li>Handler调用完毕，返回到B中的part4，执行part4</li><li>part4执行完毕，返回到A中的part2，执行part2</li><li>part2执行完毕，结束</li></ul><p>说重点，执行顺序是<code>part1 -&gt; part3 -&gt; Handler -&gt; part4 -&gt;part2</code>。恰恰满足了我们对中间件的要求，接下来看调用部分的代码，就能全部串起来了。</p><h4 id="代码实现">代码实现</h4><p>定义<code>Use</code>函数，将中间件应用到某个Group</p><blockquote><p>day4/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Use is defined to add middlewares to the groupfunc (group *RouterGroup) Use(middlewares ...HandlerFunc) &#123;    group.middlewares &#x3D; append(group.middlewares, middlewares...)&#125;func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;    var middlewares []HandlerFunc    for _, group :&#x3D; range engine.groups &#123;        if strings.HasPrefix(req.URL.Path, group.prefix) &#123;            middlewares &#x3D; append(middlewares, group.middlewares...)        &#125;    &#125;    c :&#x3D; newContext(w, req)    c.handlers &#x3D; middlewares    engine.router.handle(c)&#125;</code></pre><p>ServeHTTP函数也有变化，当我们接收到一个具体请求时，要判断该请求适用于哪些中间件，在这里我们简单通过URL的前缀来判断。得到中间件列表，赋值给<code>c.handlers</code>。</p><p>handle函数中，将从路由匹配得到的Handler添加到<code>c.handlers</code>列表中，执行<code>c.Next()</code>。</p><blockquote><p>day4/gee/router.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (r *router) handle(c *Context) &#123;    n, params :&#x3D; r.getRoute(c.Method, c.Path)        if n !&#x3D; nil &#123;        key :&#x3D; c.Method + &quot;-&quot; +n.pattern        c.Params &#x3D; params        c.handlers &#x3D; append(c.handlers, r.handlers[key])    &#125; else &#123;        c.handlers &#x3D; append(c.handlers, func(c *Context) &#123;            c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\n&quot;, c.Path)        &#125;)    &#125;    c.Next()&#125;</code></pre><h4 id="使用demo-2">使用demo</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">func onlyForV2() gee.HandlerFunc &#123;    return func(c *gee.Context) &#123;        &#x2F;&#x2F; start timer        t :&#x3D; time.Now()        &#x2F;&#x2F; if a server error occurred        c.Fail(500, &quot;Internal Server Error&quot;)        &#x2F;&#x2F; Calculate resolution time        log.Printf(&quot;[%d] %s in %v for group v2&quot;, c.StatusCode, c.Req.RequestURI, time.Since(t))    &#125;&#125;func main() &#123;    r :&#x3D; gee.New()    r.Use(gee.Logger()) &#x2F;&#x2F; global middleware    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;&quot;)    &#125;)        v2 :&#x3D; r.Group(&quot;&#x2F;v2&quot;)    v2.Use(onlyForV2())    &#123;        v2.GET(&quot;&#x2F;hello&#x2F;:name&quot;, func(c *gee.Context) &#123;            &#x2F;&#x2F; expect &#x2F;hello&#x2F;gee            c.String(http.StatisOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Param(&quot;name&quot;), c.Path)        &#125;)    &#125;        c.Run(&quot;:9999&quot;)&#125;</code></pre><p><code>gee.Logger()</code>即我们一开始就介绍的中间件，我们将这个中间件和框架代码放在了一起，作为框架默认提供的中间件。在这个例子中，我们将<code>gee.Logger()</code>应用在了全局，所有的路由都会应用该中间件。<code>onlyForV2()</code>是用来测试功能的，尽在<code>v2</code>对应的Group中应用了。</p><p>接下来使用curl测试，可以看到，v2 Group 2个中间件都生效了。</p><pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;&lt;h1&gt;Hello Gee&lt;&#x2F;h1&gt;$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;v2&#x2F;hello&#x2F;abc&#123;&quot;message&quot;:&quot;Internal Server Error&quot;&#125;</code></pre><p>服务器端</p><pre class="line-numbers language-none"><code class="language-none">2022&#x2F;07&#x2F;27 16:00:01 [200] &#x2F; in 300ns2022&#x2F;07&#x2F;27 16:00:28 [500] &#x2F;v2&#x2F;hello&#x2F;abc in 0s for group v22022&#x2F;07&#x2F;27 16:00:28 [500] &#x2F;v2&#x2F;hello&#x2F;abc in 1.6176ms</code></pre><p>这里的测试v2中间件，一开始，测试了很多次，返回的都是500错误码，比对了源码很久，没发现问题，再次运行curl测试，还是返回500错误码。后面查阅了第五天的评论区，发现，day5的中间件仅仅用来演示，发送500错误码表示中间件起作用了。</p><h3 id="day6.-模板-html-template">day6. 模板 (HTML Template)</h3><ul><li>实现静态资源服务 (Static Resource)</li><li>支持HTML模板渲染</li></ul><h4 id="服务器渲染">服务器渲染</h4><p>现在越来越流行前后端分离的开发模式，即 Web 后端提供RESTful接口，返回结构化的数据 (通常为JSON或XML)。前端使用AJAX 技术请求到所需的数据，利用 JavaScript 进行渲染。Vue/React 等前端框架持续火热，这种开发模式前后端解耦，优势很突出。后端打工人专心解决资源利用，并发，数据库等问题，只需要考虑数据如何生成；前端打工人专注于界面设计实现，只需要考虑拿到数据后如何渲染即可。后端只关注于数据，接口返回值是结构化的，于前端解耦。同一套后端服务能够同时支撑小程序，移动app，pc端 Web界面，以及对外提供的接口。随着前端工程化的不断发展，Webpack，gulp等工具层出不穷，前端技术越来越自成体系了。</p><p>但是前后端分离的一大问题在于，页面是在客户端渲染的，比如浏览器，这对爬虫并不友好。</p><p>今天的内容便是介绍 Web框架如何支持服务端渲染的场景。</p><h4 id="静态文件-serve-static-files">静态文件 (Serve Static Files)</h4><p>网页三剑客，js，css，html。要做到服务端渲染，第一步便是要支持js，css等静态文件。之前设计动态路由的时候，支持通配符<code>*</code>匹配多级子路径。比如路由规则<code>/assets/*filepath</code>，可以匹配<code>/assets/</code>开头的所有地址。例如<code>/assets/js/geek.js</code>，匹配后，参数<code>filepath</code>旧赋值为<code>js/geek.js</code>。</p><p>那么如果我们将所有静态文件放在<code>/usr/web</code>目录下，那么<code>filepath</code>的值既是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。</p><p>找到文件后，如何返回这一文件，<code>net/http</code>库已经实现了。因此，gee框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给<code>http.FileServer</code>处理就好了。</p><blockquote><p>day6/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; create static handlerfunc (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc &#123;    absolutePath :&#x3D; path.Join(group.prefix, relativePath)    fileServer :&#x3D; http.StripPrefix(absolutePath, http.FileServer(fs))    return func(c *Context) &#123;        file :&#x3D; c.Param(&quot;filepath&quot;)        &#x2F;&#x2F; check if file exists and&#x2F;or if we have permission to access it        if _, err :&#x3D; fs.Open(file); err !&#x3D; nil &#123;            c.Status(http.StatusNotFound)            return        &#125;                fileServer.ServeHTTP(c.Writer, c.Req)    &#125;&#125;&#x2F;&#x2F; serve static filesfunc (group *RouterGroup) Static(relativePath string, root string) &#123;    handler :&#x3D; group.createStaticHandler(relativePath, http.Dir(root))    urlPattern :&#x3D; path.Join(relativePath, &quot;&#x2F;*filepath&quot;)    &#x2F;&#x2F; Register GET handlers    group.GET(urlPattern, handler)&#125;</code></pre><p>我们给<code>RouterGroup</code>添加了两个方法，<code>Static</code>这个方法是暴露给用户的。用户可以将磁盘上的某个文件夹<code>root</code>映射到路由<code>relativePath</code>。例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r :&#x3D; gee.New()r.Static(&quot;&#x2F;assets&quot;, &quot;&#x2F;usr&#x2F;Jayden&#x2F;blog&#x2F;static&quot;)&#x2F;&#x2F; 或者相对路径 r.Static(&quot;&#x2F;assets&quot;, &quot;.&#x2F;static&quot;)r.Run(&quot;:9999&quot;)</code></pre><p>用户访问<code>localhost:9999/assets/js/geek.js</code></p><p>最终返回<code>/usr/geek/blog/static/js/geek.js</code>。</p><h4 id="html-模板渲染">HTML 模板渲染</h4><p>golang内置了<code>text/template</code>和<code>html/template</code>2个模板标准库，其中 <a href='https://golang.org/pkg/html/template'>html/template</a> 为 HTML提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。gee框架的模板渲染直接使用了<code>html/template</code>提供的能力。</p><blockquote><p>day6/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">Engine struct &#123;    *RouterGroup    router *router    groups []*RouterGroup &#x2F;&#x2F; store all groups    htmlTemplate *template.Template &#x2F;&#x2F; for html render    funcMap template.FuncMap &#x2F;&#x2F; for html render&#125;func (engine *Engine) SetFuncMap(funcMap template.FuncMap) &#123;    engine.funcMap &#x3D; funcMap&#125;func (engine *Engine) LoadHTMLGlob(pattern string) &#123;    engine.htmlTemplates &#x3D; template.Must(template.New(&quot;&quot;).Funcs(engine.funcMap).ParseGlob(pattern))&#125;</code></pre><p>首先为 Engine 实例添加了<code>*template.Template</code>和<code>template.FuncMap</code>对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。</p><p>另外，给用户分别提供了设置自定义渲染函数<code>funcMap</code>和加载模板的方法。</p><p>接下来，对原来的<code>(*Context).HTML()</code>方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p><blockquote><p>day6/gee/context.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Context struct &#123;    &#x2F;&#x2F; ..    &#x2F;&#x2F; engine pointer    engine *Engine&#125;func (c *Context) HTML(code int, name string, data interface&#123;&#125;) &#123;    c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;)    c.Status(code)    if err :&#x3D; c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err !&#x3D; nil &#123;        c.Fail(500, err.Error())    &#125;&#125;</code></pre><p>我们在<code>Context</code>中添加了成员变量<code>engine *Engine</code>，这样就能够通过Context访问 Engine 中的HTML模板。实例化Context时，还需要给<code>c.engine</code>赋值。</p><blockquote><p>day6/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;    &#x2F;&#x2F; ...    c :&#x3D; newContext(w, req)    c.handlers &#x3D; middlewares    c.engine &#x3D; engine    engine.router.handle(c)&#125;</code></pre><h4 id="使用demo-3">使用Demo</h4><p>最终目录结构</p><pre class="line-numbers language-none"><code class="language-none">---gee&#x2F;---static&#x2F;   |---css&#x2F;       |---geek.css   |---file1.txt---template   |---arr.tmpl   |---css.tmpl   |---custom_func.tmpl---main.go</code></pre><blockquote><p>day6/templates/arr.tmpl</p></blockquote><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;html&gt;    &lt;body&gt;        &lt;p&gt;hello, &#123;&#123;.title&#125;&#125;&lt;&#x2F;p&gt;        &#123;&#123;range $index, $ele :&#x3D;.stuArr&#125;&#125;        &lt;p&gt;&#123;&#123; $index&#125;&#125;: &#123;&#123;$ele.Name&#125;&#125; is &#123;&#123; $ele.Age&#125;&#125; years old&lt;&#x2F;p&gt;        &#123;&#123;end&#125;&#125;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><blockquote><p>day6/template/css.tmpl</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;html&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;assets&#x2F;css&#x2F;geek.css&quot;&gt;    &lt;p&gt;geek.css is loaded&lt;&#x2F;p&gt;&lt;&#x2F;html&gt;</code></pre><blockquote><p>day6/template/custom_func.tmpl</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;html&gt;    &lt;body&gt;        &lt;p&gt;hello, &#123;&#123;.title&#125;&#125;&lt;&#x2F;p&gt;        &lt;p&gt;Date: &#123;&#123;.now | FormatDate&#125;&#125;&lt;&#x2F;p&gt;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><blockquote><p>day6/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type student struct &#123;    Name string    Age int8&#125;func FormatAsDate(t time.Time) string &#123;    year, month, day :&#x3D; t.Date()    return fmt.Sprintf(&quot;%d-%02d-%02d&quot;, year, month, day)&#125;func main() &#123;    r :&#x3D; gee.New()    r.Use(gee.Logger())    r.SetFuncMap(template.FuncMap&#123;        &quot;FormatAsDate&quot;: FormatAsDate,    &#125;)    r.LoadHTMLGlob(&quot;templates&#x2F;*&quot;)    r.Static(&quot;&#x2F;assets&quot;, &quot;.&#x2F;static&quot;)        stu1 :&#x3D; &amp;student&#123;Name: &quot;gee&quot;, Age: 20&#125;    stu2 :&#x3D; &amp;student&#123;Name: &quot;Jay&quot;, Age: 22&#125;    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;css.tmpl&quot;, nil)    &#125;)    r.GET(&quot;&#x2F;students&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK), &quot;arr.tmpl&quot;, gee.H&#123;            &quot;title&quot;: &quot;gee&quot;,            &quot;stuArr&quot;: [2]*student&#123;stu1, stu2&#125;,        &#125;)    &#125;)        r.GET(&quot;&#x2F;students&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;custom_func.tmpl&quot;, gee.H&#123;            &quot;title&quot;: &quot;gee&quot;,            &quot;now&quot;: time.Date(2019,8,17,0,0,0,0,time.UTC)        &#125;)    &#125;)        r.Run(&quot;:9999&quot;)&#125;</code></pre><p>在浏览器访问主页，模板正常渲染，css静态文件加载成功</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day6.png'></p><h3 id="day7.-错误恢复-panic-recover">day7. 错误恢复 (Panic Recover)</h3><blockquote><p>实现错误处理机制</p></blockquote><h4 id="panic">panic</h4><p>golang中，比较常见的错误处理方法是返回error，由调用者决定后续如何处理。但是如果是无法恢复的错误，可以手动触发panic，当然如果在程序运行过程中出现了类似于数组越界的错误，panic也会被触发。panic会中止当前执行的程序，退出。</p><p>下面是主动触发的例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package main&#x2F;&#x2F; hello.gofunc main() &#123;    fmt.Println(&quot;before panic&quot;)    panic(&quot;crash&quot;)    fmt.Println(&quot;after panic&quot;)&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">$ go run hello.gobefore panic panic: crashgoroutine 1 [running]:main.main()        ~&#x2F;*your path*&#x2F;hello.go:5 +0x95exit status 2</code></pre><p>下面是数组越界触发的panic</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package main&#x2F;&#x2F; hello.gofunc main() &#123;    arr :&#x3D; []int&#123;1, 2, 3&#125;    fmt.Println(arr[4])&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">$ go run hello.gopanic: runtime error: index out of range [4] with legnth 3</code></pre><h4 id="defer">defer</h4><p>panic会导致程序被中止，但是在退出前，会先处理完当前携程上已经defer的任务，执行完成后再退出。效果类似于Java语言的<code>try...catch</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package main&#x2F;&#x2F; hello.gofunc main() &#123;    defer func() &#123;        fmt.Println(&quot;defer func&quot;)    &#125;()        arr :&#x3D; []int &#123;1, 2, 3&#125;    fmt.Println(arr[4])&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">$ go run hello.godefer funcpanic: runtime error: index out of range [4] with length 3</code></pre><p>可以defer多个任务，在同一个函数中defer多个任务，会逆序执行。即先执行最后的defer的任务 (类似于栈)。</p><p>在这里，defer的任务执行完成之后，panic还会继续被抛出，导致程序非正常结束。</p><h4 id="recover">recover</h4><p>golang还提供了recover函数，可以避免因为panic发生而导致整个程序终止，recover函数只在defer中生效</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; recover.gofunc test_recover() &#123;    defer func() &#123;        fmt.Println(&quot;defer func&quot;)        if err :&#x3D; recover(); err !&#x3D; nil &#123;            fmt.Println(&quot;recover success&quot;)        &#125;    &#125;()        arr :&#x3D; []int&#123;1, 2, 3&#125;    fmt.Println(arr[4])    fmt.Println(&quot;after panic&quot;)&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">$ go run recover.godefer funcrecover successafter recover</code></pre><p>我们可以看到，recover捕获了panic，程序正常结束。<code>test_recover()</code>中的after panic没有打印，这是正确的，当panic被触发时，控制权就被交给了defer。就像在Java中，<code>try</code>代码块中发生了异常，控制权交给了<code>catch</code>，接下来执行catch代码块中的代码。而在<code>main()</code>中打印了after recover，说明程序已经恢复正常，继续往下执行到结束。</p><h4 id="gee的错误处理机制">Gee的错误处理机制</h4><p>对一个Web框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。</p><p>我们在第六天实现的框架并没有加入异常处理机制，如果代码中存在会触发panic的bug，就很容易宕机。</p><p>看下面示例代码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; hello.gofunc main() &#123;    r :&#x3D; gee.New()    r.GET(&quot;&#x2F;panic&quot;, func(c *gee.Context) &#123;        names :&#x3D; []string&#123;&quot;gee&quot;&#125;        c.String(http.StatusOK, names[100])    &#125;)    r.Run(&quot;:9999&quot;)&#125;</code></pre><p>在上面的代码中，我们为gee注册了路由<code>/panic</code>，而这个路由的处理函数内部存在数组越界<code>names[100]</code>，如果访问<code>localhost:9999/panic</code>，web服务器就会宕掉。</p><p>今天，我们将在gee中添加一个添加一个非常简单的错误处理机制，即在此类错误发生时，向用户返回 Internal Server Error，并且在日志中打印必要的错误信息，方便进行错误定位。</p><p>我们之前实现了中间件机制，错误处理也可以作为一个中间件，增强gee框架的能力。</p><blockquote><p>day7/gee/recovery.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package geeimport (    &quot;fmt&quot;    &quot;log&quot;    &quot;net&#x2F;http&quot;    &quot;runtime&quot;    &quot;strings&quot;)&#x2F;&#x2F; print stack trace for debugfunc trace(message string) string &#123;    var pcs [32]uintptr    n :&#x3D; runtime.Callers(3, pcs[:]) &#x2F;&#x2F; skip first 3 caller        var str strings.Builder    str.WriteString(message + &quot;\nTraceback: &quot;)    for _, pc :&#x3D; range pcs[:n] &#123;        fn :&#x3D; runtime.FuncForPC(pc)        file, line :&#x3D; fn.FileLine(pc)        str.WriteString(fmt.Sprintf(&quot;\n\t%s:%d&quot;, file, line))    &#125;    return str.String()&#125;func Recovery() HandlerFunc &#123;    return func(c *Context) &#123;        defer func() &#123;            if err :&#x3D; recover(); err !&#x3D; nil &#123;                message :&#x3D; fmt.Sprintf(&quot;%s&quot;, err)                log.Printf(&quot;%s\n\n&quot;, trace(message))                c.Fail(http.StatusInternalServerError, &quot;Internal Server Error&quot;)            &#125;        &#125;()        c.Next()    &#125;&#125;</code></pre><p><code>Recovery()</code>的实现很简单，使用defer挂载上错误恢复的函数，在这个函数中调用<code>recover()</code>，捕获panic，并且将堆栈信息打印在日志里，向用户返回Internal Server Error。</p><p>在<code>trace()</code>中，调用了<code>runtime.Callers(3, pcs[:])</code>，Callers用来返回调用栈的程序计数器，第0个Caller是Callers本身，第一个是上一层trace，第二个是再上一层的<code>defer func</code>。因此，为了日志简洁一点，我们跳过前三个Caller。</p><p>接下来，通过<code>runtime.FuncForPC(pc)</code>获取对应的函数，再通过<code>fn.FileLine(pc)</code>获取到调用该函数的文件名和行号，打印在日志里。</p><p>至此，gee框架的错误处理机制就完成了。</p><blockquote><p>day7/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Default() *Engine &#123;    engine :&#x3D; New()    engine.Use(Logger(), Recovery())    return engine&#125;</code></pre><h4 id="使用demo-4">使用Demo</h4><blockquote><p>day7/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;net&#x2F;http&quot;    &quot;gee&quot;)func main() &#123;    r :&#x3D; gee.Default()    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;        c.String(http.StatusOK, &quot;hello gee\n&quot;)    &#125;)    &#x2F;&#x2F; index out of range for testing Recovery()    r.GET(&quot;&#x2F;panic&quot;, func(c *gee.Context) &#123;        names :&#x3D; []string&#123;&quot;gee&quot;&#125;\        c.String(http.StatusOK, names[100])    &#125;)    r.Run(&quot;:9999&quot;)&#125;</code></pre><p>下面来进行测试，先访问一个主页，访问一个有bug的<code>/panic</code>，服务正常返回。接下来我们再一次成功访问了主页，说明服务完全运转正常。</p><blockquote><p>Client</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$ curl http:&#x2F;&#x2F;localhost:9999hello gee$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;panic&#123;&quot;message&quot;:&quot;Internal Server Error&quot;&#125;$ curl http:&#x2F;&#x2F;localhost:9999hello gee</code></pre><blockquote><p>Server</p></blockquote><p>我们可以在后台日志中看到如下内容，引发错误的原因和堆栈信息都被打印了出来，通过日志，我们可以很容易知道，在day7/main.go:47的地方出现了<code>index out of range</code>的错误。</p><pre class="line-numbers language-none"><code class="language-none">2022&#x2F;07&#x2F;29 22:15:43 Route  GET - &#x2F;2022&#x2F;07&#x2F;29 22:15:43 Route  GET - &#x2F;panic2022&#x2F;07&#x2F;29 22:15:45 runtime error: index out of range [100] with length 1Traceback:    &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;panic.go:838        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;panic.go:89        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;main.go:17        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;context.go:41        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;recovery.go:56        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;context.go:41        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;logger.go:15        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;context.go:41        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;router.go:101        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;gee.go:121        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;http&#x2F;server.go:2917        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;http&#x2F;server.go:1967        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;asm_amd64.s:15722022&#x2F;07&#x2F;29 22:15:45 [500] &#x2F;panic in 103.5μs</code></pre><h3 id="一些想法">一些想法</h3><p>其实整篇做下来吧，其实到现在对整个框架只能够说是大概了解，自己也跟着博客敲了一遍，也大概能看懂作者的设计思路，先做一个简单的http相应，后面再添加Context、前缀树等等。</p><p>在做的过程中，也会遇到很多bug，不同于c，Java，golang这门语言，个人感觉抽象程度比Java这些高，有时候出现panic，找到了出错的行数，还得去翻阅源码，不过吧，这个也算是在锻炼自己的动手能力和解决问题的能力，也算是有些收获吧。</p><h3 id="参考链接">参考链接</h3><p><a href="https://geektutu.com/post/gee.html">7天用Go从零实现Web框架Gee教程 | 极客兔兔 (geektutu.com)</a></p><p><a href="https://blog.csdn.net/m0_52649917/article/details/121640535">(79条消息) 解决vscode和go mod 导包冲突的问题_sora!的博客-CSDN博客_gomod vscode</a></p><p><a href="https://blog.csdn.net/qiu_huouho/article/details/120733522">(80条消息) vscode使用go get 之后无法import_Restart丶的博客-CSDN博客</a></p><p><a href="https://vimsky.com/examples/usage/fmt-fprintf-function-in-golang-with-examples.html">Golang fmt.Fprintf()用法及代码示例 - 纯净天空 (vimsky.com)</a></p><p><a href="https://www.cnblogs.com/maji233/p/11178413.html">理解Golang中的interface和interface{} - maji233 - 博客园 (cnblogs.com)</a></p><p><a href="https://laravelacademy.org/post/21639">Go 语言通过 Request 对象读取 HTTP 请求报文 | 请求处理 | Go Web 编程 (laravelacademy.org)</a></p><p><a href="https://www.imooc.com/wenda/detail/664445#:~:text=http.ResponseWriter用来配置HTTP响应和发送数据给客户端的也是这样一个，io.Writer你要发送的数据（响应体）是通过调用组装的（不一定只有一次）ResponseWriter.Write,()（这是实现通用的io.Writer）.">ResponseWriter.Write 和 io.WriteString 有什么区别？_慕课猿问 (imooc.com)</a></p><p><a href="https://blog.csdn.net/qwe1765667234/article/details/124299251?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-124299251-blog-109959201.pc_relevant_multi_platform_whitelistv1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-124299251-blog-109959201.pc_relevant_multi_platform_whitelistv1&amp;utm_relevant_index=10">(79条消息) Go net.http包下的ListenAndServe函数的参数问题_qwe1765667234的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_34021712/article/details/109959201">(79条消息) Go使用net/http标准库(二)源码学习之- http.ListenAndServe()_这个名字想了很久的博客-CSDN博客</a></p><p><a href="https://cloud.tencent.com/developer/ask/sof/206511">ServeHTTP是如何工作的？ - 问答 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
    
    
    <summary type="html">用七天实现一个类Gin的Web框架</summary>
    
    
    
    <category term="BackEnd" scheme="https://jaydenchang.top/categories/BackEnd/"/>
    
    
    <category term="Golang" scheme="https://jaydenchang.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>摄影的哲与思</title>
    <link href="https://jaydenchang.top/post/0x002E.html"/>
    <id>https://jaydenchang.top/post/0x002E.html</id>
    <published>2022-07-19T16:00:00.000Z</published>
    <updated>2022-07-20T14:43:56.191Z</updated>
    
    <content type="html"><![CDATA[<p>其实这篇文章，我已经酝酿了很久了，因为各种原因，又搁置了一段时间，恰好后面受软协技术部的邀请，我去做了一次面向软协内部的分享会。当然，由于各种原因，本次分享会没什么人听 <del>(好像是撞上了香农班)</del>，不过也在我意料之中 <del>(这样就越少人能看到我口糊的一面)</del>。</p><p>关于那天，其实我并不认为是一次分享会，更多的是一种聊天吧。</p><h4 id="缘起">缘起</h4><p>其实我在大二以前，完全可以说是对摄影没有任何概念，就算拍的话，也只是一些简单的路人照，对构图、颜色搭配没有什么研究。记得当时好像是在大一暑假吧，那时和Sam外出散心，路过沙面，被眼前的欧式风格吸引，于是拿出手机咔咔几张，也没去考虑构图啥的，觉得还挺好看，就直接放到了pyq上。</p><p>到后面吧，有一次准备出宿舍时，看到了很好看的晚霞，顺手拍了下来，还特意下了"SnapSeed"去调色，虽然调的有点离谱，饱和度调太过了，不过也还是满足了我的虚荣，包括两周后的一个早晨，看到了很好看的天，马上拍下来，调出了一种 "你的名字" 的感觉。</p><p><a href="https://mp.weixin.qq.com/s/9NDb9Ez4JAwsYsPe-_Eyhg">Jayden的2021摄影集</a></p><p>再后来，到了12月，我借到了相机，这才算是我正式踏上了摄影的路，开始去考虑快门，ISO，光圈的搭配，也开始去尝试不同焦段下，拍到不同的照片，虽然还是拍的不咋地，不过审美相较于以往有了较大的进步。</p><p>寒假在家的日子，是没有相机的，但我又不能不出片吧，也罢，拿起手机去外面瞎拍，也许是整个二月都处于阴雨天吧，拍出来的照片的风格都不合我意，但还是选了一两张出来添加到摄影集里。</p><h4 id="跳出困局">跳出困局</h4><p>回到学校了，又借到相机了，拍没几天，新鲜感又过去了，校园的角角落落基本都走遍了，能拍的新事物，也所剩无几。既然一个人出不了什么好点子，那就找一群人。清明期间，我找了几个朋友外出闲逛，社牛一次去搭讪路人给她们拍照，这也算是人像摄影的启蒙吧 (虽然之后到现在也没拍过人像)。</p><p>我觉得我真正觉得自己摄影技术的提高，是在五一吧，去到了更远的地方，见到了更多的风景，去记录一些城市风光，当然，我也开始研究照片的后期技术，除了基本的曝光，对比度等，也开始去探索曲线对照片整体颜色走向，亮度的影响。</p><p>端午时期，我拿起相机，借了长焦，再次来到广州，依旧是那些熟悉的角落，不过在新的视角下，我也有了更深的体会。明明这条路，我走了很多遍，但我还依然走下去，并乐此不疲，或许是对这座城市的感情，我住在广州也有20年了，这里有我们的生活轨迹，也有属于我们这座城市的骄傲！</p><h4 id="哲与思">哲与思</h4><p>要说摄影给我带来了什么吧，其实开始我只是很沉浸在其中而已，并没有多想，真要我真的静下来想，emm……应该是一下这些吧</p><ul><li>一种记录生活的方式</li><li>对取景框里的主角的把握</li><li>对生活态度的改变</li><li>生活虽忙，但别忘了摄影</li><li>less is more</li></ul><p>在我没拿起相机的日子，我走在路上，也会用我心中的取景框去构图，像一只窥伺的猫，当我被某一瞬间的画面打动时，我会连忙倒退几步，伫立观望，然后再心满意足地继续上路。</p><p>这篇从开始构思，到下笔，再到结束，经历了好几个月。真的，摄影改变了我太多。我在街头无休止地穿梭，表面上看似在旁观生活，实则想作为一个体验者，寻求与某个事物在精神上的突然邂逅。</p><p>继续拍下去吧！</p>]]></content>
    
    
    <summary type="html">一些碎碎念, 浅聊我对摄影的看法和摄影对我的改变</summary>
    
    
    
    <category term="随笔" scheme="https://jaydenchang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://jaydenchang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>只是一期唠嗑</title>
    <link href="https://jaydenchang.top/post/0x002D.html"/>
    <id>https://jaydenchang.top/post/0x002D.html</id>
    <published>2022-03-10T16:00:00.000Z</published>
    <updated>2022-03-10T23:52:26.144Z</updated>
    
    <content type="html"><![CDATA[<p>断断续续记录一些自己的想法</p><h4 id="section">2.25</h4><p><strong>首先很感谢每位点进来并且看完的朋友，非常感谢你们抽出你们宝贵的时光听我扯皮、吹牛，在这个快节奏的时代，能静下来写一篇随笔、读一篇文章也是不容易。</strong></p><p>整个二月，几乎可以说是属于阴雨天的，从大年初一开始，到整个二月结束，阴雨不断，当然中间也出过几天晴天，而我也因为一些琐事，让我心情变得有些低落，有人说，天气会影响心情，我对此半信半疑。从大年初一开始，一连下了3天大雨，我的心情也是压抑的，终于在2月4日那天，出了太阳，我也有了外出取景的机会，拍了些照，和附近的小朋友打球，但我还是提不起精神，第二天，和Sam相约出去走走，与其说是走，其实更多时间花在了骑行上面，那天，花了俩小时骑行26km，夜间骑行，耳机里播放着R&amp;B歌曲，江岸沿途的灯柱，对岸大厦的广告牌，我放慢了步调，贪婪地享受这夜色，回到家后，整理今天所摄照片，心情好一些了。</p><p>估计是多巴胺分泌不太够吧，第二天，又回到了前几天的状态，身体的预警机制提醒我，学不进去，那总得找些事情做，那不如看书吧，于是我开始尝试每天睡醒看半小时书，睡前看半小时书。开始那几天，多少有些不习惯，心静不下来，总是想去看手机，后面索性直接把手机锁了，丢到沙发上，尝试了几天，貌似感觉还不错。</p><p>单单只是看书吧，总感觉少了点什么，我尝试开始写日记，每天写点东西，记录转瞬即逝的想法，顺便练练字。</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002D/0x002D_1.jpg' style="zoom: 30%;" ></p><p><img src='https://jaydenchang.gitee.io/images/images/0x002D/0x002D_2.jpg' style="zoom:33%;" ></p><center>字写的不太好，应该还能看得清写的啥吧 [狗头</center><h4 id="section-1">3.3</h4><p>写着发现好像跑题了，就是从过年后开始，我把我的睡前睡后的安排稍作调整，用来看书和复盘一天。这学期，从图书馆和好友那借了些书来看，首先看的是《追风筝的人》吧，在很早之前就有人推荐过我去看这本书，翻了几页，记录的是阿米尔的赎罪之旅，当阿米尔将索拉博带到美国，带着索拉博追风筝，索拉博渐渐打开心结，向着阿米尔微笑，而阿米尔此时也对着索拉博说着小时候哈桑经常对阿米尔说的话，"为你，千千万万遍"。</p><p>看完整本书吧，不由自主地想到了《肖申克的救赎》这本书(尽管我看的是电影的版本)，安迪在狱中服役了19年，也可以说是花了19年来救赎自己，在他即将越狱之时，他向瑞德提及了自己对妻子的爱与悔意。</p><p>"妻子说她很难了解我，我像一本合起来的书，她整天这样抱怨。她很漂亮，damn，我是多么爱她啊。我只是不擅表达。对，是我杀了她，枪不是我开的，但我害她离我远去，是我的脾气害死了她。"</p><p>这一段，我刷了好几遍，一直以为是安迪越狱前的某种仪式，到后面某天在外骑单车时，脑子里飘过一个想法，那一番对话，代表着安迪对自己的救赎，不是生命形式的救赎，不是生活方式上的救赎，而是灵魂层面上的救赎，在灵魂层面真正意义上的的自我重新认知。</p><p>同时也包括瑞德，前几次假释检验时，老老实实回答问题都被驳回，在第四十年，破罐子破摔，说出了自己在监狱四十年的感受，"我想对年轻的自己说……"，这一段，我同样也是看了好几遍，套路经不住灵魂的拷问，<strong>人可以通过模仿别人长大，但最终还是要用自己的语言面对这个世界</strong>。</p><p>再回到《追风筝的人》，阿米尔目睹哈桑被阿塞夫强暴而无动于衷，主要内心活动却是嫉妒父亲对哈桑的偏爱。移民美国后，阿米尔被羞愧自责的阴影所缠绕，他决定回阿富汗找哈桑。在解救索拉博时，面对阿塞夫的铁拳套，阿米尔没有退缩了，看到这里吧，阿米尔在赎罪的道路上已经跨出了一大半。</p><p>追完风筝，走进了围城，最近刚把《围城》看完，表面上吧，是写方鸿渐的早年经历，留学——求爱——婚姻，实际上，钱钟书刻画了三座围城，婚姻之城、事业之城，自我之城。这本书，看到后面，愈感觉讽刺性愈强，读完合上书那一刻，我心中在暗嘲那些像方鸿渐的人，但是反过来一想，自己身上也有方鸿渐的影子，芸芸众生，生活便是如此，围城之外又是一座围城。</p><h4 id="section-2">3.6</h4><p>最近无聊，翻了翻Instagram，原来我已经上传了这么多，因为一些特殊原因吧，我的Instagram没人关注，不过这样也好，可以在上面所心所欲发自己觉得拍的比较好看的照片，有时候甚至觉得Instagram的排版比国内的app还挺好看。</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002D/0x002D_3.jpg' style="zoom: 33%;" ></p><h4 id="section-3">3.7</h4><p>这几天晚上又因为一些琐事，晚上好久没看书了，有点懊悔自己断了这个习惯，不过每天在自己的小本本上记录的习惯却坚持了下来。最近又重新看了<span class="math inline">\(Sean\  Tucher\)</span>的视频，在练听力的过程中，我在刷评论区，看到了一段文字，让我内心深有感触</p><p>"过去的失败，给了我们一个倾听灵魂深处声音的机会，并且它促使我们去往一个平时绝对不会接触的地方"。</p><p><a href="https://www.bilibili.com/video/BV16t411S7jr">拥抱阴影——关于光线和人生的思考【Sean Tucker中字】_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/av28378168">保护你的高光 | 合理安排相机和人生中有限的动态范围「Sean Tucker中字」_哔哩哔哩_bilibili</a></p><p>这几天，我一直在看他之前的两期视频，有时想，我每天深夜emo真的有意义吗？第二天我查看我的储存卡，已经好几天没出新片了，想着，总得在校园里闲逛会，但是愈在意，产出就愈低。</p><p>我不得不找个阴暗的地方，翻看这学期新拍的照，噢！原来当时的我是这样构图的，原来当时的我是这样调参数的。那干脆，今天不拍了，走在风中，听听歌貌似也不错。</p><p>很感谢一位朋友(<span class="math inline">\(@Lucas\)</span>)推荐了<span class="math inline">\(Sean\ Tucker\)</span>给我，这位摄影师在哲学层面教会了我许多(当然你也可以认为我在扯淡)。</p><h4 id="section-4">3.10</h4><p>这几天在看书时，脑子里蹦出一句话，"有用是毒药，无用是解药"，这当时是一篇初中语文阅读题的标题。有时候我一直在想，什么是艺术，什么是文艺青年，我以前一直在想，我拿着相机到处走走拍拍，抱着本书读，这样就是文艺，这样就是文艺青年，显然，我只是青年，是伪文艺青年，自己还不配谈"文艺"。</p><p>文艺不应该是噱头，如果我能享受其中，那我就搞文艺这一套，读书摄影看电影，思考散步谈人生，做一些在别人眼里的为"无用"的事。别人再怎么嘲讽都没用，因为，这是我的生活方式。</p><p>或许吧，也不应该有"文艺青年"这个标签，<strong>安安静静做点自己想做的事，过点自己想过的生活</strong>，这也许是"文艺青年"最初的定义吧。</p>]]></content>
    
    
    <summary type="html">一些想法，当然你也可以认为我在扯淡</summary>
    
    
    
    <category term="随笔" scheme="https://jaydenchang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://jaydenchang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>cocos2d拖动组件吸附效果</title>
    <link href="https://jaydenchang.top/post/0x002C.html"/>
    <id>https://jaydenchang.top/post/0x002C.html</id>
    <published>2022-02-17T16:00:00.000Z</published>
    <updated>2022-03-02T10:51:46.841Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习制作小游戏，要实现一个拖动吸附效果，这里简单实现一下</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C-1.png' style="zoom:67%;" ></p><h4 id="代码实现">代码实现</h4><h5 id="定义节点和函数功能">定义节点和函数功能</h5><p>在<code>properties</code>里新建一个对象，用来接收目标区域的节点</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">properties:&#123;    sense: &#123;        defaule: null,        type: cc.Node,    &#125;&#125;</code></pre><p>然后在小车节点里绑定这个脚本，将要测试的目标节点拖动到属性检查器的<code>sense</code></p><p>这里用小车来表示要移动的组件，先在<code>onload()</code>内定义小车组件，设置位置，以及定义三个触摸事件函数</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">onload() &#123;    this.carPos &#x3D; cc.v2(0, 0);    &#x2F;&#x2F; 定义一个触摸移动控件    this.node.setPosition(this.carPos.x, this.carPos.y);    this.origin &#x3D; this.node.convertToWorldSpace(cc.v2(0, 0));    &#x2F;&#x2F; 获取小车移动前的坐标        &#x2F;&#x2F; 对当前节点设置位置    this.node.on(&quot;touchstart&quot;, this.touchStart, this);    this.node.on(&quot;touchmove&quot;, this.touchMove, this);    this.node.on(&quot;touchend&quot;, this.touchEnd, this);    &#x2F;&#x2F; 定义三个触摸事件函数&#125;</code></pre><p>然后就是对三个触摸事件定义</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">touchStart(event) &#123;    let touchPos &#x3D; event.getLocation();    &#x2F;&#x2F; 获取当前触摸位置    let posInNode &#x3D; this.worldConvertLocalPoint(this.node, touchPos);    &#x2F;&#x2F; 将当前触摸位置坐标转换为世界坐标    let target &#x3D; this.node.getContentSize();    &#x2F;&#x2F; 获得当前触摸组件的大小    let rect &#x3D; cc.rect(0, 0, target.width, target.height);    &#x2F;&#x2F; 对触摸对象组件创建一个矩形对象    if (rect.contains(posInNode)) &#123;        &#x2F;&#x2F; 判断触摸的位置是否在矩形内        this.touchTile &#x3D; this.node;        &#x2F;&#x2F; 获取被触摸的对象    &#125;    console.log(posInNode.x + &quot; &quot; + posInNode.y);    &#x2F;&#x2F; 测试，打印当前触摸位置&#125;,    touchMove(event) &#123;    if (this.touchTile) &#123;        this.touchTile.setPosition(this.touchTile.x + event.getDelta().x ,            this.touchTile.y + event.getDelta().y);        &#x2F;&#x2F; 根据小车组件移动距离重新给小车定位    &#125;&#125;,touchEnd(event) &#123;    let touchPos &#x3D; this.touchTile.convertToWorldSpaceAR(cc.v2(0, 0));    let posInNode &#x3D; this.worldConvertLocalPoint(this.sense1, touchPos);    let target &#x3D; this.sense1.getContentSize();    &#x2F;&#x2F; 定义坐标修正值    let correctValue &#x3D; cc.v2(this.sense.width &#x2F; 2  - this.origin.x - this.node.width &#x2F; 2, this.sense.height &#x2F; 2 - this.origin.y - this.node.height &#x2F; 2);    &#x2F;&#x2F; 获取要置放的区域的大小    let rect &#x3D; cc.rect(0, 0, target.width, target.height);    if (rect.contains(posInNode)) &#123;        &#x2F;&#x2F; 判断小车是否落在目标区域的矩形内        console.log(&quot;---endPos&quot;);        &#x2F;&#x2F; 设置触摸结束后小车的落位坐标        let targetPos &#x3D; this.sense1.convertToWorldSpace(cc.v2(correctValue));        &#x2F;&#x2F; 获取目标区域的中心坐标        let action &#x3D; cc.moveTo(0.3, targetPos);        &#x2F;&#x2F; 新建一个位移动作，动画持续时间为0.3s        this.touchTile.runAction(action);        &#x2F;&#x2F; 小车组件执行动作    &#125; else &#123;        console.log(&quot;----go back&quot;);        let action &#x3D; cc.moveTo(0.3, this.carPos);        &#x2F;&#x2F; 组件回到小车初始位置        this.touchTile.runAction(action);    &#125;    this.touchTile &#x3D; null;    &#x2F;&#x2F; 重置触摸组件为空&#125;,    worldConvertLocalPoint(node, worldPoint) &#123;    if (node) &#123;        return node.convertToNodeSpace(worldPoint);    &#125;    return null;&#125;</code></pre><h5 id="最终效果">最终效果</h5><p>拖入目标区域</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_drag_accept.gif' style="zoom:67%;" ></p><p>没拖到指定区域</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_drag_refuse.gif' style="zoom:67%;" ></p><h5 id="修正">修正</h5><p>这里要把小车放到目标区域的正中心，需要对坐标进行修正。在cocos creator里，有节点坐标和世界坐标这两个概念</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_xOy.png' style="zoom:67%;" ></p><p>而在属性检查器里，我们所设置的<code>position</code>，也就是锚点的位置，是相对于父节点的，例如图中我把<code>position</code>设为0和0，就是相对于父节点，该组件定位在父节点的几何中心。</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_xOy_detail.png' style="zoom:67%;" ></p><p>那么，哪些坐标值和最终放置的位置坐标有关联呢？</p><ul><li>小车初始坐标值</li><li>小车组件的长宽</li><li>目标区域的长宽</li></ul><p>在没有修正之前，把<code>targetPos</code>的值设为<code>this.sense.convertToWorldSpace(cc.v2(0, 0))</code>，拖动后的效果如下图</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_without_correct.gif' style="zoom:67%;" ></p><p>并且log打印目标位置的坐标，水平值离屏幕宽度一半还有一定的差距，这时我又打印了拖动结束后小车的坐标值，好家伙，我轻点小车没有拖动，控制台输出的坐标值为<code>(0,0)</code>，而图中很明显，小车的位置不在世界坐标的原点上，即此时小车的坐标参照点为小车的初始位置</p><p>那问题来了，怎么修正？</p><p>只需在<code>onload()</code>中定义一个变量储存小车的世界坐标值 <code>this.origin = this.node.convertToWorldSpace(cc.v2(0, 0))</code>，然后在<code>touchEnd()</code>中新定义一个向量值<code>correctValue</code>，新建一个向量<code>cc.v2(-this.origin.x, -this.origin.y)</code>，并返回给<code>correctValue</code>，再将<code>correctValue</code>转化为世界坐标赋给<code>targetPos</code>，此时小车会自动吸附到目标区域左下角，展现的效果如下</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_correct.gif' style="zoom:67%;" ></p><p>如果要把小车定位到目标区域的正中央，还需要考虑小车组件和目标区域的长宽，相应地，<code>correctValue</code>应该设为<code>cc.v2(this.sense.width / 2 - this.node.width / 2 - this.origin.x, this.sense.height / 2 - this.node.height / 2 - this.origin.y)</code></p><h4 id="参考链接">参考链接</h4><p><a href="https://blog.csdn.net/qq_45310244/article/details/113854722">(61条消息) CocosCreator的拖动小游戏主要逻辑_天才派大星 !的博客-CSDN博客_cocos creator 拖动</a></p>]]></content>
    
    
    <summary type="html">在Cocos2d中拖动组件并吸附到节点中央</summary>
    
    
    
    <category term="Cocos" scheme="https://jaydenchang.top/categories/Cocos/"/>
    
    
    <category term="JavaScript" scheme="https://jaydenchang.top/tags/JavaScript/"/>
    
    <category term="Cocos" scheme="https://jaydenchang.top/tags/Cocos/"/>
    
  </entry>
  
  <entry>
    <title>win10找回Ubuntu启动项(非EasyBCD)</title>
    <link href="https://jaydenchang.top/post/0x002B.html"/>
    <id>https://jaydenchang.top/post/0x002B.html</id>
    <published>2022-01-12T16:00:00.000Z</published>
    <updated>2022-01-13T04:04:41.513Z</updated>
    
    <content type="html"><![CDATA[<p>最近想对装在电脑上的Ubuntu进行更新，但是之前在BIOS里改了引导系统的文件，导致找不到Ubuntu启动项，EasyBCD程序也不起作用(整块硬盘Windows分区都是GPT，改BIOS也没什么用)，在必应上逛了两天找到了一个解决方法，在Windows下用命令行修改引导文件</p><p>打开管理员命令行(不是<u><strong>powershell</strong></u>)，输入以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mountvol g: &#x2F;sg:cd EFIbcdedit &#x2F;set &#123;bootmgr&#125; path \EFI\ubuntu\grubx64.efi</code></pre><p>这时候重启，开机就会进入grub菜单</p><p>如果想改回Windows引导，则最后一行命令改为</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bcdedit &#x2F;set &#123;bootmgr&#125; path \EFI\Microsoft\Boot\bootmgfw.efi</code></pre><h4 id="参考链接">参考链接</h4><p><a href="https://linux.cn/article-4667-1.html">桌面应用|Windows和Ubuntu双系统，修复UEFI引导的两种办法 (linux.cn)</a></p>]]></content>
    
    
    <summary type="html">不进入BIOS的情况下找回Ubuntu启动项</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="Linux" scheme="https://jaydenchang.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>不关闭SELinux情况下使用ftp传输</title>
    <link href="https://jaydenchang.top/post/0x002A.html"/>
    <id>https://jaydenchang.top/post/0x002A.html</id>
    <published>2022-01-03T16:00:00.000Z</published>
    <updated>2022-01-03T08:43:52.196Z</updated>
    
    <content type="html"><![CDATA[<p>在做搭建ftp服务器的作业时，整了一个活，在不关闭SELinux的情况下测试ftp服务器</p><p>使用的环境，虚拟机*2 (CentOS 7)，Hyper-v，网卡已设为静态</p><p>需要安装的软件包：</p><ul><li><p>服务器(下称server)：</p><ul><li><p>vsftpd</p></li><li><p>ftp</p></li><li><p>ip可自定义，此处设为192.168.4.5</p></li></ul></li><li><p>客户机(下称client)：</p><ul><li><p>ftp</p></li><li><p>ip这里设为192.168.4.205</p></li></ul></li></ul><h4 id="修改vsftpd配置">修改vsftpd配置</h4><p>进入目录<code>/etc/vsftpd</code>，编辑<code>vsftpd.conf</code>，在最后一行添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">listen_port&#x3D;21</code></pre><h4 id="防火墙添加信任">防火墙添加信任</h4><p>然后在防火墙里允许特定ip访问特定端口(作业里要访问的ip是<code>192.168.4.205</code>)</p><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --permanent --add-rich-rule&#x3D;&quot;rule family&#x3D;&quot;ipv4&quot; source address&#x3D;&quot;192.168.4.205&quot; port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;21&quot; accept&quot;</code></pre><p>向客户机开放21端口</p><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --reload</code></pre><p>重新载入防火墙</p><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --zone&#x3D;public --list-rich-rules</code></pre><p>查看开放的端口</p><p>如果显示防火墙未启动，可以运行命令启动防火墙</p><pre class="line-numbers language-none"><code class="language-none">systemctl start firewalld</code></pre><h4 id="客户机测试">客户机测试</h4><p>连接服务器</p><pre class="line-numbers language-none"><code class="language-none">ftp 192.168.4.5</code></pre><p>当显示<code>ftp&gt;</code>时，输入<code>ls</code>或者<code>pwd</code>查看当前位置时，又出现了一个bug，显示<code>no route to host</code>，</p><p>这时候再回到服务器，修改<code>/etc/sysconfig/</code>下的<code>iptables-config</code>，更改其中<code>IPTABLES_MODULES=""</code>项为</p><pre class="line-numbers language-none"><code class="language-none">IPTABLES_MODULES&#x3D;&quot;ip_nat_ftp ip_conntrack_ftp&quot;</code></pre><p>然后重启防火墙相关服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart iptables.service</code></pre><p>如果服务器重启后，客户机ftp连接服务器还出现<code>no route to host</code>的情况，以此输入以下命令开启相关防火墙服务</p><pre class="line-numbers language-none"><code class="language-none">systemctl start firewalldsystemctl start iptables.service</code></pre><p>如果仅是临时使用，可以运行以下两条命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">modprobe ip_nat_ftpmodprobe ip_conntrack_ftp</code></pre><h4 id="参考链接">参考链接</h4><p><a href="https://blog.csdn.net/u012906135/article/details/69944485">ftp connect: No route to host 解决方案_hello world!-CSDN博客</a></p><p><a href="https://www.jianshu.com/p/4801d9dbaa84">Linux防火墙firewall只允许特定ip访问 - 简书 (jianshu.com)</a></p>]]></content>
    
    
    <summary type="html">两台Linux服务器不关闭SELinux进行ftp传输</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="Linux" scheme="https://jaydenchang.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-图及最小生成树</title>
    <link href="https://jaydenchang.top/post/0x0029.html"/>
    <id>https://jaydenchang.top/post/0x0029.html</id>
    <published>2021-12-08T16:00:00.000Z</published>
    <updated>2021-12-11T06:08:25.654Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更了 <del>其实摸鱼摸太久了</del>，当然也是最近太多事，一直没有时间去打理博客，趁着周末有空，来整理下图部分的内容</p><p>这里来总结下无向图、最小生成树(prim和Dijkstra)算法</p><h4 id="无向图">无向图</h4><h5 id="结构">结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 到后面发现，visited在无向图中设计的是真的巧妙template &lt;class DataType&gt;class MGraph &#123;    public:      MGraph(DataType a[], int n, int e); &#x2F;&#x2F; 构造函数，构造有n个顶点e条边的图     ~MGraph() &#123;&#125;     void DFS(int); &#x2F;&#x2F; 深搜     void BFS(int); &#x2F;&#x2F; 广搜        private:     DataType vertex[maxSize]; &#x2F;&#x2F; 存放图中顶点的数组     int edge[maxSize][maxSize]; &#x2F;&#x2F; 存放图中边的数组     int vertexNum, edgeNum; &#x2F;&#x2F; 图中的顶点数和变数&#125;;</code></pre><h5 id="构造函数">构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, k;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i]; &#x2F;&#x2F; 储存顶点    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            edge[i][j] &#x3D; 0; &#x2F;&#x2F; 初始化邻接矩阵        &#125;    &#125;    for (k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cin &gt;&gt; i &gt;&gt; j; &#x2F;&#x2F; 以此输入每条边依附的两个顶点的编号        edge[i][j] &#x3D; 1; &#x2F;&#x2F; 对输入的边做标记(无向图，双向标记)        edge[j][i] &#x3D; 1;    &#125;&#125;</code></pre><h5 id="广搜和深搜">广搜和深搜</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;        if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0)             DFS(j);        &#x2F;&#x2F; 递归的妙处会在后面讲到    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int w, j, queue[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; queue数组记录的是访问矩阵第几行的顺序    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        visited[i] &#x3D; 0;    &#125;    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="主函数">主函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;;    MGraph&lt;char&gt; MG(ch, 6, 6);    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS order: \n&quot;;    MG.DFS(0);    cout &lt;&lt; &quot;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;;    cout &lt;&lt; &quot;BFS order: \n&quot;;    MG.BFS(0);&#125;</code></pre><h5 id="测试用例及其邻接矩阵">测试用例及其邻接矩阵</h5><p>测试数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0 10 20 51 21 43 4</code></pre><p>邻接矩阵</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0 1 2 3 4 5 0&#39;   1 1     1 &#39;1&#39; 1   1   1   &#39;2&#39; 1 1         &#39;3&#39;         1   &#39;4&#39;   1   1     &#39; 5&#39; 1           &#39;&#x2F;&#x2F; 以横轴为x，竖轴为y       </code></pre><p>借用这个样例来说一下深搜和广搜</p><h6 id="深搜">深搜</h6><p>已知无向图的邻接矩阵是关于对角线对称的，深搜从第一行开始搜索，搜索到<code>(1,0)</code>时进入递归，进入递归后，首先对<code>visited[v]</code>进行标记，通过观察可以知道，上一轮DFS传入的j和下一轮DFS的v在矩阵中关于对角线对称 <del>好像是个无用信息</del>，每一轮DFS的<code>visited[v]=1</code>就是为了避免重复访问<code>vertex[v]</code>，再加上那条if语句的配合，即可无重复遍历完整个图</p><h6 id="广搜">广搜</h6><p>广搜的话其实还是要自己画出一个无向图来并且在debug模式运行一遍才知道大概是怎么个流程。对上面的测试用例来说，在第一轮搜索时，访问的都是和0号这个点有通路的点，第二轮是1号，第三轮是2号，依此类推。如果把最开始输入的0号放在中间，后面输入的数据一圈圈和0号联通，产生关联，那么广搜可以理解为，从搜寻点一圈圈向外扩散找</p><h5 id="完整代码">完整代码</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;class MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);        private:     int vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, k;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            edge[i][j] &#x3D; 0;        &#125;    &#125;    for (k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cin &gt;&gt; i &gt;&gt; j;        edge[i][j] &#x3D; 1;        edge[j][i] &#x3D; 1;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;        if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0)            DFS(j);    &#125;&#125;template &lt;class DateType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int w, j, queue[maxSize] &#x3D; &#123;0&#125;;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        visited[i] &#x3D; 0;    &#125;    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;;    int i;    MGraph&lt;char&gt; MG(ch, 6, 6);    for (i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS order: \n&quot;;    MG.DFS(0);    cout &lt;&lt; &quot;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;;    cout &lt;&lt; &quot;BFS order: \n&quot;;    MG.BFS(0);&#125;</code></pre><h4 id="prim">prim</h4><h5 id="结构-1">结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;class MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);     void Prim(int);     int minEdge(int[], int);        private:     DataType vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;</code></pre><h5 id="构造函数-1">构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, w &#x3D; 0;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                 edge[i][j] &#x3D; 0; &#x2F;&#x2F; 这里忽略自环            else                edge[i][j] &#x3D; 100;            &#x2F;&#x2F; 这里初始化权值，赋比较大的数即可        &#125;    &#125;    for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cout &lt;&lt; &quot;input two points of the edge: &quot;;        cin &gt;&gt; i &gt;&gt; j;        cout &lt;&lt; &quot;input the weight of the edge: &quot; ;        cin &gt;&gt; w;        edge[i][j] &#x3D; w;        edge[j][i] &#x3D; w;    &#125;&#125;</code></pre><h5 id="prim代码实现">prim代码实现</h5><p>将图中顶点（V）分两部分，最小生成树的点集为U，其余顶点在集合（V-U）</p><ul><li><ol type="1"><li>首先任取一个点作为起点</li></ol></li><li><ol start="2" type="1"><li>在V-U中找和起点之间权值最小的边</li></ol></li><li><ol start="3" type="1"><li>adjVex记录上一轮找最小值的位置，cost记录到各顶点的距离</li></ol></li><li><ol start="4" type="1"><li>然后上一轮找到的权值最小的边的另一个点作为起点，不断重复步骤2，3</li></ol></li></ul><h6 id="找到最小值位置">找到最小值位置</h6><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;int MGraph&lt;DataType&gt;::minEdge(int r[], int n) &#123;    int index;    int min &#x3D; 100; &#x2F;&#x2F; 图中all权值最大不超过100    for (int i &#x3D; 0; i &lt; n; i++) &#123;        if (r[i] !&#x3D; 0 &amp;&amp; r[i] &lt; min) &#123;            min &#x3D; r[i];            index &#x3D; i;        &#125;    &#125;    return index; &#x2F;&#x2F; 返回最小值在数组中的位置&#125;</code></pre><h6 id="prim核心代码">prim核心代码</h6><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Prim(int v) &#123;    int adjVex[maxSize], cost[maxSize];    int i, j, k;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        &#x2F;&#x2F; 通过起点对adjVex，cost数组初始化        cost[i] &#x3D; edge[v][i];        adjVex[i] &#x3D; v;        &#x2F;&#x2F; 将起点所有有联通的点都录入cost中，找权值最小的边(类似BFS)    &#125;    cost[v] &#x3D; 0; &#x2F;&#x2F; 将顶点加入u中    for (k &#x3D; 1; k &lt; vertexNum; k++) &#123;        j &#x3D; minEdge(cost, vertexNum); &#x2F;&#x2F; 在cost数组找最小值        &#x2F;&#x2F; cout &lt;&lt; &#39;(&#39; &lt;&lt; adjVex[j] &lt;&lt; &#39;,&#39; &lt;&lt; j &lt;&lt; &#39;)&#39; &lt;&lt; cost[j] &lt;&lt; endl; &#x2F;&#x2F; 输出的是点的序号        cout &lt;&lt; &#39;(&#39; &lt;&lt; vertex[j] &lt;&lt; &#39;,&#39; &lt;&lt; vertex[adjVex[j]] &lt;&lt; &#39;)&#39; &lt;&lt; cost[j] &lt;&lt; endl;  &#x2F;&#x2F; 输出的是字符        &#x2F;&#x2F; 输出生成最小生成树的过程(都是输出上一轮查找结果)        cost[j] &#x3D; 0; &#x2F;&#x2F; 将最小值的点加入U中(清零当前最小值的权值，防止后面重复遍历)        for (int p &#x3D; 0; p &lt; vertexNum; p++) &#123;            &#x2F;&#x2F; 这一步，是以第j号为起点，不断寻找和j号联通的最小权值的路线            if (edge[p][j] &lt; cost[p]) &#123;                &#x2F;&#x2F; 从所有与当前最小值临界点出发找到最小值点权值最小的                cost[p] &#x3D; edge[p][j];                adjVex[p] &#x3D; j; &#x2F;&#x2F; 记录新加入顶点上一轮迭代的最小值的位置            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="测试用例及邻接矩阵">测试用例及邻接矩阵</h5><pre class="line-numbers language-none"><code class="language-none">0 1340 2460 5191 4122 3172 5253 4383 5254 526</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0  1  2  3  4  5 0&#39;    34 46       19 &#39;1&#39; 34          12    &#39;2&#39; 46       17    25 &#39;3&#39;       17    38    &#39;4&#39;    12    38    26 &#39; 5&#39; 19    25    26    &#39;&#x2F;&#x2F; 以横轴为x，竖轴为y       </code></pre><h4 id="dijkstra">Dijkstra</h4><h5 id="结构-2">结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 到后面发现，visited在无向图中设计的是真的巧妙template &lt;class DataType&gt;class MGraph &#123;    public:      MGraph(DataType a[], int n, int e); &#x2F;&#x2F; 构造函数，构造有n个顶点e条边的图     ~MGraph() &#123;&#125;     void DFS(int); &#x2F;&#x2F; 深搜     void BFS(int); &#x2F;&#x2F; 广搜        private:     DataType vertex[maxSize]; &#x2F;&#x2F; 存放图中顶点的数组     int edge[maxSize][maxSize]; &#x2F;&#x2F; 存放图中边的数组     int vertexNum, edgeNum; &#x2F;&#x2F; 图中的顶点数和变数&#125;;</code></pre><h5 id="构造函数-2">构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    vertexNum &#x3D; e, edgeNum &#x3D; n;    int i, j, w &#x3D; 0;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                 edge[i][j] &#x3D; 0;            else                edge[i][j] &#x3D; 100;        &#125;        for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;            cout &lt;&lt; &quot;input two vertexes of the edge: &quot;;            cin &gt;&gt; i &gt;&gt; j;            cout &lt;&lt; &quot;input the weight of the edge: &quot;;            cin &gt;&gt; w;            edge[i][j] &#x3D; w;        &#125;    &#125;&#125;</code></pre><h5 id="深搜和广搜">深搜和广搜</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        if (edge[v][i] &lt; 100 &amp;&amp; visited[i] &#x3D;&#x3D; 0)             DFS(i);    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int queue[maxSize];    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &lt; 100 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[v];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; 1;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="dijkstra-1">Dijkstra</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Dijkstra(MGraph&lt;DataType&gt; mg, int v) &#123;    int dist[maxSize];    &#x2F;&#x2F; dist为起点到各个点的距离，具有临时性    string path[maxSize];    string vertex(mg.vertex);    for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;        dist[i] &#x3D; mg.edge[v][i];        &#x2F;&#x2F; 初始化dist数组，0号顶点到其余各顶点的初始路程        if (dist[i] !&#x3D; 100) &#123;            path[i] +&#x3D; vertex[v];            path[i] +&#x3D; vertex[i];            &#x2F;&#x2F; 这里是记录起点可以直达的路径        &#125; else &#123;            path[i] &#x3D; &quot;&quot;;        &#125;    &#125;    dist[v] &#x3D; 0;    int num &#x3D; 1;    while (num &lt; mg.vertexNum) &#123;        int min &#x3D; 255, k &#x3D; 0; &#x2F;&#x2F; 每一轮重置最小值        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (dist[i] !&#x3D; 0 &amp;&amp; dist[i] &lt; min) &#123;                min &#x3D; dist[i];                k &#x3D; i;                &#x2F;&#x2F; 找最小值            &#125;        &#125;        &#x2F;&#x2F; cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; dist[k] &lt;&lt; &quot;;\n&quot;;        num++; &#x2F;&#x2F; 标记这是第几个被访问的点        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (dist[i] &gt; dist[k] + mg.edge[k][i]) &#123;                dist[i] &#x3D; dist[k] + mg.edge[k][i];                path[i] &#x3D; &quot;&quot;; &#x2F;&#x2F; 重置路径                path[i] +&#x3D; path[k]; &#x2F;&#x2F; 加上之前走过的路                path[i] +&#x3D; vertex[i];            &#125;        &#125;        cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; dist[k] &lt;&lt; &quot;;\n&quot;;        dist[k] &#x3D; 0;    &#125;&#125;</code></pre><h5 id="测试用例及邻接矩阵-1">测试用例及邻接矩阵</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0 1100 3300 41001 2502 4103 2203 460</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0   1   2   3   40          1&#39; 10                 &#39;2&#39;     50      20     &#39;3&#39; 30                 &#39;4&#39; 100     10  60     &#39;&#x2F;&#x2F; 横轴为x，竖轴为y       </code></pre><h5 id="完整代码-1">完整代码</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;struct MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);     void Dijkstra(MGraph&lt;DataType&gt;, int);        private:     DataType vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, w &#x3D; 0;    vertexNum &#x3D; n, edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                edge[i][j] &#x3D; 0;            else                edge[i][j] &#x3D; 100;        &#125;    &#125;    for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cout &lt;&lt; &quot;input two vertexes of the edge: &quot;;        cin &gt;&gt; i &gt;&gt; j;        cout &lt;&lt; &quot;input the weight of the edge: &quot;;        cin &gt;&gt; w;        edge[i][j] &#x3D; w;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        if (edge[v][i] &lt; 100 &amp;&amp; visited[i] &#x3D;&#x3D; 0)            DFS(i);    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int queue[maxSize];    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &lt; 100 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Dijkstra(MGraph&lt;DataType&gt; mg, int v) &#123;    int distance[maxSize];    string path[maxSize];    string vertex(mg.vertex);    for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;        distance[i] &#x3D; mg.edge[v][i];        if (dist[i] !&#x3D; 100) &#123;            path[i] +&#x3D; vertex[v];            path[i] +&#x3D; vertex[i];        &#125; else &#123;            path[i] &#x3D; &quot;&quot;;        &#125;    &#125;    distance[v] &#x3D; 0;    int num &#x3D; 1;    while (num &lt; mg.vertexNum) &#123;        int min &#x3D; 100, k &#x3D; 0;        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (distance[i] !&#x3D; 0 &amp;&amp; distance[i] &lt; min) &#123;                min &#x3D; distance[i];                k &#x3D; i;            &#125;        &#125;        num++;        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (distance[i] &gt; distance[k] + mg.edge[v][i]) &#123;                distance[i] &#x3D; distance[i] + mg.edge[k][i];                path[i] &#x3D; &quot;&quot;;                path[i] +&#x3D; path[k];                path[i] +&#x3D; vertex[i];            &#125;        &#125;        cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; distance[k] &lt;&lt; &quot;;\n&quot;;        distance[k] &#x3D; 0;    &#125;&#125;int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;&#125;;    MGraph&lt;char&gt; mg(ch, 5, 7);    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS: &quot;;    mg.DFS(0);    cout &lt;&lt; endl;    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;BFS: &quot;;    mg.BFS(0);    cout &lt;&lt; &quot;the short path: \n&quot;;    mg.Dijkstra(mg, 0);&#125;</code></pre><h4 id="参考链接">参考链接</h4><p><a href="https://blog.csdn.net/zgsdlr/article/details/121426826">【数据结构】最小生成树Prim算法_zgsdlr的博客-CSDN博客_ java求最小生成树</a></p>]]></content>
    
    
    <summary type="html">填坑系列之图，整理了数据结构无向图、最小生成树(Prim和Dijkstra)</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--哈夫曼树与哈夫曼编码</title>
    <link href="https://jaydenchang.top/post/0x0028.html"/>
    <id>https://jaydenchang.top/post/0x0028.html</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2021-12-11T10:14:34.545Z</updated>
    
    <content type="html"><![CDATA[<p>填坑系列之哈夫曼树</p><p>刚开始看哈夫曼树时有点懵懵的，加权是啥子玩意，后面查阅资料后才明白，哈夫曼树以及哈夫曼编码多用在压缩编码中，再配合二倍速食用B站大学的网课，算是把整个算法过了一遍</p><h4 id="the-main-structure">the main structure</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int Max &#x3D; 1000;char **HuffmanCode;typedef struct Node &#123;    int weight;    int parent, left, right;&#125; HTNode, *HuffmanTree;</code></pre><h4 id="select">Select</h4><p>select是来选择剩余结点中权值最小的两颗二叉树(包括新构造的树)的左右子树来构建一个新的二叉树，新根节点权值为其左右子树根节点的权值之和</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Select(HuffmanTree ht, int k, int&amp; id1, int&amp; id2) &#123;    long min1, min2;    min1 &#x3D; min2 &#x3D; 99999; &#x2F;&#x2F; 不能太小    for (int i &#x3D; 0;i &lt; k;i++) &#123;        if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min1 &gt; ht[i].weight) &#123;            &#x2F;&#x2F; 选择无双亲的结点            if (min1 &lt; min2) &#123;                 &#x2F;&#x2F; 这里是比大小的操作，规定min1为小                min2 &#x3D; min1;                id2 &#x3D; id1;            &#125;            min1 &#x3D; ht[i].weight; &#x2F;&#x2F; 这个操作可以把这k个数据都遍历一遍，可以选出两个最小的结点            id1 &#x3D; i;        &#125; else if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min2 &gt; ht[i].weight) &#123;            min2 &#x3D; ht[i].weight;            id2 &#x3D; i;        &#125;    &#125;&#125;</code></pre><h4 id="create-a-huffman-tree">Create a Huffman Tree</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HuffmanTree(huffTree &amp;ht, int n) &#123;    int m &#x3D; n * 2 - 1;    int id1, id2;    int i;    if (n &lt; 0) &#x2F;&#x2F; 创建空树        return;    ht &#x3D; new Node[m];    for (i &#x3D; 0;i &lt; m;i++) &#123;        ht[i].parent &#x3D; ht[i].left &#x3D; ht[i].right &#x3D; -1;        &#x2F;&#x2F; 初始化各节点    &#125;    for (i &#x3D; 0;i &lt; n;i++) &#123;        cin &gt;&gt; ht[i].weight; &#x2F;&#x2F; 输入各个结点的权值    &#125;    for (i &#x3D; n;i &lt; m;i++) &#123;        Select(ht, i, id1, id2);        &#x2F;&#x2F; 在n个结点中选择俩无双亲的结点且权值最小的结点        ht[id1].parent &#x3D; ht[id2].parent &#x3D; i;        &#x2F;&#x2F; 获得id1，id2，把第i个结点设为它俩的双亲        ht[i].left &#x3D; id1;        ht[i].right &#x3D; id2; &#x2F;&#x2F; 设第i个结点的左右孩子为id1，id2        ht[i].weight &#x3D; ht[id1].weight + ht[id2].weight;    &#125;&#125;</code></pre><h4 id="destroy-a-huffman-tree">destroy a Huffman Tree</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Destroy(HuffmanTree &amp;ht) &#123;    delete[] ht;    ht &#x3D; NULL;&#125;</code></pre><h4 id="create-the-huffman-code">create the Huffman Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void createHuffmanCode(HuffmanTree ht, HuffmanCode &amp;hc, int n) &#123;    int start;    int cur, f;    hc &#x3D; new char *[n + 1];    char *cd &#x3D; new char[n];    cd[n - 1] &#x3D; &#39;\0&#39;;    for (i &#x3D; 0;i &lt; n;i++) &#123;        start &#x3D; n - 1;         cur &#x3D; i; &#x2F;&#x2F; 当前结点在数组中的位置        f &#x3D; hf[i].parent; &#x2F;&#x2F; 当前结点的父节点在数组的位置        while (f !&#x3D; 0) &#123;            &#x2F;&#x2F; 如果该结点是父节点的左孩子则对应编码为0，否则右孩子为1            start--;            if (hf[f].left &#x3D;&#x3D; cur)                cd[start] &#x3D; &#39;0&#39;;            else                 cd[start] &#x3D; &#39;1&#39;;            &#x2F;&#x2F; 以父节点为孩子结点，继续朝树根的方向遍历            cur &#x3D; f;            f &#x3D; hf[f].parent;        &#125;        &#x2F;&#x2F; 跳出循环后，cd数组中从下标start开始，存放的就是该结点的哈夫曼编码        hc[i] &#x3D; new char[n - start];        strcpy(hc[i], &amp;cd[start]);    &#125;    delete cd;&#125;</code></pre><h4 id="the-code">the code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int Max &#x3D; 9999;typedef char **HuffmanCode;typedef struct Node &#123;    int weight;    int parent, left, right;&#125; HTNode, *HuffmanTree;void Select(HuffmanTree ht, int k, int id1, int id2) &#123;    int min1 &#x3D; min2 &#x3D; 9999;for (int i &#x3D; 0;i &lt; k;i++) &#123;        if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min1 &lt; ht[i].weight) &#123;            if (min1 &lt; min2) &#123;                min2 &#x3D; min1;                id2 &#x3D; id1;            &#125;            id1 &#x3D; i;            min1 &#x3D; ht[i].weight;        &#125; else if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min2 &gt; ht[i].weight) &#123;            min2 &#x3D; ht[i].weight;            id2 &#x3D; i;        &#125;    &#125;&#125;void createHuffmanTree(HuffmanTree ht, int n) &#123;    int id1, id2;    if (n &lt;&#x3D; 0)         return;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        ht[i].left &#x3D; ht[i].right &#x3D; ht[i].parent &#x3D; 0;    &#125;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        cin &gt;&gt; ht[i].weight;    &#125;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        Select(ht, i, id1, id2);        ht[id1].parent &#x3D; ht[id2].parent &#x3D; i;        ht[i].left &#x3D; id1;        ht[i].right &#x3D; id2;        ht[weight] &#x3D; ht[id1].weight + ht[id2].weight;    &#125;&#125;void createHuffmanTreeCode(HuffmanTree ht, HuffmanCode &amp;hc, int n) &#123;    int start, cur f;    hc &#x3D; new char*[n + 1];    char* cd &#x3D; new char[n];    cd[n - 1] &#x3D; &#39;\0&#39;;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        start &#x3D; n - 1;        cur &#x3D; i;        f &#x3D; ht[i].parent;        while (f !&#x3D; 0) &#123;            start--;            if (ht[f].left &#x3D;&#x3D; cur) &#123;                cd[start] &#x3D; &#39;0&#39;;            &#125; else &#123;                cd[start] &#x3D; &#39;1&#39;;            &#125;            cur &#x3D; f;            f &#x3D; ht[i].parent;        &#125;        hc[i] &#x3D; cd[n - start];        strcpy(hc[i], &amp;cd[start]);    &#125;    delete cd;&#125;int main() &#123;    int n;    cin &gt;&gt; n;    HuffmanTree ht;    HuffmanCode hc;    int sum &#x3D; 0;    HuffmanTree(ht, n);    createHuffmanCode(ht, hc, n);    for (int i &#x3D; 0;i &lt; 2 * n - 1;i++) &#123;        cout &lt;&lt; ht[i].weight &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 测试，输出所有结点，包括非原有结点    &#125;    cout &lt;&lt; endl;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        cout &lt;&lt; hc[i] &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 输出每个结点的HuffmanCode    &#125;&#125;</code></pre><h4 id="参考链接">参考链接</h4><p><a href="https://www.cnblogs.com/linfangnan/p/12593480.html">数据结构：哈夫曼树与哈夫曼编码 - 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p><p><a href="https://www.bilibili.com/video/BV18t411U7Tb">数据结构与算法基础--第09周04--5.7哈夫曼树及其应用4-5.7.2哈夫曼树的构造算法2-哈夫曼树算法实现_哔哩哔哩_bilibili</a>(共6p)</p>]]></content>
    
    
    <summary type="html">填坑系列之哈夫曼树，整理了哈夫曼树和哈夫曼编码</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--简单二叉树(无序)</title>
    <link href="https://jaydenchang.top/post/0x0027.html"/>
    <id>https://jaydenchang.top/post/0x0027.html</id>
    <published>2021-11-15T16:00:00.000Z</published>
    <updated>2021-12-11T05:45:42.062Z</updated>
    
    <content type="html"><![CDATA[<p>本次来简单总结下简单二叉树(无序)，前面欠的债有点多，最近在疯狂追赶课程进度，简单记录下自己对简单二叉树的一些理解</p><h4 id="binary-tree">binary tree</h4><h5 id="the-main-structure">the main structure</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int Max &#x3D; 100;template &lt;class DataType&gt;struct BiNode &#123;    DataType data;    BiNode *leftChild, *rightChild;    &#125;;template &lt;class DataType&gt;class BiTree &#123;    public:     BiTree() &#123; root &#x3D; Create(); &#125;     ~BiTree() &#123; Release(root); &#125;     void PreOrder() &#123; PreOrder(root); &#125;     void InOrder() &#123; InOrder(root); &#125;     void LevelOrder();     int leafNum(BiNode*);     BiNode* getRoot() &#123; return root; &#125;        private:     BiNode* root;     BiNode* Create();     void Release(BiNode* bt);     void PreOrder(BiNode* bt);     void InOrder(BiNode* bt);     void PostOrder(BiNode* bt);&#125;;</code></pre><h5 id="create">Create()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;BiTree::BiTree() &#123;    BiNode* bt;    DataType ch;    cout &lt;&lt; &quot;enter a binary node: &quot;;    cin &gt;&gt; ch;    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;        return NULL;    &#125; else &#123;        bt &#x3D; new BiNode;        bt-&gt;data &#x3D; ch;        bt-&gt;leftChild &#x3D; Create();        bt-&gt;rightchild &#x3D; Create();        &#x2F;&#x2F; 不断套娃递归    &#125;&#125;</code></pre><h5 id="release">Release()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;BiTree::Release(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        Release(bt-&gt;leftChild);        Release(bt-&gt;rightChild);        delete bt;    &#125;&#125;</code></pre><h5 id="preorder">PreOrder</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::PreOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        PreOrder(bt-&gt;leftChild);        PreOrder(bt-&gt;rightChild);    &#125;&#125;</code></pre><h5 id="inorder">InOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::InOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        InOrder(bt-&gt;leftChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        InOrder(bt-&gt;rightChild);    &#125;&#125;</code></pre><h5 id="postorder">PostOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::PostOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        PostOrder(bt-&gt;leftChild);        PostOrder(bt-&gt;rightChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;    &#125;&#125;</code></pre><h5 id="levelorder">LevelOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::LevelOrder() &#123;    BiNode *queue[Max], *ptr &#x3D; NULL;    int front &#x3D; -1, rear &#x3D; -1;    if (root &#x3D;&#x3D; NULL)         return;        queue[++rear] &#x3D; root; &#x2F;&#x2F; 根节点入队    while (front !&#x3D; rear) &#123;        ptr &#x3D; queue[++front]; &#x2F;&#x2F; 把根节点赋给临时指针ptr        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 输出当前结点的内容               if (ptr-&gt;leftChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;leftChild;        if (ptr-&gt;rightChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;rightChild;        &#x2F;&#x2F; 这里依次遍历左右左右孩子节点并添加入列    &#125;&#125;</code></pre><h5 id="leafnum">leafNum()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;int BiTree::leafNum(BiNode* bt)&#123;    if (bt &#x3D;&#x3D; NULL)        return 0;    if (bt-&gt;leftChild &#x3D;&#x3D; NULL &amp;&amp; bt-&gt;rightChild &#x3D;&#x3D; NULL)         return 1;    int left &#x3D; leafNum(bt-&gt;leftChild);    int right &#x3D; leafNum(bt-&gt;rightChild);    return left + right;&#125;</code></pre><h5 id="complete-code">Complete code</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int Max &#x3D; 100;template &lt;class DataType&gt;struct BiNode &#123;    DataType data;    BiNode *leftChild, *rightChild;&#125;;template &lt;class DataType&gt;class BiTree &#123;    public:     BiTree() &#123; root &#x3D; Create(); &#125;     ~BiTree() &#123;Release(root); &#125;     void PreOrder() &#123; PreOrder(root); &#125;     void InOrder() &#123; InOrder(root); &#125;     void PostOrder() &#123; PostOrder(root); &#125;     void LevelOrder();     int leafNum(BiNode*);     BiNode* getRoot() &#123; return root; &#125;        private:     BiNode* root;     BiNode* Create();     void Release(BiNode*);     void PreOrder(BiNode*);     void InOrder(BiNode*);     void PostOrder(BiNode*);&#125;;template &lt;class DataType&gt;BiNode* BiTree::Create() &#123;    BiNode* bt;    DataType ch;    cout &lt;&lt; &quot;enter a node data: &quot;;    cin &gt;&gt; ch;    if (ch !&#x3D; &#39;#&#39;) &#123;        bt-&gt;data &#x3D; ch;        bt-&gt;leftChild &#x3D; Create();        bt-&gt;rightChild &#x3D; Create();        return bt;    &#125;&#125;template &lt;class DataType&gt;void BiTree::Release(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        Release(bt-&gt;leftChild);        Release(bt-&gt;rightChild);        delete bt;    &#125;&#125;template &lt;class DataType&gt;void BiTree::PreOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        PreOrder(bt-&gt;leftChild);        PreOrder(bt-&gt;rightChild);    &#125;&#125;template &lt;class DataType&gt;void BiTree::InOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        InOrder(bt-&gt;leftChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        InOrder(bt-&gt;rightChild);    &#125;&#125;template &lt;class DataType&gt;void BiTree::PostOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        PostOrder(bt-&gt;leftChild);        PostOrder(bt-&gt;rightChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;    &#125;&#125;template &lt;class DataType&gt;void BiTree::LevelOrder() &#123;    BiNode* queue[Max], ptr &#x3D; NULL;    int front &#x3D; -1, rear &#x3D; -1;    if (root &#x3D;&#x3D; NULL)        return;queue[++rear] &#x3D; root;    while (front !&#x3D; rear) &#123;        ptr &#x3D; queue[++front];        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;;        if (ptr-&gt;leftChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;leftChild;        if (ptr-&gt;rightChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;rightChild;    &#125;&#125;template &lt;class DataType&gt;int BiTree::leafNum(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL)        return 0;    if (bt-&gt;leftChild &#x3D;&#x3D; NULL &amp;&amp; bt-&gt;rightChild &#x3D;&#x3D; NULL)        return 1;    int left &#x3D; leafNum(bt-&gt;leftChild);    int right &#x3D; leafNum(bt-&gt;rightChild);    return left + right;    &#125;int main() &#123;    BiTree tree;    cout &lt;&lt; &quot;---PreOrder---\n&quot;;    tree.PreOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---InOrder---\n&quot;;    tree.InOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---PostOrder---\n&quot;;    tree.PostOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---LevelOrder---\n&quot;;    tree.LevelOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;the num of the leaves: &quot;;    cout &lt;&lt; tree.leafNum(tree.getRoot());&#125;</code></pre>]]></content>
    
    
    <summary type="html">整理了简单二叉树的简单应用，包括前中后遍历，求树的深度、叶子节点个数</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>kmp</title>
    <link href="https://jaydenchang.top/post/0x0026.html"/>
    <id>https://jaydenchang.top/post/0x0026.html</id>
    <published>2021-10-30T16:00:00.000Z</published>
    <updated>2022-08-16T14:23:32.545Z</updated>
    
    <content type="html"><![CDATA[<p>注：本篇文章只记录我理解的过程、需要注意的小细节，不涉及具体讲解，一些具体的原理、推导步骤可参考文末我列出的文章和视频</p><p>说到字符串匹配，以前的我，对时间、空间复杂度没有什么概念，估计写出来的代码长这样</p><h3 id="bfbrute-force">BF(brute-force)</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int BF(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0; j &#x3D; 0;    while (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        if (s[i] &#x3D;&#x3D; p[j]) &#123;            i++, j++;            &#x2F;&#x2F; 匹配成功就指针都后移        &#125; else &#123;            i &#x3D; i - j + 1;            j &#x3D; 0;        &#125;    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else         return -1;&#125;</code></pre><p>查阅资料后发现，这￥%&amp;#时间复杂度还挺高，假设文本串长m，模式串长n，时间复杂度是<code>O(m*n)</code>，如果m和n都很大的话，效率会低到无法想象</p><h3 id="kmp">kmp</h3><p>这时候，引入一个新算法，kmp，反正就是三个大佬的名字首字母拼在一起</p><p>要理解kmp，首先要理解kmp中的next数组，next数组，说人话，就类似一个索引。kmp的本质就是利用模式串的最长公共前后缀来缩短查找时间</p><p>如果字符失配，模式串向后移动<code>j-next[j]</code>位，这样说还不是很好理解，看一个例子</p><table><thead><tr class="header"><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr class="odd"><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td><u><strong>d</strong></u></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>这里在第七位失配，在d前面，有最长公共前后缀"ab"，长度为2，按照刚才说的，模式串向后移动<code>j-next[j]</code>位，即<code>6-next[6]</code>，其中<code>next[6] = 2</code>，变成如下</p><table><thead><tr class="header"><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td><u><strong>c</strong></u></td><td>d</td><td>a</td><td>b</td><td>d</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>c失配，c前无最长公共前后缀，向后移动<code>2-next[2]</code>，也就是2位</p><table><thead><tr class="header"><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td><u><strong>d</strong></u></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在d处又失配，再次移动<code>6-next[6]</code>也就是4位</p><table><thead><tr class="header"><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td>d</td><td></td></tr></tbody></table><p>匹配成功ヾ(≧▽≦*)o</p><p>以上就是kmp算法的基本实现流程</p><h4 id="next">next</h4><h5 id="next数组的二三事">next数组的二三事</h5><p>next数组的实质是：在当前字符前，最长公共前后缀的字符数</p><p>先拿出一个模式串：<code>abcabzan</code></p><p>对于next，有些版本默认第0位是-1，有的是0，这里默认第0位是-1.</p><ul><li>对于第一位是a，前面没有字符，赋值-1</li><li>第二位b前面只有一个字符，没有相同子串，赋值0</li><li>第三位前面两个字符没有同，赋值0</li><li>第四位前面也无，同上</li><li>第五位前面有相同前后缀元素，即a，赋值1</li><li>第六位前面，继续找，发现有更长的前后缀公共元素，是ab，两个字符，赋值2</li><li>第七位无，第八位前有一个a，赋值1，后面无公共元素</li><li>一般来说不用管最后一位是否和前面的字符能匹配上，next的目的是判断当前字符前面是否有相同的子串</li></ul><p>最后把next数组的值罗列一下</p><p><code>-1 0 0 0 1 2 0 1</code></p><p>然后就得到了next数组</p><h5 id="next数组代码实现">next数组代码实现</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void makeNext(string p, int next[]) &#123;    int j &#x3D; 0, k &#x3D; -1;    int len &#x3D; p.length();    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            &#x2F;&#x2F; 这里判断是否从首位开始匹配，或者模式串前后是否匹配成功            j++, k++;            next[j] &#x3D; k;            &#x2F;&#x2F; 匹配成功就把当前匹配的字符数赋给当前next[j]            &#x2F;&#x2F; 即模式串第j位前有k个最长前后缀公共元素        &#125; else &#123;            k &#x3D; next[k];            &#x2F;&#x2F; 把当前next[k]赋给k，也就相当于整个模式串向后移动next[k]位        &#125;    &#125;&#125;</code></pre><h5 id="next数组的优化">next数组的优化</h5><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr class="odd"><td>a</td><td>b</td><td>a</td><td>b</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>对于模式串<code>"abab"</code>，它的next数组为<code>-1 0 0 1</code></p><p>当c与b失配时，模式串向后移动<code>3-next[3] = 2</code>，变成如下</p><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td>a</td><td><u><strong>b</strong></u></td><td>a</td><td>b</td><td></td><td></td><td></td></tr></tbody></table><p>看到上面这里，原来<code>p[j]</code>和<code>s[j]</code>失配，右移之后，变成<code>s[j]</code>和<code>p[next[j]]</code>(即前后缀相同字符)匹配，然后呢，又失配了，虽然说在这组字符串里最后都能匹配成功，但是移动后，按照道理，失配位前面的字符在移动之后都能匹配成功，如果一直出现这样的情况的话，那么匹配的效率就会下降。</p><p>那么怎么修改？答案是，<strong>不能容许<code>p[j]=p[next[j]]</code></strong>。如果出现刚才叙述的情况，则需递归，令<code>next[j] = next[next[j]]</code></p><p>那么这个递归又是怎么个回事呢？(看了好久才懂)</p><p>随便举一个字符串<code>ababc</code></p><p>下标从0开始，到c这个位置，也就是第4位，下标为1的字符b和下标为3的字符b是等价的，在递归之后，next数组更新，可避免出现刚才那样的bug，后移之后在前面的子串部分失配(按照道理，公共前后缀部分是不会失配的)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void makeNext(string p, int next[]) &#123;    int len &#x3D; p.length();    int k &#x3D; -1, j &#x3D; 0;    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            j++, k++;            if (p[j] !&#x3D; p[k])                 next[j] &#x3D; k;            &#x2F;&#x2F; 如果匹配失败就把匹配数赋给next[j]            else                 next[j] &#x3D; next[k];            &#x2F;&#x2F; 不能出现p[j] &#x3D; p[next[j]]的情况，需要继续递归        &#125; else &#123;            k &#x3D; next[k];            &#x2F;&#x2F; 把k复位(分匹配是否成功两种情况)        &#125;    &#125;&#125;</code></pre><p>优化过后的数组</p><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>b</th></tr></thead><tbody><tr class="odd"><td>-1</td><td>0</td><td>-1</td><td>0</td></tr></tbody></table><p>单单只看优化过后的代码，感觉还是有点恍惚，还是要结合kmp的主干部分来看</p><h4 id="kmp-1">kmp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int kmp(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0, j &#x3D; 0;    int *next &#x3D; new int[len2];    makeNext(p, next);    while (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        &#x2F;&#x2F; j为-1 or 匹配成功才指针后移        if(j &#x3D;&#x3D; -1 || s[i] &#x3D;&#x3D; p[j])             i++, j++;        &#x2F;&#x2F; 匹配就指针后移        else             j &#x3D; next[j];                &#x2F;&#x2F; 不匹配就根据之前求出的next来决定模式串从哪开始匹配    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else        return 0;&#125;</code></pre><p>优化过后继续结合刚才优化前出现bug的那个数组</p><p>优化后next：<code>-1 0 -1 0</code></p><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr class="odd"><td>a</td><td>b</td><td>a</td><td><u><strong>b</strong></u></td><td></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第四位失配，后移<code>3-next[3]</code>，递归后<code>next[3] = 0</code>，后移了3位</p><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td>a</td><td>b</td><td>a</td><td>b</td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td><td></td></tr></tbody></table><p>c和a失配，再后移</p><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>a</td><td>b</td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td></tr></tbody></table><p>匹配成功</p><h4 id="完整代码">完整代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;void makeNext(string p, int next[]);int kmp(string s, string p);void makeNext(string p, int next[]) &#123;    int len &#x3D; p.length();    int j &#x3D; 0, k &#x3D; -1;    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            j++, k++;            if (p[j] !&#x3D; p[k])                next[j] &#x3D; next[k];            else                k &#x3D; next[j];        &#125;     &#125;&#125;int kmp(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0, j &#x3D; 0;    int *next &#x3D; new int[len2];    makeNext(p, next);    while (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        if (j &#x3D;&#x3D; -1 || s[i] &#x3D;&#x3D; p[j])            i++, j++;        else            j &#x3D; next[j];    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else         return 0;&#125;int main() &#123;    string s, p;    cin &gt;&gt; s &gt;&gt; p;    if (kmp(s, p) &#x3D;&#x3D; 1)        cout &lt;&lt; &quot;found the key string\n&quot;;    else        cout &lt;&lt; &quot;not found the key string\n&quot;;&#125;</code></pre><h3 id="参考链接">参考链接</h3><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解KMP（2014年8月22日版）_结构之法 算法之道-CSDN博客_kmp</a></p><p><a href="https://www.bilibili.com/video/BV1Ys411d7yh?from=search&amp;seid=14595349758363193343&amp;spm_id_from=333.337.0.0">【soso字幕】汪都能听懂的KMP字符串匹配算法【双语字幕】_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">填坑系列之kmp，本篇文章只记录我理解的过程、需要注意的小细节，不涉及具体讲解，一些具体的原理、推导步骤可参考文末我列出的文章和视频</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--不设头指针的循环链队列</title>
    <link href="https://jaydenchang.top/post/0x0025.html"/>
    <id>https://jaydenchang.top/post/0x0025.html</id>
    <published>2021-10-24T16:00:00.000Z</published>
    <updated>2021-12-11T05:52:19.369Z</updated>
    
    <content type="html"><![CDATA[<p>本次数据结构的作业是设计一个只有尾指针的循环链队列，要求实现构造(有参 &amp;&amp; 无参)、析构、出入列、获取头结点等功能。在完成过程中踩了很多坑(特别是在实现析构时qwq)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;struct Node &#123;    DataType data;    Node&lt;DataType&gt;* next;&#125;;template &lt;class DataType&gt;class LinkQueue &#123;    public:     LinkQueue();     LinkQueue(int [], int);     ~LinkQueue();     void EnQueue(DataType x);     DataType DeQueue();     DataType GetQueue();        private:     Node&lt;DataType&gt;* rear;&#125;;</code></pre><h4 id="有参构造无参构造">有参构造&amp;&amp;无参构造</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue(int arr[], int n) &#123;    rear &#x3D; new Node&lt;DataType&gt;;    Node&lt;DataType&gt;* p &#x3D; rear;    &#x2F;&#x2F;储存首地址，最后把尾巴连上for(int i &#x3D; 0; i &lt; n; i++) &#123;        rear-&gt;next &#x3D; new Node&lt;DataType&gt;;        rear &#x3D; rear-&gt;next;        rear-&gt;data &#x3D; arr[i];    &#125;    rear-&gt;next &#x3D; p;    &#x2F;&#x2F; 把尾巴连到首部&#125;template &lt;class DataType&gt;LinkQueue&lt;DataTpye&gt;::LinkQueue() &#123;    rear &#x3D; NULL;&#125;</code></pre><h4 id="进队-出队">进队 &amp;&amp; 出队</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void LinkQueue&lt;DataType&gt;::EnQueue(DataType x) &#123;    Node&lt;DataType&gt;* p &#x3D; new Node&lt;DataType&gt;;        p-&gt;data &#x3D; x;    if (rear &#x3D;&#x3D; NULL) &#123;        rear &#x3D; p;        rear-&gt;next &#x3D; p;    &#125; else &#123;        p-&gt;next &#x3D; rear-&gt;next;  &#x2F;&#x2F; 新建节点连接头指针        rear-&gt;next &#x3D; p; &#x2F;&#x2F; 尾指针连接新节点        rear &#x3D; p; &#x2F;&#x2F; 尾指针后移    &#125;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::DeQueue() &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    DataType x;    if (rear &#x3D;&#x3D; NULL)         throw &quot;dive dowm&quot;;    p &#x3D; rear-&gt;next;    x &#x3D; p-&gt;data;    if (rear &#x3D;&#x3D; p)        rear &#x3D; NULL;    else         rear-&gt;next &#x3D; p-&gt;next;    delete p;    return x;&#125;</code></pre><h4 id="获取头结点">获取头结点</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::GetQueue() &#123;    if (rear !&#x3D; NULL)        return rear-&gt;next-&gt;data;    &#x2F;&#x2F; return rear-&gt;data;    &#x2F;&#x2F; 这里rear已经指向队末，按照上一行代码，返回的是队末元素    else        throw &quot;empty queue&quot;;&#125;</code></pre><h4 id="清空循环链队列也可写成析构">清空循环链队列(也可写成析构)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::~LinkQueue() &#123;    Node&lt;DataType&gt;* p;    while (rear !&#x3D; NULL) &#123;        &#x2F;&#x2F; the wrong version:                &#x2F;&#x2F; p &#x3D; rear;        &#x2F;&#x2F; rear &#x3D; rear-&gt;next;        &#x2F;&#x2F; delete p;        p &#x3D; rear-&gt;next;        if (rear &#x3D;&#x3D; p) &#123;            delete rear;            break;        &#125; else             rear-&gt;next &#x3D; p-&gt;next;        delete p;    &#125;&#125;</code></pre><p>关于这个析构函数，我在网上找了很多个版本，很多代码都是写成注释里的那样，包括老师给的答案也是，有些编译器直接运行可能看不出什么问题，但是放在debug模式里，就会报错</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0025-1.jpg' style="zoom:67%;" ></p><p>如上图，在这里我已将循环链队列所有元素delete，当我查看变量的值时，发现，没那么简单，rear指针不为null，它指向的data值也是不规则的，也就不难说明为什么跳不出第46行的while循环了</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0025-2.jpg' style="zoom:67%;" ></p><p>跳不出循环后，继续delete，就会报错，虽然提示<code>unKnown signal</code>，实际上是队列为空，无法继续delete</p><p>那么怎么解决呢，我将出列函数改写，放到析构函数里，这样子在删除最后一个节点时就能跳出循环，结束析构</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0025-3.JPG'></p><h4 id="完整代码">完整代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template &lt;class DataType&gt;struct Node &#123;    DataType data;    Node&lt;DataType&gt;* next;&#125;;template &lt;class DataType&gt;class LinkQueue &#123;   public:    LinkQueue();    LinkQueue(int[], int);    ~LinkQueue();    void EnQueue(DataType x);    DataType DeQueue();    DataType GetQueue();   private:    Node&lt;DataType&gt;* rear;&#125;;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue(int arr[], int n) &#123;    rear &#x3D; new Node&lt;DataType&gt;;    &#x2F;&#x2F; rear-&gt;data &#x3D; arr[0];    Node&lt;DataType&gt;* p &#x3D; rear;  &#x2F;&#x2F; 储存首地址，最后把尾巴连接到首部    for (int i &#x3D; 0; i &lt; n; i++) &#123;        rear-&gt;next &#x3D; new Node&lt;DataType&gt;;  &#x2F;&#x2F; 不断开辟空间        rear &#x3D; rear-&gt;next;                &#x2F;&#x2F; rear后移        rear-&gt;data &#x3D; arr[i];    &#125;    rear-&gt;next &#x3D; p;  &#x2F;&#x2F;把尾巴连到首部&#125;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue() &#123;    rear &#x3D; NULL;&#125;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::~LinkQueue() &#123;    Node&lt;DataType&gt;* p;    while (rear !&#x3D; NULL) &#123;                p &#x3D; rear-&gt;next;        if (rear &#x3D;&#x3D; p) &#123;            delete rear;            break;        &#125; else &#123;            rear-&gt;next &#x3D; p-&gt;next;        &#125;        delete p;    &#125;&#125;template &lt;class DataType&gt;void LinkQueue&lt;DataType&gt;::EnQueue(DataType x) &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    p &#x3D; new Node&lt;DataType&gt;;    p-&gt;data &#x3D; x;    if (rear &#x3D;&#x3D; NULL) &#123;        rear &#x3D; p;        rear-&gt;next &#x3D; p;    &#125; else &#123;        p-&gt;next &#x3D; rear-&gt;next;  &#x2F;&#x2F; 新建节点连接头指针        rear-&gt;next &#x3D; p;        &#x2F;&#x2F; 尾指针连接新节点        rear &#x3D; p;              &#x2F;&#x2F; 尾指针后移    &#125;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::DeQueue() &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    DataType x;    if (rear &#x3D;&#x3D; NULL)        throw &quot;dive down&quot;;    p &#x3D; rear-&gt;next;    x &#x3D; p-&gt;data;    if (rear &#x3D;&#x3D; p)        rear &#x3D; NULL;    else        rear-&gt;next &#x3D; p-&gt;next;    delete p;    return x;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::GetQueue() &#123;    if (rear !&#x3D; NULL)        return rear-&gt;next-&gt;data;    &#x2F;&#x2F; return rear-&gt;data;    &#x2F;&#x2F; 这里rear已指向队末，返回的是队末元素    else        throw &quot;empty queue&quot;;&#125;int main() &#123;    LinkQueue&lt;int&gt; Queue;    try &#123;        Queue.EnQueue(5);        Queue.EnQueue(10);        Queue.EnQueue(15);        &#x2F;&#x2F; Queue.EnQueue(20);    &#125; catch (char* wrong) &#123;        cout &lt;&lt; wrong &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;get head element&quot; &lt;&lt; endl;    cout &lt;&lt; Queue.GetQueue() &lt;&lt; endl;    try &#123;        Queue.DeQueue();    &#125; catch (char* wrong) &#123;        cout &lt;&lt; wrong &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;get head element&quot; &lt;&lt; endl;    cout &lt;&lt; Queue.GetQueue() &lt;&lt; endl;&#125;</code></pre>]]></content>
    
    
    <summary type="html">记录一次和作业答案bug的对抗过程</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--关于单链表小细节的一些补充</title>
    <link href="https://jaydenchang.top/post/0x0024.html"/>
    <id>https://jaydenchang.top/post/0x0024.html</id>
    <published>2021-10-04T16:00:00.000Z</published>
    <updated>2021-12-11T05:53:22.157Z</updated>
    
    <content type="html"><![CDATA[<p>以下是在做数据结构作业时遇到的一些bug<del>(老师给的答案不太行)</del></p><h4 id="无相应构造函数报错">无相应构造函数报错</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int MaxSize &#x3D; 10;template &lt;class T&gt;class Seqlist &#123;    public:    Seqlist() &#123; length &#x3D; 0;&#125;    Seqlist(T [],int);    private:    int length;    T data[MaxSize];&#125;;    class B &#123;    public:    B(T);    B() &#123;&#125; &#x2F;&#x2F;这个默认的构造函数十分重要    private:    T data;&#125;;B::B(T n) &#123;    data &#x3D; n;&#125;template &lt;class T&gt;Seqlist&lt;T&gt;::Seqlist(T arr[], int n) &#123;    if (n &gt; MaxSize) throw &quot;invalid num&quot;;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        data[i] &#x3D; arr[i];    &#125;    length &#x3D; n;&#125;int main() &#123;    B b[3] &#x3D; &#123;B(10), B(20), B(30)&#125;;    Seqlist&lt;B&gt; list(b,3);&#125;</code></pre><p>在上面部分代码中，如果把有注释的那一行代码删去，则这部分代码不能正常运行，报错信息是</p><p><code>no matching function for call to 'B::B()'[25, 35]</code></p><p>根据这个报错信息找到相应行数，居然在<code>int n</code>这里报错，我寻思着这关n什么事，后面查阅了资料，原因出在第34行的<code>B b[3]</code>这里，定义了一个B类型的数组，没有参数传入，而B类中无适配该成员的构造函数，于是编译器报错</p><p>解决方法是，加上相应的构造函数<code>B() &#123;&#125;</code></p><h4 id="线性链表的反转和复制功能">线性链表的反转和复制功能</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;template &lt;class T&gt;struct Node &#123;    T data;    Node&lt;T&gt;* next;&#125;;template &lt;class T&gt;class LinkList &#123;    public:     LinkList(); &#x2F;&#x2F; create an empty list    LinkList(T[], int);    &#x2F;&#x2F;~LinkList();        void Reverse(Node&lt;T&gt;* head);    Node&lt;T&gt;* Copy(Node&lt;T&gt;* head);    Node&lt;T&gt;* first;&#125;template &lt;class T&gt;LinkList&lt;T&gt;::LinkList() &#123;    first &#x3D; new Node&lt;T&gt;;    first-&gt;next &#x3D; NULL;&#125;template &lt;class T&gt;LinkList&lt;T&gt;::LinkList(T arr[], int n) &#123;    first &#x3D; new Node&lt;T&gt;;    Node&lt;T&gt;* p &#x3D; first;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        Node&lt;T&gt;* s &#x3D; new Node&lt;T&gt;;        s-&gt;data &#x3D; arr[i];        p-&gt;next &#x3D; s;&#x2F;&#x2F;让first指向第一个节点        p &#x3D; s;&#x2F;&#x2F;虽说把s的地址赋给p，但是first的地址和p不一样，对p操作不会改变first        &#x2F;&#x2F;因此first永远指向链表第一个位置    &#125;    p-&gt;next &#x3D; NULL;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::Reverse(Node&lt;T&gt;* head) &#123;    Node&lt;T&gt;* pre, *cur;    cur &#x3D; head-&gt;next;    head-&gt;next &#x3D; NULL;    while (cur) &#123;        pre &#x3D; cur;&#x2F;&#x2F;让当前节点的上一节点移动到当前节点位置        cur &#x3D; cur-&gt;next;&#x2F;&#x2F;当前节点移动到下一个位置        pre-&gt;next &#x3D; head-&gt;next;&#x2F;&#x2F;这一操作就是让pre不断指向前一个节点        head-&gt;next &#x3D; pre;&#x2F;&#x2F;更新节点，让head的next指向pre    &#125;    &#x2F;&#x2F;在画图理解时，要让cur和pre同时向后移动    &#x2F;&#x2F;这一部分，建议自己在纸上画出若干个节点和用三个小部件(代表三个指针)模拟一边才能够真正地理解&#125;&#x2F;&#x2F;复盘时自己有个小细节没注意到，这里都是指针变量的赋值操作，这里的赋值只是赋予地址，给予者的值改变，接收者的值不会改变template &lt;class T&gt;Node&lt;T&gt;* LinkList&lt;T&gt;::Copy(Node&lt;T&gt;* head) &#123;    Node&lt;T&gt;* headB &#x3D; new Node&lt;T&gt;;    Node&lt;T&gt;* pb &#x3D; headB;    Node&lt;T&gt;* pa &#x3D; head-&gt;next;    while (pa !&#x3D; NULL) &#123;        Node&lt;T&gt;* temp &#x3D; new Node&lt;T&gt;;        temp-&gt;data &#x3D; pa-&gt;data;        temp-&gt;next &#x3D; NULL;&#x2F;&#x2F;这里用到了一个临时指针变量        pb-&gt;next &#x3D; temp;&#x2F;&#x2F;让pb连上temp        pb &#x3D; pb-&gt;next;        pa &#x3D; pa-&gt;next;        &#x2F;&#x2F;这里向后移动    &#125;    return headB;    &#x2F;&#x2F;注意这里返回的是headB，在调用时记得再加一个&quot;-&gt;next&quot;&#125;int main() &#123;    int arr[] &#x3D; &#123;1, 2, 3, 4, 5&#125;;    LinkList&lt;int&gt; list(arr,5);    cout &lt;&lt; &quot;the origin state: &quot; &lt;&lt; endl;    list.PrintList();        cout &lt;&lt; endl &lt;&lt; &quot;copy list a to list b\n&quot;;    Node&lt;int&gt;* ptr &#x3D; new Node&lt;int&gt;;    ptr &#x3D; list.copy(list.first)-&gt;next;    while (ptr !&#x3D; NULL) &#123;        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;;        ptr &#x3D; ptr-&gt;next;    &#125;        cout &lt;&lt; endl &lt;&lt; &quot;reverse the list a\n&quot;;    list.Reverse(list.first);    list.PrintList();&#125;</code></pre><h4 id="链表反转参考视频">链表反转参考视频</h4><p><a href="https://www.bilibili.com/video/BV1KZ4y157Up?from=search&amp;seid=15845376229805622503&amp;spm_id_from=333.337.0.0">LeetCode力扣刷题 | 剑指Offer 24. 反转链表_哔哩哔哩_bilibili</a> [小姐姐声音很温柔doge]</p><p><a href="https://www.bilibili.com/video/BV1CW411N7mg?from=search&amp;seid=15845376229805622503&amp;spm_id_from=333.337.0.0">一分钟教你链表反转_哔哩哔哩_bilibili</a> [这个动画模拟比较贴合代码框的函数]</p><p>//谁知道我当时居然还去断点debug把每个节点以及他们的next的地址抄下来去对比</p>]]></content>
    
    
    <summary type="html">记录一次和老师给的答案的bug的对抗过程</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>旧手机改造成web服务器并实现内网穿透</title>
    <link href="https://jaydenchang.top/post/0x0023.html"/>
    <id>https://jaydenchang.top/post/0x0023.html</id>
    <published>2021-08-27T16:00:00.000Z</published>
    <updated>2021-12-11T05:53:51.507Z</updated>
    
    <content type="html"><![CDATA[<p>前几天由于gitee的审核引擎一通乱杀，使得gitee pages停止提供服务，心生更换服务器或者其他pages托管的想法，看了看价格感人的云服务器以及空空的钱包，这时，脑子有个奇怪的想法飘过，自己搞一个服务器，忽然想起来，我有一台root的旧手机，刚好拿来做测试</p><h3 id="前期准备">前期准备</h3><p>需要的工具：一台旧安卓手机(能获取root权限)，能联网的电脑，并装有Git</p><p>需要安装的软件：Linux Deploy，BusyBox，JuiceSSH (可选)，KSWEB (可选)</p><blockquote><p>JuiceSSH执行命令速度比电脑快，不过是手机操作，可能需要外接键盘</p><p>以下操作全在电脑端操作，不演示JuiceSSH与Linux Deploy的连接 (教程见文末第三个链接)</p></blockquote><p>需要的经验：部署过hexo博客，有一定git (或linux)基础，灵活运用关键字搜索，vim编辑器的使用语法</p><p><em>旧手机的基本信息</em></p><blockquote><ul><li>手机型号：Redmi 3</li><li>Android版本：5.1.1</li><li>Linux发行版：CentOS 7 (AltArch) [running via Linux Deploy]</li><li>RAM：2.0GiB</li><li>CPU：8核1.5GHz</li><li>储存空间：10GiB，可用4GiB</li></ul></blockquote><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-1.jpg' style="zoom: 25%;border-radius:2em" ></p><h3 id="配置linux环境">配置Linux环境</h3><p>首先打开BusyBox，点击安装 (需要root权限)</p><p>然后打开Linux Deploy，点击右下方的配置，设置系统相关信息，容器类型选chroot，发行版选CentOS，如果选其他发行版，架构一定要选对，不然会安装出错，或者无法使用，安装之前一定要知道手机CPU的架构；源地址建议切换为国内源，这里放上中科大的镜像源 http://mirrors.ustc.edu.cn/centos-altarch/ ，国内还有其他源可选择，例如清华源，阿里源等</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-2.jpg' style="zoom: 25%;border-radius:2em" ></p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-3.jpg' style="zoom: 25%;border-radius:2em" ></p><p>这里的设置很重要，一定要启用ssh，后面的步骤会用到 (SSH默认端口是22，此端口用于JuiceSSH连接)</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-4.jpg' style="zoom: 25%;border-radius:2em" ></p><p>然后返回主界面，点击左上，打开设置，建议前三个选项都勾上，往下滑，看到<code>PATH变量</code>，输入<code>/system/xbin</code>，再往下拉，把 调试模式 也勾上</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-5.jpg' style="zoom: 25%;border-radius:2em" ></p><p>再回到主界面，点击右上角，开始安装，大约要半小时</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-6.jpg' style="zoom: 25%;border-radius:2em" ></p><p>a few thousand years later......</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-7.jpg' style="zoom: 25%;border-radius:2em" ></p><p>看到手机输出<code>&lt;&lt;&lt;deploy</code>时说明安装完成，启动前先点击一次停止按钮，看见<code>&lt;&lt;&lt;stop</code>时再点击启动，看见输出如图内容时即成功启动。</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-8.jpg' style="zoom: 25%;border-radius:2em" ></p><p>然后打开KSWEB，查看当前手机的局域网ip，例如我手机的ip是192.168.101.10</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-9.jpg' style="zoom: 25%;border-radius:2em" ></p><p>然后打开电脑终端(cmd，git，wsl都可)，输入<code>ssh admin@192.168.101.10</code>，按照要求输入密码(前面的Linux Deploy配置里有密码的选项)，如下图所示即成功连接手机</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-10.jpg' style="zoom: 100%;border-radius:0.5em" ></p><h3 id="在服务器上部署">在服务器上部署</h3><h4 id="配置git">配置git</h4><p>在服务器端安装git和node.js</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y gitcurl -sL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_12.x | bash -yum -y install nodejs</code></pre><div class="tip"><p>如果出现没做任何操作，下载自行终止并出现<code>Exiting on user cancel</code>，可尝试输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum clean metadatayum clean allyum upgrade</code></pre><p>如果出现<code>Failed to set locale, defaulting to C.UTF-8</code>，是没有正确设置语言环境或者没安装相关语言包导致的，可尝试用两种解决方法</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;export LC_ALL&#x3D;en_US.UTF-8&quot; &gt;&gt; &#x2F;etc&#x2F;profilesource &#x2F;etc&#x2F;profile</code></pre><p>执行完后<strong>重新登陆</strong>再试安装，若还出现这个情况，安装相应语言包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install glibc-langpack-zh &#x2F;&#x2F;中文包&#x2F;&#x2F;英文包dnf install glibc-langpack-en 或dnf install langpacks-en glibc-all-langpacks -y</code></pre></div><p>创建用户并配置其仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">useradd gitpasswd git &#x2F;&#x2F; 设置密码su git &#x2F;&#x2F; 这步很重要，不切换用户后面会很麻烦cd &#x2F;home&#x2F;git&#x2F;mkdir -p projects&#x2F;blog &#x2F;&#x2F; 项目存在的真实目录mkdir repos &amp;&amp; cd reposgit init --bare blog.git &#x2F;&#x2F; 创建一个裸露的仓库cd blog.git&#x2F;hooksvi post-receive &#x2F;&#x2F; 创建 hook 钩子函数，输入了内容如下</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;shgit --work-tree&#x3D;&#x2F;home&#x2F;git&#x2F;projects&#x2F;blog --git-dir&#x3D;&#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git checkout -f</code></pre><p>添加完毕修改权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod +x post-receiveexit &#x2F;&#x2F; 退出到 root 登录chown -R git:git &#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git &#x2F;&#x2F; 添加权限</code></pre><p>测试<code>git仓库</code>是否可用，另找空白文件夹，在电脑端右键git bash here，输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone git@server_ip:&#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git</code></pre><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-11.jpg' style="zoom:50%;border-radius:0.7em" ></p><p>如果能clone空仓库，说明git仓库搭建成功</p><p>建立ssh信任关系，在电脑输入以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-copy-id -i C:&#x2F;Users&#x2F;yourname&#x2F;.ssh&#x2F;id_rsa.pub git@server_ip&#x2F;&#x2F;如果用户名有空格，路径用引号括起来ssh git@server_ip &#x2F;&#x2F; 测试能否登录</code></pre><p><strong>注：此时的 ssh 登录 git 用户不需要密码！否则就有错，请仔细重复步骤 3-5</strong></p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-12.jpg' style="zoom:50%;border-radius:0.7em" ></p><p>如图即成功添加信任</p><p>为了安全起见禁用 git 用户的 shell 登录权限，从而只能用 git clone，git push</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;etc&#x2F;shells &#x2F;&#x2F; 查看 git-shell 是否在登录方式里面which git-shell &#x2F;&#x2F; 查看是否安装vi &#x2F;etc&#x2F;shells添加上2步显示出来的路劲，通常在 &#x2F;usr&#x2F;bin&#x2F;git-shell</code></pre><p>修改<code>/etc/passwd</code>中的权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F; 将原来的git:x:1000:1000::&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash&#x2F;&#x2F; 修改为git:x:1000:1000:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</code></pre><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-13.jpg' style="zoom:45%;" ></p><blockquote><p>需修改的内容一般在最后一行，数字不用改，只需添加半角逗号和改路径即可</p></blockquote><h4 id="搭建nginx服务器">搭建nginx服务器</h4><p>下载并安装nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;usr&#x2F;local&#x2F;srcwget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.15.2.tar.gztar xzvf nginx-1.15.2.tar.gzcd nginx-1.15.2&#x2F;&#x2F; 执行之前先检查是否有安装gcc gdb gcc-c++ make wget这五个软件，没有的话不能进行下一步，可直接用yum命令安装.&#x2F;configure &#x2F;&#x2F; 如果后面还想要配置 SSL 协议，就执行后面一句！.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_modulemake &amp;&amp; make installalias nginx&#x3D;&#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx&#39; &#x2F;&#x2F; 为 nginx 取别名，后面可直接用，重新登陆后失效</code></pre><p>配置nginx文件</p><p>先启动是否安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx &#x2F;&#x2F; 直接来！浏览器查看 server_ip，默认是 80 端口</code></pre><p>修改配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -s stop &#x2F;&#x2F; 先停止nginxcd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;confvi nginx.conf修改 root 解析路径，如下图同时将 user 改为 root 如下图，不然nginx无法访问 &#x2F;home&#x2F;git&#x2F;projects&#x2F;blognginx -s reload</code></pre><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-14.jpg' style="zoom:50%;border-radius:0.7em" ></p><blockquote><p>需要修改第一个箭头所指的nobody，第二个箭头所指的是会产生bug的文件</p></blockquote><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-15.jpg' style="zoom:50%;border-radius:0.7em" ></p><blockquote><p>需要修改root的路径为博客位置，例如我之前设置的位置是<code>/home/git/projects/blog</code>，就把这个路径替换进去，注意不要漏了句尾的分号</p></blockquote><div class="tip"><p>在修改配置文件这里目测有坑，会出现<code>/usr/local/nginx/logs/nginx.pid failed</code>这样的字眼，打开<code>/usr/local/nginx/logs</code>，输入<code>ls -al</code>，没看见有<code>nginx.pid</code>，我的解决方法是输入这个<br /><code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code>，再输入<code>ls -al</code>，发现<code>nginx.pid</code>出现了，再次运行<code>nginx -s reload</code>，没有报错。</p></div><p>在这里，可以测试下部署在服务器的网页，不过只能实现局域网查。注意上图中有一个<code>listen  80</code>，这是一个设置在localhost的端口，可尝试在浏览器打开预览，不过建议换成其他端口，避免端口被占用无法预览，这里我换成800，可成功预览</p><div class="warning"><p>别忘了启动nginx，不然不能预览页面</p></div><p>在手机浏览器输入<code>127.0.0.1:800</code>或<code>192.168.101.10:800</code>可以预览</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-19.jpg' style="zoom: 40%;border-radius:0.8em" ></p><p>在同一局域网的电脑输入<code>192.168.101.10:800</code>即可预览</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-20.jpg' style="zoom: 50%;border-radius:0.8em" ></p><h3 id="发布">发布</h3><h4 id="配置_config.yml文件">配置<code>_config.yml</code>文件</h4><p>编辑deploy属性</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-17.jpg' style="zoom: 67%;border-radius:0.8em" ></p><blockquote><p>repo是推送到的目的地地址</p></blockquote><p>推送到服务器</p><p>使用<code>hexo d -g</code>或<code>hexo g- d</code>均可，如图即成功推送</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-18.jpg' style="zoom:67%;border-radius:0.7em" ></p><h3 id="内网穿透">内网穿透</h3><p>内网穿透有很多工具，常见的有花生壳，FRP，ngork。由于花生壳的价格过于感人，FRP需要另一台有公网ip的服务器，这里使用基于ngork的<a href='natapp.cn'>natapp</a></p><p>官网：https://natapp.cn <del>(快来打钱doge)</del></p><p>这里需要在Linux安装，安装方法用wget + Linux安装包，由于我不知道wget会保存到哪里，所以我在wget后加了一个指定路径</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget -P &#x2F;home&#x2F;git&#x2F; https:&#x2F;&#x2F;cdn.natapp.cn&#x2F;assets&#x2F;downloads&#x2F;clients&#x2F;2_3_9&#x2F;natapp_linux_arm64&#x2F;natapp?version&#x3D;20190730</code></pre><p>下载之后对安装包重命名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv natapp?version&#x3D;20190730 natapp</code></pre><p>在root下先给予执行权限再执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod a+x natapp.&#x2F;natapp</code></pre><p>直接运行<code>./natapp</code>还不能运行程序，这里需要加上创建的隧道的authtoken参数才能打开</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;natapp -authtoken&#x3D;&lt;your token&gt;</code></pre><p>运行程序后，图中的网址已穿透内网，可对外访问 (这是个临时链接)</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-21.jpg' style="zoom:50%;border-radius:0.8em" ></p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-22.jpg' style="zoom:40%;border-radius:0.8em" ></p><p>到这里，一个web私人服务器就搭好了。</p><p>另外，关于穿透的网址，natapp有一个付费隧道可以绑定自定义域名，每个月9￥，而花生壳那边的价格比较感人 (还花了6￥开启https穿透的认证，发现没什么luan用，我*&amp;%@)，最终还是选择了natapp</p><p>不过，我还是选择GitHub Pages + Netlify 来配置我的网站，私人服务器跑网页，需要让服务器24h保持运作状态 (感觉也废不了什么电费)，毕竟通过隧道来访问网站的速度和直接托管在GitHub Pages差不多，干脆直接用GitHub Pages比较省事</p><p>除了网页服务器，旧手机理论上也可以建一个私人网盘 <del>(感觉也没时间整了)</del></p><h3 id="参考链接">参考链接</h3><p><a href="https://ii.do/24.html">旧手机搭建网站以及内网穿透 - Dark's blog (ii.do)</a></p><p><a href="https://blog.csdn.net/qq_35561857/article/details/81590953">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器_jeffery5461的博客-CSDN博客_</a></p><p><a href="https://www.cnblogs.com/sw-code/p/14990229.html">使用Linux Deploy将闲置的安卓手机改造简易服务器 - sw-code - 博客园 (cnblogs.com)</a></p><p><a href="https://segmentfault.com/a/1190000017986794">超详细Hexo+Github Page搭建技术博客教程【持续更新】 - SegmentFault 思否</a></p><p>[<a href="https://blog.csdn.net/qq_41502780/article/details/104064975">解决nginx: [error] open() ＂/usr/local/nginx/logs/nginx.pid＂ failed错误_三也先生的博客-CSDN博客]</a></p><p><a href="https://developer.aliyun.com/article/387493">centos 7 升级后yum install出现Exiting on user cancel-阿里云开发者社区 (aliyun.com)</a></p><p><a href="https://www.cnblogs.com/h2285409/p/14745010.html">Failed to set locale, defaulting to C.UTF-8 - 天军 - 博客园 (cnblogs.com)</a></p><p><a href="https://mx142.cn/2020/12/22/11/">把hexo博客部署到服务器 | MX (mx142.cn)</a></p>]]></content>
    
    
    <summary type="html">我用半个月做了一个&quot;服务器&quot;</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="整活" scheme="https://jaydenchang.top/tags/%E6%95%B4%E6%B4%BB/"/>
    
    <category term="Linux" scheme="https://jaydenchang.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>迁移博客</title>
    <link href="https://jaydenchang.top/post/0x0022.html"/>
    <id>https://jaydenchang.top/post/0x0022.html</id>
    <published>2021-08-19T16:00:00.000Z</published>
    <updated>2021-12-11T05:54:15.728Z</updated>
    
    <content type="html"><![CDATA[<p>本站点已由<a href='https://jaydenchang.gitee.io'>旧站点</a>迁往<a href='https://jaydenchang.top'>jaydenchang.top</a>，旧站点已废弃</p><p>前几天准备更博客时，发现gitee的站点被ban了，了解到我的站点有违规内容 <del>(一脸懵逼)</del>，具体就不吐槽了，<strong>果然免费的是最贵的</strong>。后来心里冒出个想法，迁博客到别的服务器，gitee就当作图床了doge。</p><p>最终还是选择了GitHub pages，云服务器太贵了，自己搭的服务器内网穿透效果一般般<del>(先挖个坑)</del></p>]]></content>
    
    
    <summary type="html">记录一次站点迁移</summary>
    
    
    
    <category term="随笔" scheme="https://jaydenchang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://jaydenchang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>为博客添加评论邮件提醒功能(踩坑全过程)</title>
    <link href="https://jaydenchang.top/post/0x0021.html"/>
    <id>https://jaydenchang.top/post/0x0021.html</id>
    <published>2021-08-15T16:00:00.000Z</published>
    <updated>2021-12-11T05:55:03.852Z</updated>
    
    <content type="html"><![CDATA[<p>在很早之前，我就想过要给博客加一个邮件评论提醒功能，上个月折腾了三天愣是没折腾出什么，这几天学不进去，刚好来折腾这个。</p><p>因为懒，需要加载到图床的图片太多，这次不插入图片。</p><h3 id="准备工作">准备工作</h3><ul><li>注册一个 leancloud 国际版账户(国内的需要备案等一系列复杂的操作)</li><li>去GitHub fork项目，开启GitHub Action功能</li></ul><h3 id="为hexo博客添加评论valine系统">为hexo博客添加评论valine系统</h3><p>这一步可参考以下链接，此处不再赘述，包括</p><ul><li>注册leancloud</li><li>配置hexo博客根目录下的<code>_config.(the name of your theme).yml</code> (这里需要修改的是对应主题的yml文件，不是<code>_config.yml</code>)</li></ul><p><a href='https://blog.csdn.net/blue_zy/article/details/79071414'>为你的Hexo加上评论系统-Valine -- blue_zy</a></p><p><a href='https://blog.csdn.net/jiunian_2761/article/details/97388997'>Hexo博客进阶：为Next主题添加Valine评论系统-- 千帆过烬</a></p><p>前两步，csdn，博客园大多数帖子都有教程，剩下的步骤有些难度，需要大量阅读相关帖子</p><h3 id="为hexo博客添加valine评论邮件提醒功能">为hexo博客添加valine评论邮件提醒功能</h3><p>这一步包括</p><ul><li>自定义云引擎的变量 <del>(可选择氪还是不氪，不氪的选择体验版)</del></li><li>添加定时任务，定期唤醒和检查补发邮件</li></ul><p><a href='https://blog.csdn.net/Aoman_Hao/article/details/105323917'>Hexo博客Next主题valine评论系统邮件提醒 -- AomanHao</a></p><p>完成这一步并且测试后，我心满意足，开始写博客，一开始还是有收到评论邮件的，过几天更新时发现有新评论却没有邮件提醒，回到leancloud后台一看，我%￥#&amp;*，引擎自动休眠了，再看日志，现实云函数报错，马上去必应一下这个情况，找不到有效解决方案，那就先搁着；过了几天来看，我去，提示我这个信息</p><p>"因为流控问题，通过定时任务唤醒体验版实例失败，建议升级至标准版引擎实例避免休眠"</p><p>好家伙，这明摆着要我去氪。不过，本着我多年不氪金<del>(白嫖)</del>的习惯，又去必应了下解决方案</p><h3 id="解决leancloud流控问题最难">解决leancloud流控问题(最难)</h3><p>有三个常见的唤醒功能</p><ul><li>cron-job</li><li>Github+Action</li><li>Ajax请求唤醒</li></ul><p>csdn上大多数是去阿里云等网站申请唤醒功能，不过这些感觉需要花很多大洋的样子，就没去理会，后来发现GitHub+Action这个貌似不错，然后就去必应了下，雀食有很多帖子教GitHub+Action的，不过他们fork的项目已经不能访问了，就是这个： <code>https://github.com/blogimg/WakeLeanCloud</code></p><p>下面这两个帖子的</p><p><a href='https://hiram.wang/leancloud-timer-github-actions/#原有方案'>使用Github Actions模拟评论解决LeanCloud的流控限制 -- Hiram's Blog</a></p><p><a href='https://www.aimtao.net/slef-wake-leancloud/'>Gtihub Action｜一行命令解决 LeanCloud 流控问题 -- AimTao's Blog</a></p><p>以上两个博客提到的GitHub建议fork到本地仓库</p><p>按照上面两个博客其中之一设置完就差不多设置好了</p><h3 id="可能出现的问题">可能出现的问题</h3><ul><li>怎么进入leancloud国际版评论后台网站：参照这个博客来设置user变量 <a href='https://www.fezhu.top/2020/07/02/liukong/'>解决Leancloud流控问题 -- Uncleacc's Blog</a></li><li>为什么提示云函数报错：是因为没有在云引擎处设置变量<code>ADMIN_URL</code>，这里填leancloud评论后台管理网址</li><li>云引擎中的变量<code>SMTP_PASS</code>不是邮箱密码，是邮箱SMTP的授权码</li><li>GitHub Action那里的<code>SITE</code>应该填评论后台管理网址</li></ul><p>写到这里，总算把折腾的全过程写出来了<del>(无用的知识增加了)</del></p>]]></content>
    
    
    <summary type="html">记录一次整活，完善博客的评论提醒功能</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="整活" scheme="https://jaydenchang.top/tags/%E6%95%B4%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>单链表(Java)</title>
    <link href="https://jaydenchang.top/post/0x0020.html"/>
    <id>https://jaydenchang.top/post/0x0020.html</id>
    <published>2021-08-06T16:00:00.000Z</published>
    <updated>2021-12-11T05:56:35.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识">基础知识</h3><p>大体结构和C++的链表差不多，参考之前写过的博客 <a href='https://jaydenchang.gitee.io/post/0x0006'>单链表图书管理系统实例</a> <a href='https://jaydenchang.gitee.io/post/0x000B'>基于类的单链表实例</a></p><p>补充之前不知道的：链表分两类，带和不带头结点的链表 <del>现在才知道，Java没有像C/C++那样的指针</del></p><p>首先创建一个<code>LinkList</code>类，然后把链表的各个功能添加进去</p><h4 id="创建结点">创建结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;当不考虑编号顺序时，找到当前链表最后节点，将最后节点next指向新节点public void add(PersonNode node) &#123;    &#x2F;&#x2F;因为头节点不能动，先需要一个辅助遍历节点temp    PersonNode temp &#x3D; head;            while (true) &#123;&#x2F;&#x2F;遍历链表，找到最后        if (temp.next &#x3D;&#x3D; null) &#123;            break;        &#125;                    temp &#x3D; temp.next;&#x2F;&#x2F;如果没到最后，就继续找下去    &#125;&#x2F;&#x2F;当退出while循环时，temp指向链表的最后    temp.next &#x3D; node;&#125;</code></pre><h4 id="添加结点乱序">添加结点(乱序)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void addByOrder(PersonNode node) &#123;    &#x2F;&#x2F;因为头节点不移动，仍通过一个辅助变量来找添加的位置    &#x2F;&#x2F;因为是单链表，所以找的temp时位于添加位置的前一个结点，否则不能插入    PersonNode temp &#x3D; head;    boolean flag &#x3D; false;&#x2F;&#x2F;标识添加的编号是否存在    while (true) &#123;        if (temp.next &#x3D;&#x3D; null) &#x2F;&#x2F;说明temp在链表最后            break;        if (temp.next.no &gt; node.no) &#123;&#x2F;&#x2F;位置找到了，就在temp后面            break;        &#125; else if (temp.next.no &#x3D;&#x3D; node.no) &#123;&#x2F;&#x2F;希望添加的编号已存在            flag &#x3D; true;            break;        &#125;        temp &#x3D; temp.next;    &#125;    if (flag) &#123;&#x2F;&#x2F;编号已存在，不能添加        System.out.println(&quot;already exist no.&quot; + node.no + &quot;, you can&#39;t add it.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125; else &#123;        node.next &#x3D; temp.next;        temp.next &#x3D; node;    &#125;&#125;&#x2F;&#x2F;最终还是按照序号来排列</code></pre><h4 id="编辑结点">编辑结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void edit(PersonNode node) &#123;&#x2F;&#x2F;这里直接引入外部结点，根据node.no来寻找需要修改的结点    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    PersonNode temp;    temp &#x3D; head.next;    boolean flag &#x3D; false;&#x2F;&#x2F;判断是否找到该结点    while (true) &#123;        if (temp &#x3D;&#x3D; null)            break;&#x2F;&#x2F;到了链表最后        if (temp.no &#x3D;&#x3D; node.no) &#123;            flag &#x3D; true;&#x2F;&#x2F;找到            break;        &#125;        temp &#x3D; temp.next;    &#125;    &#x2F;&#x2F;根据flag判断是否找到    if (flag) &#123;        temp.name &#x3D; node.name;        temp.score &#x3D; node.score;    &#125; else &#123;        System.out.println(&quot;not found no.&quot; + node.no + &quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#125;</code></pre><h4 id="删除结点">删除结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void delete(int no) &#123;    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    PersonNode temp &#x3D; head;&#x2F;&#x2F;temp指向待删除结点的前一个结点    boolean flag &#x3D; false;    while (true) &#123;        if (temp.next &#x3D;&#x3D; null) &#123;                            break;&#x2F;&#x2F;已经到链表最后        &#125;        if (temp.next.no &#x3D;&#x3D; no) &#123;            flag &#x3D; true;&#x2F;&#x2F;找到了待删除结点的前一个结点temp            break;        &#125;        temp &#x3D; temp.next;    &#125;    if (flag) &#123;        temp.next &#x3D; temp.next.next;    &#x2F;&#x2F;Java会自动回收未被访问的数据            &#125; else &#123;        System.out.println(&quot;not found&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#125;</code></pre><h4 id="打印链表">打印链表</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void list() &#123;    &#x2F;&#x2F;判断链表是否为空    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    &#x2F;&#x2F;头节点不动，需要一个辅助变量来遍历    PersonNode temp &#x3D; head.next;    while (true) &#123;        &#x2F;&#x2F;判断是否到链表最后        if (temp &#x3D;&#x3D; null) &#123;            break;        &#125;        &#x2F;&#x2F;输出节点信息        System.out.println(temp);        &#x2F;&#x2F;由于之前重写了toString，这里直接打印temp就可以打印出节点的所有信息        temp &#x3D; temp.next;    &#125;&#125;</code></pre><h4 id="主函数">主函数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;    PersonNode person1 &#x3D; new PersonNode(1, &quot;Jordan&quot;, 56);    PersonNode person2 &#x3D; new PersonNode(2, &quot;Kobe&quot;, 81);    PersonNode person3 &#x3D; new PersonNode(3, &quot;James&quot;, 61);    PersonNode person4 &#x3D; new PersonNode(4, &quot;Melo&quot;, 60);    LinkList list &#x3D; new LinkList();&#x2F;&#x2F;按照顺序添加    &#x2F;&#x2F; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#x2F;&#x2F; list.add(person1);    &#x2F;&#x2F; list.add(person2);    &#x2F;&#x2F; list.add(person3);    &#x2F;&#x2F; list.add(person4);&#x2F;&#x2F;不按照顺序添加    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add by order&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    list.addByOrder(person1);    list.addByOrder(person4);    list.addByOrder(person3);    list.addByOrder(person2);    list.list();    &#x2F;&#x2F; list.addByOrder(person2);    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;edit&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    PersonNode newNode &#x3D; new PersonNode(3, &quot;Ivring&quot;, 57);    list.edit(newNode);    list.list();&#x2F;&#x2F;删除结点    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;delete&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    list.delete(4);    list.list();&#125;</code></pre><h4 id="完整代码">完整代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;SingleLinkList.javapublic class SingleLinkList &#123;    public static void main(String[] args) &#123;        PersonNode person1 &#x3D; new PersonNode(1, &quot;Jordan&quot;, 56);        PersonNode person2 &#x3D; new PersonNode(2, &quot;Kobe&quot;, 81);        PersonNode person3 &#x3D; new PersonNode(3, &quot;James&quot;, 61);        PersonNode person4 &#x3D; new PersonNode(4, &quot;Melo&quot;, 60);        LinkList list &#x3D; new LinkList();    &#x2F;&#x2F;按照顺序添加        &#x2F;&#x2F; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#x2F;&#x2F; list.add(person1);        &#x2F;&#x2F; list.add(person2);        &#x2F;&#x2F; list.add(person3);        &#x2F;&#x2F; list.add(person4);    &#x2F;&#x2F;不按照顺序添加        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add by order&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        list.addByOrder(person1);        list.addByOrder(person4);        list.addByOrder(person3);        list.addByOrder(person2);        list.list();        &#x2F;&#x2F; list.addByOrder(person2);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;edit&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        PersonNode newNode &#x3D; new PersonNode(3, &quot;Ivring&quot;, 57);        list.edit(newNode);        list.list();    &#x2F;&#x2F;删除结点        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;delete&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        list.delete(4);        list.list();    &#125;&#125;&#x2F;&#x2F;定义一个成员点class PersonNode &#123;    String name;    public int no;    public int score;    public PersonNode next;&#x2F;&#x2F;指向下一个结点    public PersonNode(int no, String name, int score) &#123;        this.no &#x3D; no;        this.name &#x3D; name;        this.score &#x3D; score;    &#125;    &#x2F;&#x2F;为了显示方便，重写toString    @Override    public String toString() &#123;        return &quot;[no&#x3D;&quot; + no + &quot;,name&#x3D;&quot; + name + &quot;,score&#x3D;&quot; + score + &quot;]&quot;;    &#125;&#125;&#x2F;&#x2F;定义LinkList管理personclass LinkList &#123;    &#x2F;&#x2F;初始化头节点，头节点不能动    private PersonNode head &#x3D; new PersonNode(0, &quot;&quot;, 0);    public PersonNode getHead()&#123;        return head;&#x2F;&#x2F;返回私有成员head    &#125;    &#x2F;&#x2F;当不考虑编号顺序时，找到当前链表最后节点，将最后节点next指向新节点    public void add(PersonNode node) &#123;        &#x2F;&#x2F;因为头节点不能动，先需要一个辅助遍历节点temp        PersonNode temp &#x3D; head;                while (true) &#123;&#x2F;&#x2F;遍历链表，找到最后            if (temp.next &#x3D;&#x3D; null) &#123;                break;            &#125;                        temp &#x3D; temp.next;&#x2F;&#x2F;如果没到最后，就继续找下去        &#125;&#x2F;&#x2F;当退出while循环时，temp指向链表的最后        temp.next &#x3D; node;    &#125;    public void addByOrder(PersonNode node) &#123;        &#x2F;&#x2F;因为头节点不移动，仍通过一个辅助变量来找添加的位置        &#x2F;&#x2F;因为是单链表，所以找的temp时位于添加位置的前一个结点，否则不能插入        PersonNode temp &#x3D; head;        boolean flag &#x3D; false;&#x2F;&#x2F;标识添加的编号是否存在        while (true) &#123;            if (temp.next &#x3D;&#x3D; null) &#x2F;&#x2F;说明temp在链表最后                break;            if (temp.next.no &gt; node.no) &#123;&#x2F;&#x2F;位置找到了，就在temp后面                break;            &#125; else if (temp.next.no &#x3D;&#x3D; node.no) &#123;&#x2F;&#x2F;希望添加的编号已存在                flag &#x3D; true;                break;            &#125;            temp &#x3D; temp.next;        &#125;        if (flag) &#123;&#x2F;&#x2F;编号已存在，不能添加            System.out.println(&quot;already exist no.&quot; + node.no + &quot;, you can&#39;t add it.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125; else &#123;            node.next &#x3D; temp.next;            temp.next &#x3D; node;        &#125;    &#125;    public void edit(PersonNode node) &#123;        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        PersonNode temp;        temp &#x3D; head.next;        boolean flag &#x3D; false;&#x2F;&#x2F;判断是否找到该结点        while (true) &#123;            if (temp &#x3D;&#x3D; null)                break;&#x2F;&#x2F;到了链表最后            if (temp.no &#x3D;&#x3D; node.no) &#123;                flag &#x3D; true;&#x2F;&#x2F;找到                break;            &#125;            temp &#x3D; temp.next;        &#125;        &#x2F;&#x2F;根据flag判断是否找到        if (flag) &#123;            temp.name &#x3D; node.name;            temp.score &#x3D; node.score;        &#125; else &#123;            System.out.println(&quot;not found no.&quot; + node.no + &quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;        public void delete(int no) &#123;        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        PersonNode temp &#x3D; head;&#x2F;&#x2F;temp指向待删除结点的前一个结点        boolean flag &#x3D; false;        while (true) &#123;            if (temp.next &#x3D;&#x3D; null) &#123;                                break;&#x2F;&#x2F;已经到链表最后            &#125;            if (temp.next.no &#x3D;&#x3D; no) &#123;                flag &#x3D; true;&#x2F;&#x2F;找到了待删除结点的前一个结点temp                break;            &#125;            temp &#x3D; temp.next;        &#125;        if (flag) &#123;            temp.next &#x3D; temp.next.next;        &#125; else &#123;            System.out.println(&quot;not found&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#x2F;&#x2F;Java会自动回收未被访问的数据    &#125;    &#x2F;&#x2F;显示链表(遍历)    public void list() &#123;        &#x2F;&#x2F;判断链表是否为空        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        &#x2F;&#x2F;头节点不动，需要一个辅助变量来遍历        PersonNode temp &#x3D; head.next;        while (true) &#123;            &#x2F;&#x2F;判断是否到链表最后            if (temp &#x3D;&#x3D; null) &#123;                break;            &#125;            &#x2F;&#x2F;输出节点信息            System.out.println(temp);            &#x2F;&#x2F;由于之前重写了toString，这里直接打印temp就可以打印出节点的所有信息            temp &#x3D; temp.next;        &#125;    &#125;&#125;</code></pre><h3 id="面试题">面试题</h3><h4 id="求单链表中有效结点个数">求单链表中有效结点个数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;如果带头节点的链表，不统计头节点public static int getLength(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null)        return 0;    int length &#x3D; 0;    PersonNode current &#x3D; head.next;&#x2F;&#x2F;定义辅助变量    while (current !&#x3D; null) &#123;        length++;        current &#x3D; current.next;    &#125;    return length;&#125;</code></pre><p>在主函数中测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(getLength(list.getHead()));</code></pre><h4 id="查找单链表中倒数第n个结点新浪">查找单链表中倒数第n个结点(新浪)</h4><p>思路</p><ul><li>编写一个方法，接收head结点，同时接收一个index</li><li>index表示是倒数第index个结点</li><li>先把链表从头到尾遍历，得到链表的总长度 getLength</li><li>得到size后，我们从链表第一个开始遍历<code>(size-index)</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static PersonNode findLastIndexNode(PersonNode head, int index)&#123;    if (head.next &#x3D;&#x3D; null)        return null;    int size &#x3D; getlength(head);&#x2F;&#x2F;第一次遍历，获取链表大小    if (index &lt;&#x3D; 0 || index &gt; size)&#x2F;&#x2F;判断倒数的序号是否超出容量        return null;    PersonNode current &#x3D; head.next;    for (int i &#x3D; 0; i &lt; size - index; i++) &#123;        current &#x3D; current.next;&#x2F;&#x2F;遍历size-index次    &#125;    return current;&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">PersonNode res &#x3D; findLastIndexNode(list.getHead(), 1);System.out.println(res);</code></pre><h4 id="单链表反转腾讯">单链表反转(腾讯)</h4><p>思路</p><ul><li>先定义一个结点<code>reverseHead = new PersonNode();</code></li><li>从头到尾遍历原来的链表，每遍历一个链表，就将其取出，放在新链表最前端</li><li>原来链表的<code>head.next = reverseHead.next;</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void reverseList(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)        return;    &#x2F;&#x2F; 定义一个辅助遍历，帮助遍历原来的链表    PersonNode current &#x3D; head.next;    PersonNode next &#x3D; null;&#x2F;&#x2F;指向当前结点[current]的下一个结点    PersonNode reverseHead &#x3D; new PersonNode(0, &quot;&quot;, 0);    while (current !&#x3D; null) &#123;        next &#x3D; current.next;&#x2F;&#x2F;先暂时保存当前结点的下一个结点，后面会用到        current.next &#x3D; reverseHead.next;&#x2F;&#x2F;把current的下一个结点指向新链表最前端        reverseHead.next &#x3D; current;&#x2F;&#x2F;将current连接到新链表        current &#x3D; next;&#x2F;&#x2F;让current后移&#x2F;*每一次循环，reverseHead.next都会按照原链表的顺序定位到current，遍历结束，刚到reverseHead.next定位到链表最后一个，此时把reverseHead.next地址赋给head.next，这样就可以倒着来遍历链表*&#x2F;    &#125;    head.next &#x3D; reverseHead.next;&#x2F;&#x2F;头结点拼接，实现反转&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">reverseList(list.getHead());list.list();</code></pre><h4 id="从尾到头打印单链表百度">从尾到头打印单链表(百度)</h4><p>思路</p><ul><li>1.先反转后再打印(有个问题：只要求逆序打印，不要求反转，这样会破坏原链表结构)</li><li>2.用栈的方法，利用栈先进后出的特点，实现逆序打印的效果</li></ul><blockquote><p><code>stack.java</code></p></blockquote><p>下面是栈的实例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Stack;public class stack&#123;    public static void main(String[] args)&#123;        Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();        stack.add(&quot;James&quot;);        stack.add(&quot;Kboe&quot;);        stack.add(&quot;Jordan&quot;);        while(stack.size() &gt; 0)&#123;            System.out.println(stack.pop());        &#125;    &#125;&#125;</code></pre><p>用栈的方法实现从头到尾打印单链表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void reversePrint(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null)        return;    &#x2F;&#x2F;创建一个栈，将各个结点压入栈    Stack&lt;PersonNode&gt; stack &#x3D; new Stack&lt;PersonNode&gt;();    PersonNode current &#x3D; head.next;    while (current !&#x3D; null) &#123;        stack.push(current);        current &#x3D; current.next;    &#125;    while (stack.size() &gt; 0) &#123;        System.out.println(stack.pop());    &#125;&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">reversePrint(list.getHead());</code></pre>]]></content>
    
    
    <summary type="html">Java版的链表</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组和队列(数组)</title>
    <link href="https://jaydenchang.top/post/0x001F.html"/>
    <id>https://jaydenchang.top/post/0x001F.html</id>
    <published>2021-08-05T16:00:00.000Z</published>
    <updated>2021-12-11T06:06:16.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="稀疏数组">稀疏数组</h3><p>当一个数组中大部分元素是0时，或者为同一个值的数组时，可以用稀疏数组来保存该数组，节省储存空间(二维数组储存太浪费空间了)</p><!--more>应用场景- 五子棋、围棋记录黑白子，无占位处记为0，黑白分别记为1，2- 扫雷- 象棋类，跳棋等处理方法：- 记录数组有几行几列，有多少个不同的值- 把有不同值的元素的行列及值记录在一个小规模的数组里，从而缩小程序的规模二维数组转化稀疏数组的思路- 遍历原始二维数组，得到有效数据的个数- 根据sum就可以创建稀疏数组 `int spareseArr[sum + 1][3]`- 将二维数组的有效数据的个数sum存入稀疏数组稀疏数组转原始二维数组- 先读稀疏数组第一行，根据第一行数据创建原始二维数组- 在读取稀疏数组后几行的数据，并赋予原始的二维数组`int originArr[size][size]`即可#### 代码<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;spareseArray.javaimport java.util.Scanner;public class spareseArray&#123;    public static void main(String[] args)&#123;        public static void main(String[] args) &#123;        Scanner scan &#x3D; new Scanner(System.in);        int size &#x3D; scan.nextInt();        scan.close();        int chessArr[][] &#x3D; new int[size][size];&#x2F;&#x2F;创建一个11*11的棋盘        chessArr[1][2] &#x3D; 1;        chessArr[2][3] &#x3D; 2;        chessArr[4][6] &#x3D; 1;        int sum &#x3D; 0;        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                if (chessArr[i][j] !&#x3D; 0)                    sum++;            &#125;        &#125;        &#x2F;&#x2F;创建稀疏数组        int spareseArr[][] &#x3D; new int[sum + 1][3];        &#x2F;&#x2F;给稀疏数组赋值        spareseArr[0][0] &#x3D; size;        spareseArr[0][1] &#x3D; size;        spareseArr[0][2] &#x3D; sum;        &#x2F;&#x2F;遍历二维数组，把非0的值存放在稀疏数组中        int count &#x3D; 0;&#x2F;&#x2F;计数器，记录非0数据个数        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                if (chessArr[i][j] !&#x3D; 0) &#123;                    count++;                    spareseArr[count][0] &#x3D; i;                    spareseArr[count][1] &#x3D; j;                    spareseArr[count][2] &#x3D; chessArr[i][j];                &#125;            &#125;        &#125;        &#x2F;&#x2F;输出稀疏数组的形式        System.out.println(&quot;the sparese Array:&quot;);        for (int i &#x3D; 0; i &lt; sum + 1; i++) &#123;            System.out.printf(&quot;%d %d %d\n&quot;, spareseArr[i][0], spareseArr[i][1], spareseArr[i][2]);        &#125;        &#x2F;&#x2F;稀疏数组恢复二维数组        int originArr[][] &#x3D; new int[spareseArr[0][0]][spareseArr[0][1]];        &#x2F;&#x2F;输出恢复后的二维数组        for (int i &#x3D; 1; i &lt; spareseArr.length; i++) &#123;            originArr[spareseArr[i][0]][spareseArr[i][1]] &#x3D; spareseArr[i][2];        &#125;        System.out.println(&quot;the origin array:&quot;);        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                System.out.print(originArr[i][j] + &quot; &quot;);            &#125;            System.out.println();        &#125;        &#125;&#125;</code></pre><p>参考链接：<a href='https://www.bilibili.com/video/BV1E4411H73v?from=search&seid=10722391219764061578'>尚硅谷--Java数据结构p7-p9  bilibili</a></p><h3 id="队列数组">队列(数组)</h3><p>队列是一个有序列表，可以用数组或者链表来实现。遵循先入先出原则，这一部分用数组来模拟</p><p>应用场景：银行排队案例</p><p>队列本身是有序列表，需要两个变量front和rear分别标记队列前后端，front随着数据输出而改变，rear随着数据输入而改变。还有需要一个maxSize来标记队列的最大容量。</p><p>当存数据入列时</p><ul><li>把尾指针后移：rear+1，当front=rear [ 空 ]</li><li>若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。<code>rear == maxSize-1</code> =&gt; 队列满</li></ul><h4 id="代码">代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;import java.util.Scanner;public class Queue &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;创建一个队列        ArrayQueue queue &#x3D; new ArrayQueue(3);        char key &#x3D; &#39; &#39;;        Scanner scan &#x3D; new Scanner(System.in);        boolean loop &#x3D; true;        &#x2F;&#x2F;输出一个菜单        while (loop) &#123;            System.out.println(&quot;s(show queue)&quot;);            System.out.println(&quot;e(exit)&quot;);            System.out.println(&quot;a(add)&quot;);            System.out.println(&quot;g(get)&quot;);            System.out.println(&quot;h(head)&quot;);            key &#x3D; scan.next().charAt(0);            switch (key) &#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;output a num:&quot;);                    int value &#x3D; scan.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.printf(&quot;get the num is: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                        break;                    &#125;                    break;                case &#39;h&#39;:                    &#x2F;&#x2F;查看队列头数据                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.printf(&quot;head data: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:&#x2F;&#x2F;退出                    scan.close();                    loop &#x3D; false;&#x2F;&#x2F;退出while循环                    break;                default:                    break;            &#125;        &#125;    &#125;&#125;class ArrayQueue &#123;    private int maxSize;&#x2F;&#x2F;数组最大容量    private int front;&#x2F;&#x2F;队列头    private int rear;&#x2F;&#x2F;队列尾    private int[] arr;&#x2F;&#x2F;该数组用于存放数据，模拟队列    &#x2F;&#x2F;创建队列的构造器    public ArrayQueue(int arrMaxSize) &#123;        maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];        front &#x3D; -1;&#x2F;&#x2F;指向队列头部，指向数据头部前一个位置        rear &#x3D; -1;&#x2F;&#x2F;指向队列尾，指向队列尾的数据(即队列最后一个数据)    &#125;    &#x2F;&#x2F;判断队列是否满    public boolean isFull() &#123;        return rear &#x3D;&#x3D; maxSize - 1;    &#125;    &#x2F;&#x2F;判断队列是否空    public boolean isEmpty() &#123;        return rear &#x3D;&#x3D; front;    &#125;    &#x2F;&#x2F;添加数据到队列    public void addQueue(int n) &#123;        &#x2F;&#x2F;判断队列是否满        if (isFull()) &#123;            System.out.println(&quot;the queue is full~~&quot;);            return;        &#125;        &#x2F;&#x2F;rear++;&#x2F;&#x2F;rear后移        &#x2F;&#x2F;arr[rear] &#x3D; n;        arr[++rear] &#x3D; n;&#x2F;&#x2F;这是上两行代码简写    &#125;    &#x2F;&#x2F;获取队列数据，出队列    public int getQueue() &#123;        &#x2F;&#x2F;判断是否为空        if (isEmpty()) &#123;            &#x2F;&#x2F;抛出异常            throw new RuntimeException(&quot;empty queue~~&quot;);        &#125;        front++;        return arr[front];    &#125;    &#x2F;&#x2F;显示队列所有数据    public void showQueue() &#123;        if (isEmpty()) &#123;            System.out.println(&quot;empty queue~~&quot;);            return;        &#125;        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i, arr[i]);        &#125;    &#125;    &#x2F;&#x2F;显示队列的头数据，不是取出数据    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty queue~~&quot;);        &#125;        return arr[front + 1];&#x2F;&#x2F;使front指向头数据    &#125;&#125;</code></pre><p>缺点：</p><ul><li>数组只能用一次</li></ul><p>优化：</p><ul><li>改进成为环形队列 算法思想：取模%</li></ul><h3 id="数组模拟环形队列">数组模拟环形队列</h3><p>思路：</p><ul><li>front变量含义做一个调整：front指向队列第一个元素，也就是<code>arr[front]</code>就是队列第一个元素</li><li>rear变量含义做一个调整：rear指向队列最后一个元素的后一个位置。留出一个空间来判断队列是空或满</li><li>当队列满时，条件是：<code>(rear+1)&amp;maxSize == front</code> =&gt;队列满</li></ul><p>队列中有效数据的个数 <code>(rear + maxSize - front) % maxSize</code></p><h4 id="代码-1">代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class CircleArrayQueue &#123;    public static void main(String[] args) &#123;        CircleArray queue &#x3D; new CircleArray(4);&#x2F;&#x2F;队列有效数据是3        char key &#x3D; &#39; &#39;;        Scanner scan &#x3D; new Scanner(System.in);        boolean loop &#x3D; true;        &#x2F;&#x2F;输出一个菜单        while (loop) &#123;            System.out.println(&quot;s(show queue)&quot;);            System.out.println(&quot;e(exit)&quot;);            System.out.println(&quot;a(add)&quot;);            System.out.println(&quot;g(get)&quot;);            System.out.println(&quot;h(head)&quot;);            key &#x3D; scan.next().charAt(0);            switch (key) &#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;output a num:&quot;);                    int value &#x3D; scan.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.printf(&quot;get the num is: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                        break;                    &#125;                    break;                case &#39;h&#39;:                    &#x2F;&#x2F;查看队列头数据                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.printf(&quot;head data: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:                    scan.close();                    loop &#x3D; false;                    break;                default:                    break;            &#125;        &#125;    &#125;&#125;class CircleArray &#123;    private int maxSize;&#x2F;&#x2F;数组最大容量    private int front;&#x2F;&#x2F;队列头，队列的第一个元素，不一定是0    private int rear;&#x2F;&#x2F;队列尾    private int[] arr;&#x2F;&#x2F;该数组用于存放数据，模拟队列    public CircleArray(int arrMaxSize) &#123;        maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];        front &#x3D; 0;        rear &#x3D; 0;    &#125;    public boolean isFull() &#123;        return (rear + 1) % maxSize &#x3D;&#x3D; front;&#x2F;&#x2F;+1是利用了留出的空位来判断队列是否为满    &#125;    public boolean isEmpty() &#123;        return rear &#x3D;&#x3D; front;&#x2F;&#x2F;初始化时rear和front都是0，如果没有add，即可判断为空    &#125;    public void addQueue(int n) &#123;        if (isFull()) &#123;            System.out.println(&quot;full array~~&quot;);            return;        &#125;        arr[rear] &#x3D; n;&#x2F;&#x2F;直接把n赋给arr        rear &#x3D; (rear + 1) % maxSize;&#x2F;&#x2F;考虑取模    &#125;    public int getQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty array~~&quot;);        &#125;        &#x2F;&#x2F;这里要分析出front是指向队列的第一个元素        &#x2F;&#x2F;1.先把front对应的值保留到一个临时变量        &#x2F;&#x2F;2.把front后移        &#x2F;&#x2F;3.把临时保存的变量返回        int value &#x3D; arr[front];            front &#x3D; (front + 1) % maxSize;        return value;    &#125;    public void showQueue() &#123;        if (isEmpty()) &#123;            System.out.println(&quot;empty array~~&quot;);            return;        &#125;        for (int i &#x3D; front; i &lt; front + size(); i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i % maxSize, arr[i % maxSize]);        &#125;    &#125;    &#x2F;&#x2F;求出当前队列有效数据个数    public int size() &#123;        return (rear + maxSize - front) % maxSize;    &#125;    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty array~~&quot;);        &#125;        return arr[front];    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">简单记录稀疏数组的用法</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>js简单实现拦截访问指定网页</title>
    <link href="https://jaydenchang.top/post/0x001E.html"/>
    <id>https://jaydenchang.top/post/0x001E.html</id>
    <published>2021-08-03T16:00:00.000Z</published>
    <updated>2021-12-11T06:06:47.305Z</updated>
    
    <content type="html"><![CDATA[<p>最近闲的无事，写个脚本玩玩，实现拦截访问指定网址</p><h3 id="浏览器插件">浏览器插件</h3><p>要想实现这个功能，就要自定义一个浏览器插件</p><p>最简单的浏览器插件有两个文件，分别是<code>manifest.json</code>和<code>**.js</code>。首先新建一个文件夹，然后在文件夹目录新建上述两个文件。</p><h4 id="manifest.json"><code>manifest.json</code></h4><p><a href='https://ask.dcloud.net.cn/article/94'> <code>manifest.json</code> </a>是插件的配置文件，用于描述插件的元数据，插件的配置信息</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;name&quot;: &quot;hello&quot;,    &quot;description&quot;: &quot;hello&quot;,    &quot;version&quot;: &quot;1.0&quot;,    &quot;manifest_version&quot;: 2,    &quot;content_scripts&quot;: [&#123;        &quot;matches&quot;: [            &#39;http:&#x2F;&#x2F;*&#x2F;*&#39;, &quot;https:&#x2F;&#x2F;*&#x2F;*&quot;        ],        &quot;js&quot;: [            &quot;test.js&quot;        ]    &#125;]&#125;</code></pre><p>这里的matches通配http和https，js对应的文件名一定要和自己命名的js相同(包括路径)</p><h4 id="test.js"><code>test.js</code></h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">var url;url &#x3D; window.location.host;&#x2F;&#x2F;获取当前网页urlif(url &#x3D;&#x3D; &#39;www.google.com.hk&#39; || url &#x3D;&#x3D; &#39;www.google.com&#39;)&#123;    alert(&quot;反正你就是打不开这个页面doge&quot;);    window.location.href &#x3D; &#39;cn.bing.com&#39;;&#x2F;&#x2F;跳转到指定页面&#125;</code></pre><h3 id="怎么使用">怎么使用</h3><p>edge用户在浏览器输入<code>edge://extensions</code>，chrome用户在浏览器输入<code>chrome://extensions</code> <del>(其他浏览器没用过)</del> ，然后把刚才装json和js的文件夹拖动到刚才打开的页面，重启浏览器就好了。</p>]]></content>
    
    
    <summary type="html">写了一个脚本来拦截网页</summary>
    
    
    
    <category term="FrontEnd" scheme="https://jaydenchang.top/categories/FrontEnd/"/>
    
    
    <category term="JavaScript" scheme="https://jaydenchang.top/tags/JavaScript/"/>
    
    <category term="技术" scheme="https://jaydenchang.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>练字时我在想什么</title>
    <link href="https://jaydenchang.top/post/0x001C.html"/>
    <id>https://jaydenchang.top/post/0x001C.html</id>
    <published>2021-07-19T16:00:00.000Z</published>
    <updated>2021-12-11T06:07:22.127Z</updated>
    
    <content type="html"><![CDATA[<p>最近几天在练字，在练字时，脑子里有些奇怪的想法，趁着现在有时间，把自己的想法记录下</p><h4 id="小学">小学</h4><p>犹记得是在四年级时，我看着爸妈、老师写连笔字很帅，于是也自己尝试写，就在我开始写连笔字的第二天，班主任发现不对，马上私信我爸妈，在我爸妈的连哄带骗下，我开始练字，练的啥呢，正楷，每天中午放学回家恰饭前就拿出字帖来练，字帖嘛，照着描，当时我给老师看了，嗯，写出来还是不错的，当字帖换成作业本时，他傻了，差点嘴吐芬芳，于是我又开始练字，就这样我练到了小学毕业，感觉也没什么长进，写出来有时候我都不知道自己在写啥 (<del>年代久远，小学的作业本找不到就不放图了</del>)</p><h4 id="初中">初中</h4><p>刚进班级，我的班主任就注意到了我的字，马上找我和我爸妈谈话，毕竟我现在的字在中考上很吃亏，不过班主任没有让我去练正楷，让我去学一点行楷。好在我初中老师和我一些同学的字都比较好看，我时不时去模仿他们的字迹。</p><p>在初二时，我偶然知道，井柏然的字很好看，于是我去搜索他的微博，我勒个去，这是神仙写的字吧</p><p><a href='https://weibo.com/boranjing?is_all=1&is_search=1&key_word=手写'>井柏然的微博--#手写微博</a></p><p>正巧，当时小米收录了井柏然的字，我咬咬牙，省了几天生活费，买了下来装到手机上，在此之后我的字和以前有一些不一样了，虽然带有一点点点文艺范，但字本质上还是很潦草，特别是是写语文和政治时，心疼改卷老师φ(゜▽゜*)♪</p><p><del>(感觉也找不到以前的作业本了)</del></p><h4 id="高中">高中</h4><p>让我的字开始定型是在我高一文理分科时，我注意到了我舍友的字，哎呀word麻鸭，这恰到好处的布局，word麻鸭，这刚劲有力的笔锋，word麻鸭，这行云流水的笔顺……真是妙到了米奇妙妙屋</p><p>放一张我高一的字</p><p><img src='https://jaydenchang.gitee.io/images/images/0x001C-1.jpg' style="border-radius: 5em; zoom: 20%;"></p><p>当时的我，觉得自己写的比初中好些了，不过，每到语文考试40min极限作文时，我的字又打回原形。</p><p>大概是在高三吧，那时候我开始写日记，经常和我舍友交流问题，两人在讨论过程就开始练字，在这个阶段了，我的字又有了质的飞跃<del>(感觉也就那样)</del>。</p><h4 id="大学">大学</h4><p>大学里，关于练字这个话题，我身边比较少有人练字，都程序员了，练什么字，敲代码不香吗。曾经我试过3天没摸笔，果然，提笔忘字，这让我很是头疼，没办法，只能减少打代码时间，每天抽出10分钟写点字。然后就是大一下的思想汇报，写了大概几千字吧，是一个很好的练字机会，很庆幸当时自己能把自己摁下来乖乖一笔一划写好每个字<del>(有错字整页无了)</del>。</p><p>大一暑假，终于有时间练字了，还是照着井柏然的微博来练，坐在书桌前，听着周杰伦和林俊杰的歌，一笔一划，有种坐在咖啡厅里的感觉。</p><p><img src='https://jaydenchang.gitee.io/images/images/0x001C-2.jpg' style='border-radius:5em;zoom:20%;border-color:lightskyblue;'></p><p><img src='https://jaydenchang.gitee.io/images/images/0x001C-3.jpg' style='border-radius:5em;zoom:20%;border-color:lightskyblue;'></p><p>练字也有一周了，练字时我在想什么呢，答案是，什么也没想，看着别人的字，自己一笔一划照着写一遍，那种成就感、新鲜感无法形容，另外再配上林俊杰的歌，那环境简直惬意到起飞，那段时间，也是最容易迸发灵感的。</p><p>截止要到截稿时，我再回过头去看看我前几天写的字，突然感觉也没那么好看了，人嘛，就是在这样不断批判以前的自己中成长，寻之错并改之。练字真的是非常畅快的体验<del>(前提是内心要平静)</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近几天在练字，在练字时，脑子里有些奇怪的想法，趁着现在有时间，把自己的想法记录下&lt;/p&gt;
&lt;h4 id=&quot;小学&quot;&gt;小学&lt;/h4&gt;
&lt;p&gt;犹记得是在四年级时，我看着爸妈、老师写连笔字很帅，于是也自己尝试写，就在我开始写连笔字的第二天，班主任发现不对，马上私信我爸妈，在我</summary>
      
    
    
    
    <category term="随笔" scheme="https://jaydenchang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://jaydenchang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
