<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jayden&#39;s Blog</title>
  
  
  <link href="https://jaydenchang.top/atom.xml" rel="self"/>
  
  <link href="https://jaydenchang.top/"/>
  <updated>2022-10-17T02:37:39.916Z</updated>
  <id>https://jaydenchang.top/</id>
  
  <author>
    <name>Jayden Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动手写RPC框架</title>
    <link href="https://jaydenchang.top/post/0x0031.html"/>
    <id>https://jaydenchang.top/post/0x0031.html</id>
    <published>2022-10-15T16:00:00.000Z</published>
    <updated>2022-10-17T02:37:39.916Z</updated>
    
    <content type="html"><![CDATA[<hr/><p>本文学习自<a href="https://geetktutu.com">geektutu</a> , 大部分内容摘自 <a href="https://geektutu.com/post/geerpc.html">7天用Go从零实现RPC框架GeeRPC | 极客兔兔 (geektutu.com)</a>，并在此基础上稍加个人的学习经历和理解</p><p>作者仓库地址：<a href="https://github.com/geektutu/7days-golang">geektutu/7days-golang: 7 days golang programs from scratch (web framework Gee, distributed cache GeeCache, object relational mapping ORM framework GeeORM, rpc framework GeeRPC etc) 7天用Go动手写/从零实现系列 (github.com)</a></p><h3 id="day0.-浅谈rpc框架">day0. 浅谈RPC框架</h3><p>前几天在学 6.824 时，发现有太多内容是我完全没接触过的，然后其中涉及到 RPC 的内容又比较多，忽然想起 geektutu 出过 "七天实现 RPC 框架" 的文章，马上转坑来学习。</p><h4 id="谈谈rpc框架">1. 谈谈RPC框架</h4><p>RPC (Remote Procedure Call，远程过程调用) 是一种计算机通信协议，允许调用不同进程空间的程序。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部实现的细节。</p><p>不同应用程序间的通信方式有很多，例如浏览器和服务器间广泛用基于 HTTP协议的 Restful API。与 RPC相比，Restful API 有相对统一的标准，因而更通用，兼容性更好，支持不同的语言。HTTP 协议是基于文本的，一般具备更好的可读性。但是缺点也很明显：</p><ul><li>Restful 接口要额外的定义，无论是客户端还是服务端，都需要额外的代码来处理，而 RPC 调用则更接近于直接调用。</li><li>基于 HTTP 协议的 Restful 报文冗余，承载了过多无效信息，而RPC 通常使用自定义的协议格式，减少冗余报文。</li><li>RPC 可以采用更高效的序列化协议，将文本转为二进制传输，获得更高的性能。</li><li>因为 RPC 的灵活性，所以更容易扩展和集成诸如注册中心，负载均衡等功能。</li></ul><h4 id="rpc框架需要解决什么问题">2. RPC框架需要解决什么问题</h4><p>RPC 需要解决什么问题？或者换个说法，为什么要RPC 框架？</p><p>我们可以想象下两台机器上，两个程序之间要通信，那么首先，需要确定采用的传输协议是什么？如果这两个程序位于不同的机器，那么一般会选择 TCP 协议活 HTTP 协议；那如果两个程序位于相同的机器，也可以选择 Unix Socket 协议。传输协议确定后，还需要确定报文的编码格式，比如采用最常用的json 或xml，那如果报文比较大，还可能会选择 protobuf 等其他的编码方式，甚至编码之后，再进行压缩。接收端获取报文则需要相反的过程，先解压再解码。</p><p>解决了传输协议和保温编码的问题，接下来还需要解决一系列的可用性问题，例如，连接超时了怎么办？是否支持异步请求和并发？</p><p>如果服务端的实例很多，客户端并不关心这些实例的地址和部署位置，只关心自己能否获取到期待的结果，那就引出了注册中心 (registry) 和负载均衡 (load balance) 的问题。简单地说，即客户端和服务端相互不感知对方的存在，服务端启动时将自己注册到注册中心，客户端调用时，从注册中心获取到所有可用的实例，选择一个来调用。这样服务端和客户端只需要感知注册中心的存在就够了。注册中心还需要实现服务动态添加，删除，使用 "心跳机制" 确保服务处于可用状态等功能。</p><p>再进一步，假设服务端是不同的团队提供的，如果没有统一的RPC 框架，各个团队的服务提供方就需要各自实现一套消息编解码，连接池，收发线程，超时处理等 "业务之外" 的重复技术劳动，造成整体的低效。因此，"业务之外" 的这部分公共的能力，即是RPC 框架所需要具备的能力。</p><h3 id="day1.-服务端与消息编码">day1. 服务端与消息编码</h3><ul><li>使用<code>encoding/gob</code>实现消息的编解码 (序列化与反序列化)。</li><li>实现一个简易的服务端，仅接受消息，不处理，代码约200行。</li></ul><h4 id="消息的序列化与反序列化">消息的序列化与反序列化</h4><p>一个典型的RPC 调用如下</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">err &#x3D; client.call(&quot;Arith.Multiply&quot;, args, &amp;reply)</code></pre><p>客户端发送的请求包括服务名<code>Arith</code>，方法名<code>Multiply</code>，参数<code>args</code>三个，服务端的响应包括错误<code>error</code>，返回值<code>reply</code> 2个。我们将请求和响应中的参数和返回值抽象为 body，剩余的信息放在 header 中，那么就可以抽象出数据结构 Header：</p><p><strong>day1/codec/codec.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package codecimport &quot;io&quot;type Header struct &#123;    ServiceMethod string &#x2F;&#x2F; format &quot;Service.Method&quot;    Seq           string &#x2F;&#x2F; sequence number chosen by client    Error         string&#125;</code></pre><ul><li>ServiceMethod 是服务名和方法名，通常与 Golang 中的结构体和方法相映射。</li><li>Seq 是请求的序号，也可以认为是某个请求的 ID，用来区分不同的请求。</li><li>Error 是错误信息，客户端设置为空，</li></ul><p>我们将和消息编解码相关的代码都放到 codec 子目录中，在此之前，还需要在geerpc项目根目录下使用 <code>go mod init geerpc</code> 初始化项目，方便后续子 package 之间的引用。</p><p>进一步，抽象出对消息体进行编解码的接口 Codec，抽象出接口是为了实现不同的 Codec 实例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Codec interface &#123;    io.Closer    ReadHeader(*Header) error    ReadBody(interface&#123;&#125;) error    Write(*Header, interface&#123;&#125;) error&#125;</code></pre><p>紧接着，抽象出 Codec 的构造函数，客户端和服务端可以通过 Codec 的<code>Type</code>得到构造函数，从而创建 Codec 实例。这部分代码和工厂模式类似，与工厂模式不同的是，返回的是构造函数，而非实例。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type NewCodecFunc func(io.ReadWriteCloser) Codec type Type stringconst (GobType  Type &#x3D; &quot;application&#x2F;gob&quot;    JsonType Type &#x3D; &quot;application&#x2F;json&quot;)var NewCodecFuncMap map[Type]NewCodecFuncfunc init() &#123;    NewCodecFuncMap &#x3D; make(map[Type]NewCodecFunc)    NewCodecFuncMap[GobType] &#x3D; NewGobCodec &#x2F;&#x2F; 初始化map，实例化一个GobCodec对象&#125;</code></pre><p>我们定义了两种 Codec，<code>Gob</code>和<code>Json</code>，但是实际代码只实现了<code>Gob</code>一种，事实上，2者的实现非常接近，甚至只需把<code>gob</code>换成<code>json</code>即可。</p><p>首先定义<code>GobCodec</code>结构体，这个结构体由四部分构成，<code>conn</code>是由构建函数传入，通常是通过 TCP 或者 Unix 建立 socket 时得到的链接实例，dec 和 enc 对应 gob的 Decoder 和 Encoder，buf 是为了防止阻塞而创建的带缓冲的<code>Writer</code>，一般这么做都能提升性能。</p><p><strong>day1/codec/gob.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package codecimport (    &quot;bufio&quot;    &quot;encoding&#x2F;gob&quot;    &quot;io&quot;    &quot;log&quot;)type GobCodec struct &#123;    conn io.ReadWriteCloser    buf  *bufio.Writer    dec  *gob.Decoder    enc  *gob.Encoder&#125;var _ Codec &#x3D; (*GobCodec)(nil)&#x2F;&#x2F; 这里的写法的含义是，用来检测GobCodec是否实现了Codec接口，如果没有实现该接口则编译报错func NewGobCodec(conn io.ReadWriteCloser) Codec &#123;    buf :&#x3D; bufio.NewWriter(conn)    return &amp;GobCodec &#123;        conn: conn,        buf:  buf,        dec:  gob.NewDecoder(conn),        enc:  gob.NewEncoder(buf),    &#125;&#125;</code></pre><p>接着实现<code>ReadHeader</code>，<code>ReadBody</code>，<code>Write</code>和<code>Close</code>方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (c *GobCodec) ReadHeader(h *Header) error &#123;    return c.dec.Decode(h)&#125;func (c *GobCodec) ReadBody(body interface&#123;&#125;) error &#123;    return c.dec.Decode(body)&#125;func (c *GobCodec) Write(h *Header, body interface&#123;&#125;) (err error) &#123;    defer func() &#123;        _ &#x3D; c.buf.Flush() &#x2F;&#x2F; 将缓存区内容写入文件，返回类型为error         if err !&#x3D; nil &#123;            _ &#x3D; c.Close()        &#125;    &#125;()    if err !&#x3D; c.enc.Encode(h); err !&#x3D; nil &#123;        log.Println(&quot;rpc codec: gob error encoding header:&quot;, err)        return err    &#125;    if err :&#x3D; c.enc.Encode(body); err !&#x3D; nil &#123;        log.Println(&quot;rpc codec: gob error encoding body:&quot;, err)        return err    &#125;    return nil&#125;func (c *GobCodec) Close() error &#123;    return c.conn.Close() &#x2F;&#x2F; 返回一个err，具体的Close()在io.go中有重写&#125;</code></pre><h4 id="通信过程">通信过程</h4><p>客户端与服务端的通信需要协商一些内容，例如 HTTP 报文，分为 header 和 body 两部分，body 的格式和长度通过 header 中的<code>Content-Type</code>和<code>Content-Length</code>指定，服务端通过解析 header 就能够知道如何从 body 中读取需要的信息。对于RPC 协议来说，这部分协商是需要自主设计的。为了提升性能，一般在报文的最开始会规划固定的字节，来协商相关的信息。比如第1个字节用来表示序列化方式，第2个字节表示压缩方式，第3-6字节表示 header 的长度，7-10字节表示body 长度。</p><p>对于 GeeRPC 来说，目前需要协商的唯一一项内容时消息的编解码方式。我们将这部分信息，放到结构体<code>Option</code>中承载。目前，已经进入到服务端的实现阶段了。</p><p><strong>day1/server.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package geerpcconst MagicNumber &#x3D; 0x23bef5ctype Option struct &#123;    MagicNumber int        &#x2F;&#x2F; MagicNumber marks this&#39;s a geerpc request    CodecType   codec.Type &#x2F;&#x2F; client may choose different Codec to encode body&#125;var DefaultOption &#x3D; &amp;Option &#123;    MagicNumber: MagicNumber,    CodecType:   codec.GobType,&#125;</code></pre><p>一般来说，设计协商协议的这部分信息，需要设计固定的字节来传输。但是为了实现上更简单， GeeRPC 客户端固定采用 JSON 编码 Option，后续的 header 和 body 的编码方式由 Option 中的 CodeType指定，服务端首先使用 JSON 解码 Option，然后通过 Option 的 CodeType 解码剩余内容。即报文将以这样的形式发送：</p><pre class="line-numbers language-none"><code class="language-none">| Option&#123;MagicNumber: xxx, CodecType: xxx&#125; | Header&#123;ServiceMethod ...&#125; | Body interface&#123;&#125; || &lt;-------    固定 JSON 编码       -------&gt; | &lt;--------  编码方式由 CodeType决定   -------&gt; |</code></pre><p>在一次连接中，Option 固定在报文的最开始，Header 和 Body 可以有很多个，即报文可能是这样的。</p><pre class="line-numbers language-none"><code class="language-none">| Option | Header1 | Body1 | Header2 | Body2 | ...</code></pre><h4 id="服务端的实现">服务端的实现</h4><p>通信过程已经定义清楚了，那么服务端的实现就比较直接了。</p><p><strong>day1/server.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Server represents an RPC Server.type Server struct&#123;&#125;&#x2F;&#x2F; NewServer returns a new Server.func NewServer() *Server &#123;    return &amp;Server&#123;&#125;&#125;&#x2F;&#x2F; DefaultServer is the default instance of *Servervar DefaultServer &#x3D; NewServer()&#x2F;&#x2F; Acccept accepts connections on the listener and serves requests&#x2F;&#x2F; for each incoming connectionfunc (server *Server) Accept(lis net.Listener) &#123;    &#x2F;&#x2F; for循环等待socket连接建立    for &#123;        conn, err :&#x3D; lis.Accept()        if err !&#x3D; nil &#123;            log.Println(&quot;rpc server: accept error:&quot;, err)            return         &#125;        go server.ServeConn(conn)    &#125;&#125;&#x2F;&#x2F; Accept accepts connections on the listener and serves requests&#x2F;&#x2F; for each incoming connectionfunc Accept(lis net.Listener) &#123;    DefaultServer.Accept(lis)&#125;</code></pre><ul><li>首先定义了结构体<code>Server</code>，没有任何的成员字段。</li><li>实现了<code>Accept</code>方式，<code>net.Listener</code>作为参数，for 循环等待 socket 连接建立，并开启子协程处理，处理过程交给了<code>ServerConn</code>方法。</li><li>DefaultServer 是一个默认的<code>Server</code>实例，主要为了用户使用方便。</li></ul><p>如果想启动服务，过程是很简单的，传入 listener 即可，tcp 协议和 unix 协议都支持。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">lis, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:9999&quot;)geerpc.Accept(lis)</code></pre><p><code>ServeConn</code>的实现就和之前讨论的通信过程紧密相关了，首先使用<code>json.NewDecoder</code>反序列化得到 Option 实例，检查 MagicNumber 和 CodeType的值是否正确。然后根据 CodeType 得到对应的消息编解码器，接下来的处理就交给<code>serverCodec</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; ServeConn runs the serer on a single connection&#x2F;&#x2F; ServeConn blocks, serving the connection until the client hangs upfunc (server *Server) ServeConn(conn io.ReadWriteCloser) &#123;    defer func() &#123;        _ &#x3D; conn.Close()    &#125;()    if err :&#x3D; json.NewDecoder(conn).Decode(&amp;opt); err !&#x3D; nil &#123;        log.Println(&quot;rpc server: options error:&quot;, err)        return    &#125;    &#x2F;&#x2F; 检查Option的参数是否正确    if opt.MagicNumber !&#x3D; MagicNumber &#123;        log.Printf(&quot;rpc server: invalid magic number %x&quot;, opt.MagicNumber)        return    &#125;    f :&#x3D; codec.NewCodecFuncMap[opt.CodecType]    if f &#x3D;&#x3D; nil &#123;        log.Printf(&quot;rpc server: invalid codec type %s&quot;, opt.CdoecType)        return    &#125;    server.serveCodec(f(conn))&#125;&#x2F;&#x2F; invalidRequest is a placeholder for response argv when error occursvar invalidRequest &#x3D; struct&#123;&#125;&#123;&#125;&#x2F;&#x2F; 注意这里要改serveCodec的入参func (server *Server) serveCodec(cc codec.Codec, opt *Option) &#123;    sending :&#x3D; new(sync.Mutex) &#x2F;&#x2F; make sure to send a complete response    &#x2F;&#x2F; 加入一个互斥锁避免多个回复报文交织在一起    wg :&#x3D; new(sync.WaitGroup) &#x2F;&#x2F; wait until all request are handled    for &#123;        req, err :&#x3D; server.readRequest(cc) &#x2F;&#x2F; 读取请求        if err !&#x3D; nil &#123;            if req &#x3D;&#x3D; nil &#123;                break &#x2F;&#x2F; it&#39;s not possible to recover, so close the connection            &#125;            req.h.Error &#x3D; err.Error()            server.sendResponse(cc, req.h, invalidRequest, sending)            &#x2F;&#x2F; 回复请求            continue        &#125;        wg.Add(1)        go server.handleRequest(cc, req, sending, wg, opt.HandleTimeout)        &#x2F;&#x2F; 加入一个处理请求协程        &#x2F;&#x2F; 这里注意要新增一个超时时间    &#125;    wg.Wait()    _ &#x3D; cc.Close()&#125;</code></pre><p><code>serveCodec</code>的过程很简单，主要包含三阶段：</p><ul><li>读取请求 readRequest</li><li>处理请求 handleRequest</li><li>回复请求 sendRequest</li></ul><p>之前提到过，再一次连接中，允许收到多个请求，即多个 request header 和 request body，因此这里使用了 for 无限制地等待请求的到来，直到发生错误 (例如连接被关闭，接收到的报文有问题等)，这里需要注意的点有三个：</p><ul><li>handleRequest 使用了协程并发执行请求。</li><li>处理请求是并发的，但是回复请求的报文必须是逐个发送的，并发容易导致多个回复报文交织在一起，客户端无法解析。在这里使用锁 (sending) 保证。</li><li>尽力而为，只有在 header 解析失败时，才终止循环。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; request stores all infomation of a calltype request struct &#123;    h            *codec.Header &#x2F;&#x2F; header of request    argv, replyv reflect.Value &#x2F;&#x2F; argv and replyv of request    &#x2F;&#x2F; Value also is a struct&#125;func (server *Server) readRequestHeader(cc codec.Codec) (*codec.Header, error) &#123;    var h codec.Header    if err :&#x3D; cc.ReadHeader(&amp;h); err !&#x3D; nil &#123;        if err !&#x3D; io.EOF &amp;&amp; err !&#x3D; io.ErrUnexpectedEOF &#123;            log.Println(&quot;rpc server: read header error:&quot;, err)        &#125;        return nil, err    &#125;    return &amp;h, nil&#125;func (server *Server) readRequest(cc codec.Codec) (*request, error) &#123;    h, err :&#x3D; server.readRequestHeader(cc)    if err !&#x3D; nil &#123;        return nil, err    &#125;    req :&#x3D; &amp;reqeust&#123;h: h&#125;    &#x2F;&#x2F; TODO: now we don&#39;t know the type of request argv    &#x2F;&#x2F; day1, just suppose it&#39;s string    req.argv &#x3D; reflect.New(reflect.TypeOf(&quot;&quot;))    if err &#x3D; cc.ReadBody(req.argv.Interface()); err !&#x3D; nil &#123;        log.Println(&quot;rpc server: read argv err:&quot;, err)    &#125;    return req, nil&#125;func (server *Server) sendResponse(cc codec.Cdoec, h *codec.Header, body interface&#123;&#125;, sneding *sync.Mutex) &#123;    sending.Lock()    defer sending.Unlock()    if err :&#x3D; cc.Write(h, body); err !&#x3D; nil &#123;        log.Println(&quot;rpc server: write response error:&quot;, err)    &#125;&#125;func (server *Server) handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;    &#x2F;&#x2F; TODO, should call registered rpc methods to get the right replyv    &#x2F;&#x2F; day1, just print argv and send a hello message    defer wg.Done()    log.Println(req.h, req.argv.Elem())    req.replyv &#x3D; reflect.ValueOf(fmt.Sprintf(&quot;geerpc resp %d&quot;, req.h.Seq))    server.sendResponse(cc, req.h, req.replyv.Interface(), sending)&#125;</code></pre><p>目前还不能判断 body 的类型，因此在 readRequest 和 handleRequest 中，day1 将在 body作为字符串处理。接收到请求，打印 header，并回复<code>geerpc resp $&#123;req.h.Seq&#125;</code>。这一部分后续再实现。</p><h4 id="main-函数-一个简易的客户端">main 函数 (一个简易的客户端)</h4><p>day1 的内容就到此为止了，在这里我们已经实现了一个消息的编解码器<code>GobCodec</code>，并且客户端与服务端实现了简单的协议交换 (protocol exchange)，即允许客户端使用不同的编码方式。实现了服务端的雏形，建立连接，读取、处理并回复客户端的请求。</p><p>接下来，我们在 main 函数中看看如何使用刚实现的 GeeRPC。</p><p><strong>day1/main/main.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;encoding&#x2F;json&quot;    &quot;geerpc&quot;    &quot;geerpc&#x2F;codec&quot;    &quot;log&quot;    &quot;net&quot;    &quot;time&quot;)func startServer(addr chan string) &#123;    &#x2F;&#x2F; pick a free port    l, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)    if err !&#x3D; nil &#123;        log.Fatal(&quot;network error: &quot;, err)    &#125;    log.Println(&quot;start rpc server on&quot;, l.Addr())    addr &lt;- l.Addr().String()    geerpc.Accept(l) &#x2F;&#x2F; 注意这里是不是数字1，是字母l&#125;func main() &#123;    addr :&#x3D; make(chan string)    go startServer(addr)        &#x2F;&#x2F; in fact, following code is like a simple geerpc client    conn, _ :&#x3D; net.Dial(&quot;tcp&quot;, &lt;- addr)    defer func() &#123;        _ &#x3D; conn.Close()    &#125;()        time.Sleep(time.Second)    &#x2F;&#x2F; send options    _ &#x3D; json.NewEncoder(conn).Encode(geerpc.DefaultOption)    cc :&#x3D; codec.NewGobCodec(conn)    &#x2F;&#x2F; send request &amp; receive response    for i :&#x3D; 0; i &lt; 5; i++ &#123;        h :&#x3D; $codec.Header &#123;            ServiceMethod: &quot;Foo.Sum&quot;,            Seq:           uint64(i),        &#125;        _ &#x3D; cc.Write(h, fmt.Sprintf(&quot;geerpc req %d&quot;, h.Seq))        _ &#x3D; cc.ReadHeader(h)        var reply string        _ &#x3D; cc.ReadBody(&amp;reply)        log.Println(&quot;reply:&quot;, reply)    &#125;&#125;</code></pre><ul><li>在<code>startServer</code>中使用了信道<code>addr</code>，确保服务端端口监听成功，客户端再发起请求。</li><li>客户端首先发送<code>Option</code>进行协议交换，接下来发送消息头<code>h := &amp;codec.Header&#123;&#125;</code>，和消息体<code>geerpc req $&#123;h.Seq&#125;</code>。</li><li>最后解析服务端的相应<code>reply</code>，并打印出来。</li></ul><p>执行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">start rpc server on [::]63662&amp;&#123;Foo.Sum 0 &#125; geerpc req 0reply: geerpc resp 0&amp;&#123;Foo.Sum 1 &#125; geerpc req 1reply: geerpc resp 1&amp;&#123;Foo.Sum 2 &#125; geerpc req 2reply: geerpc resp 2&amp;&#123;Foo.Sum 3 &#125; geerpc req 3reply: geerpc resp 3&amp;&#123;Foo.Sum 4 &#125; geerpc req 4reply: geerpc resp 4</code></pre><h3 id="day2.-支持并发和异步的客户端">day2. 支持并发和异步的客户端</h3><h4 id="call-的设计">Call 的设计</h4><p>对<code>net/rpc</code>而言，一个函数需要能够被远程调用，需要满足如下五个条件：</p><ul><li>the method's type is exported</li><li>the method is exported</li><li>the method has two arguments, both exported (or builtin) types</li><li>the method's second arguments is a pointer</li><li>the method has return type error</li></ul><p>更直观一点：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (t *T) MethodName(argType T1, replyType *T2) error</code></pre><p>根据上述需求，首先我们封装了结构体 Call 来承载一次 RPC 调用所需要的信息。</p><p><strong>day2/client.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Call represents an active RPC type Call struct &#123;    Seq           uint64    ServiceMethod string      &#x2F;&#x2F; format &quot;&lt;service&gt;.&lt;method&gt;&quot;    Args          interface&#123;&#125; &#x2F;&#x2F; arguments to the function    Reply         interface&#123;&#125; &#x2F;&#x2F; reply from the fucntion    Error         error       &#x2F;&#x2F; if error occurs, it will be set    Done          chan *Call  &#x2F;&#x2F; Strobes when call is complete&#125; func (call *Call) done() &#123;    call.Done &lt;- call&#125;</code></pre><p>为了支持异步调用，Call 结构体中添加了一个字段 Done，Done 的类型是<code>chan *Call</code>，当调用结束时，会调用<code>call.done()</code>通知调用方。</p><h4 id="实现-client">实现 Client</h4><p>接下来，我们将实现 GeeRPC 客户端最核心的部分 Client。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Client represents an RPC Client&#x2F;&#x2F; There may be multipie outstanding Calls associated&#x2F;&#x2F; with a single Client, and a Client may be used by&#x2F;&#x2F; multipie goroutines simultaneouslytype Client struct &#123;    cc       codec.Codec    opt      *Option    sending  sync.Mutex &#x2F;&#x2F; protect following    header   codec.Header    mu       sync.Mutex &#x2F;&#x2F; protect following    seq      uint64    pending  map[uint64]*Call    closing  bool &#x2F;&#x2F; user has called Close    shutdown bool &#x2F;&#x2F; server has told us to stop&#125;var _ io.Closer &#x3D; (*Client)(nil)var ErrShutdown &#x3D; errors.New(&quot;connection is shut down&quot;)&#x2F;&#x2F; Close the connection func (client *Client) Close() error &#123;    client.mu.Lock()    defer client.mu.Unlock()    if client.closing &#123;        return ErrShutdown    &#125;    client.closing &#x3D; true    return client.cc.Close()&#125;&#x2F;&#x2F; IsAvaliable return true if the client does workfunc (client *Client) IsAvaliable() bool &#123;    client.mu.Lock()    defer client.mu.Unlock()    return !client.shutdown &amp;&amp; !client.closing&#125;</code></pre><p>client 的字段解析如下：</p><ul><li>cc 是消息的编解码器，和服务端类似，用来序列化将要发送出去的请求，以及反序列化接收到的响应。</li><li>sending 是一个互斥锁，和服务端类似，为了保证请求的有序发送，即防止出现多个请求报文混淆。</li><li>header 是每个请求的消息头，header 只有在请求发送时才需要，而请求发送是互斥的，因此每个客户端只需要一个，声明在 Client 结构体中可以复用。</li><li>seq 用于给发送的请求编号，每个请求有唯一编号。</li><li>pending 存储未处理完的请求，键是编号，值是 Call 实例。</li><li>closing 和 shutdown 任意一个值置为 true，则表示 Client 处于不可用的状态，但有些许的差别，closing 是用户主动关闭的，即调用<code>Close</code>方法，而 shutdown 置为 true 一般是有错误发生。</li></ul><p>紧接着，实现和 Call 相关的方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (client *Client) registerCall(call *Call) (uint64, error) &#123;    client.mu.Lock()    defer client.mu.Unlock()    if client.closing || client.shutdown &#123;        return 0, ErrShutdown    &#125;    call.Seq &#x3D; client.seq    client.pending[call.Seq] &#x3D; call    client.seq++    return call.Seq, nil&#125;func (client *Client) removeCall(seq uint64) *Call &#123;    client.mu.Lock()    defer client.mu.Unlock()    call :&#x3D; client.pending[seq]    delete(client.pending, seq)    return all&#125;func (client *Client) terminateCalls(err error) &#123;    client.sending.Lock()    defer client.sending.Unlock()    client.mu.Lock()    defer client.mu.Unlock()    client.shutdown &#x3D; true    for _, call :&#x3D; range client.pending &#123;        call.Error &#x3D; err        call.done()    &#125;&#125;</code></pre><ul><li>registerCall ：将参数 call 添加到 client.pending 中，并更新 client.seq。</li><li>removeCall：根据seq，从 client.pending 中移除对应的 call，并返回。</li><li>terminateCalls：服务端或客户端发生错误时调用，将 shutdown 设置为 true，且将错误信息通知所有 pending 状态的 call。</li></ul><p>对一个客户端来说，接收响应、发送请求是最重要的2个功能。那么首先实现接收功能，接收到的响应有三种情况：</p><ul><li>call 不存在，可能是请求没有发送完整，或者因为其他原因被取消，但是服务端仍旧处理了。</li><li>call 存在，但服务端处理出错，即 <code>h.Error</code>不为空。</li><li>call 存在，服务端处理正常，那么需要从 body 中读取 Reply 的值。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (client *Client) receive() &#123;    var err error    for err &#x3D;&#x3D; nil &#123;        var h codec.Header        if err &#x3D; client.cc.ReadHeader(&amp;h); err !&#x3D; nil &#123;            break        &#125;        call :&#x3D; client.removeCall(h.Seq)        switch &#123;        case call &#x3D;&#x3D; nil:            &#x2F;&#x2F; it usually means that Write partially failed            &#x2F;&#x2F; and call was already removed            arr :&#x3D; client.cc.ReadBody(nil)        case h.Error !&#x3D; &quot;&quot;:            call.Error &#x3D; fmt.Errorf(h.Error)            err &#x3D; client.cc.ReadBody(nil)            call.done()        default:            err &#x3D; client.cc.ReadBody(call.Reply)            if err !&#x3D; nil &#123;                call.Error &#x3D; errors.New(&quot;reading body &quot; + err.Error())            &#125;            call.done()        &#125;    &#125;    &#x2F;&#x2F; error occurs, so terminateCalls pending calls    client.terminateCalls(err)&#125;</code></pre><p>创建 Client 实例时，首先需要完成一开始的协议交换，即发送<code>Option</code>信息给服务端。协商好消息的编解码方式之后，再创建一个子协程<code>receive()</code>接收响应。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func NewClient(conn net.conn, opt *Option) (*Client, error) &#123;    f :&#x3D; codec.NewCodecFuncMap[opt.CodecType]    if f &#x3D;&#x3D; nil &#123;        err :&#x3D; fmt.Errorf(&quot;invalid codec type %s&quot;, opt.CodecType)        log.Println(&quot;rpc client: options error: &quot;, err)        return nil, err    &#125;    &#x2F;&#x2F; send options with server    if err :&#x3D; json.NewEncoder(conn).Encode(opt); err !&#x3D; nil &#123;        log.Println(&quot;rpc client: options error: &quot;, err)        _ &#x3D; conn.Close()        return nil, err    &#125;    return newClientCodec(f(conn), opt), nil&#125;func newClientCodec(cc codec.Codec, opt *Option) *Client &#123;    client :&#x3D; &amp;Client &#123;        seq:     1, &#x2F;&#x2F; seq starts with 1, 0 means invalid call        cc:      cc,        opt:     opt,        pending: make(map[uint64]*Call)    &#125;    go client.receive()    return client&#125;</code></pre><p>还需要实现<code>Dial</code>函数，便于用户传入服务端地址，创建 Client 实例。为了简化用户调用，通过<code>...*Option</code>将 Option 实现为可选参数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func parseOptions(opts ...*Option) (*Option, error) &#123;    &#x2F;&#x2F; if opts is nil or pass nil as parameter    if len(opts) &#x3D;&#x3D; 0 || opts[0] &#x3D;&#x3D; nil &#123;        return DefaultOption, nil    &#125;    if len(opts) !&#x3D; 1 &#123;        return nil, errors.New(&quot;number of options is more than 1&quot;)    &#125;    opt :&#x3D; opts[0]    opt.MagicNumber &#x3D; DefaultOption.MagicNumber    if opt.CodecType &#x3D;&#x3D; &quot;&quot; &#123;        opt.CodecType &#x3D; DefaultOption.CodecType    &#125;    return opt, nil&#125;&#x2F;&#x2F; Dial connects to an RPC server at the specified network addressfunc Dial(network, address string, opts ...*Option) (client *Client, err error) &#123;    opt, err :&#x3D; parseOptions(opts...)    if err !&#x3D; nil &#123;        return nil, err    &#125;    conn, err :&#x3D; net.Dial(network, address)    if err !&#x3D; nil &#123;        return nil, err    &#125;    &#x2F;&#x2F; close the connection if client is nil    defer func() &#123;        if client &#x3D;&#x3D; nil &#123;            _ &#x3D; conn.Close()        &#125;    &#125;()    return NewClient(conn, opt)&#125;</code></pre><p>此时，GeeRPC 客户端已经具备了完整的创建连接和接受响应的能力了，最后还需要实现发送请求的能力。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (client *Client) send(call *Call) &#123;    &#x2F;&#x2F; make sure that the client will send a complete request    client.sending.Lock()    defer client.sending.Unlock()        &#x2F;&#x2F; register this call    seq, err :&#x3D; client.registerCall(call)    if err !&#x3D; nil &#123;        call.Error() &#x3D; err        call.done()        return    &#125;        &#x2F;&#x2F; prepare request header    client.header.ServiceMethod &#x3D; call.ServiceMethod    client.header.Seq &#x3D; seq    client.header.Error &#x3D; &quot;&quot;        &#x2F;&#x2F; encode and send the request    if err :&#x3D; client.cc.Write(&amp;client.header, call.Args); err !&#x3D; nil &#123;        call :&#x3D; client.removeCall(seq)        &#x2F;&#x2F; call may be nil, it usually means that Write partially failed,        &#x2F;&#x2F; client has receive the response and handled        if call !&#x3D; nil &#123;            call.Error &#x3D; err            call.done()        &#125;    &#125;&#125;&#x2F;&#x2F; Go invokes the function asynchronously&#x2F;&#x2F; It returns the Call structure representing the invocationfunc (client *Client) Go(serviceMethod string, args, reply interface&#123;&#125;, done chan *Call) *Call &#123;    if done &#x3D;&#x3D; nil &#123;        done &#x3D; make(chan *Call, 10)    &#125; else if cap(done) &#x3D;&#x3D; 0 &#123;        log.Panic(&quot;rpc client: done channel is unbuffered&quot;)    &#125;    call :&#x3D; &amp;Call &#123;        ServiceMethod: serviceMethod,        Args:          args,        Reply:         reply,        Done:          done,    &#125;    client.send(call)    return call&#125;&#x2F;&#x2F; Call invokes the named function, waits for it to complete,&#x2F;&#x2F; and returns its error statusfunc (client *Client) Call(serviceMethod string, args, reply interface&#123;&#125;) error &#123;    call :&#x3D; &lt;- client.Go(serviceMethod, args, reply, make(chan *Call, 1)).Done    return call.Error&#125;</code></pre><ul><li><code>Go</code>和<code>Call</code>是客户端暴露给用户的两个 RPC 服务调用接口，<code>Go</code>是一个异步接口，返回 call 实例。</li><li><code>Call</code>是对<code>Go</code>的封装，阻塞 call.Done，等待响应返回，是一个同步接口。</li></ul><p>至此，一个支持异步和并发的 GeeRPC 客户端已经完成。</p><p><strong>补充</strong></p><p>defer的运行机制为，在return之后，在函数退出之前执行。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func test() (ans int) &#123;    defer func() &#123;        fmt.Println(ans)    &#125;()    return 10&#125;func main() &#123;    test()&#125;</code></pre><p>运行结果为：10。</p><h4 id="demo">Demo</h4><p>第一天 GeeRPC 只实现了服务端，因此我们在 main 函数中手动模拟了整个通信过程，第二天中我们将 main 函数中的通信部分替换为客户端。</p><p><strong>day2/main/main.go</strong></p><p>startServer 没有发生变化。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func startServer(addr chan string) &#123;    &#x2F;&#x2F; pick a free port    l, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)    if err !&#x3D; nil &#123;        log.Fatal(&quot;network error: &quot;, err)    &#125;    log.Println(&quot;start rpc server on&quot;, l.Addr())    addr &lt;- l.Addr().String()    geerpc.Accept(l)&#125;</code></pre><p>在 main 函数中使用了<code>client.Call</code>并发了5个 RPC 同步调用，参数和返回值类型均为 string。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;    log.SetFalgs(0)    addr :&#x3D; make(chan string)    go startServer(addr)    client, _ &#x3D; geerpc.Dial(&quot;tcp&quot;, &lt;-addr)    defer func() &#123;        _ &#x3D; client.Close()    &#125;()        time.Sleep(time.Second)    &#x2F;&#x2F; send request &amp; receive response    var wg sync.WaitGroup    for i :&#x3D; 0; i &lt; 5; i++ &#123;        wg.Add(1) &#x2F;&#x2F; 每一个任务开始时，将等待组增加1        &#x2F;&#x2F; 开启一个并发        go func(i int) &#123;            defer wg.Done()            args :&#x3D; fmt.Sprintf(&quot;geerpc req %d&quot;, i)            var reply string            if err :&#x3D; client.Call(&quot;Foo.Sum&quot;, args, &amp;reply); err !&#x3D; nil &#123;                log.Fatal(&quot;call Foo.Sum error: &quot;, err)            &#125;            log.Println(&quot;reply&quot;, reply)        &#125;(i)    &#125;    wg.Wait() &#x2F;&#x2F; 等待所有任务完成&#125;</code></pre><p>运行结果如下 (不唯一)：</p><pre class="line-numbers language-none"><code class="language-none">start rpc server on [::]:36013&amp;&#123;Foo.Sum 5&#125; geerpc req 3&amp;&#123;Foo.Sum 1&#125; geerpc req 4&amp;&#123;Foo.Sum 2&#125; geerpc req 1&amp;&#123;Foo.Sum 3&#125; geerpc req 0&amp;&#123;Foo.Sum 4&#125; geerpc req 2reply: geerpc resp 4reply: geerpc resp 5reply: geerpc resp 1reply: geerpc resp 2reply: geerpc resp 3</code></pre><p>当然也有这种情况</p><pre class="line-numbers language-none"><code class="language-none">&amp;&#123;Foo.Sum 1 &#125; geerpc req 4&amp;&#123;Foo.Sum 3 &#125; geerpc req 0&amp;&#123;Foo.Sum 2 &#125; geerpc req 1reply: geerpc resp 3reply: geerpc resp 1reply: geerpc resp 2&amp;&#123;Foo.Sum 5 &#125; geerpc req 3&amp;&#123;Foo.Sum 4 &#125; geerpc req 2reply: geerpc resp 5reply: geerpc resp 4</code></pre><p>对于以上执行结果，加以个人的理解，添加了若干个协程，并同步调用，其中会出现延迟开启并发的现象。</p><h3 id="day3.-服务注册">day3. 服务注册</h3><ul><li>通过反射实现服务注册功能。</li></ul><h4 id="结构体映射为服务">结构体映射为服务</h4><p>RPC 框架的一个基本能力是：像调用本地程序一样调用远程服务。关于如何将程序映射为服务，对于 Go 来说，这个问题就变成了如何将结构体的方法映射为服务。</p><p>对<code>net/rpc</code>而言，一个函数需要能够被远程调用，需要满足以下五个条件：</p><ul><li>the method's type is exported. - 方法所属的类型是导出的。</li><li>the method is exported. - 方式是导出的。</li><li>the method has two arguments, both expoerted (or builtin) types. - 两个入参，均为导出 or 内置类型。</li><li>the method's second argument is a pointer. - 第二个入参必须是一个指针。</li><li>the method has return type error. - 返回值为 error 类型。</li></ul><p>更直观一些：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (t *T)  MethodName(argType T1, replyType *T2) error</code></pre><p>假如客户端发来一个请求，包含 ServiceMethod 和 Argv。</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;ServiceMethod&quot;: &quot;T.MethodName&quot; &quot;Argv&quot;: &quot;001010010100...&quot; &#x2F;&#x2F; 序列化之后的字节流&#125;</code></pre><p>通过 <code>T.MethodName</code>可以确定调用的是类型 T 的<code>MethodName</code>，如果硬编码实现这个功能，很可能是这样：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">switch req.ServiceMethod &#123;    case &quot;T.MethodName&quot;:        t :&#x3D; new(t)        reply :&#x3D; new(T2)        var argv T1        gob.NewDecoder(conn).Decode(&amp;argv)        err :&#x3D; t.MethodName(argv, reply)        server.sendMessage(reply, err)    case &quot;Foo.Sum&quot;:        f :&#x3D; new(Foo)    ...&#125;</code></pre><p>也就是说，如果使用硬编码的方式来实现结构体与服务的映射，那么每暴露一个方法，就需要编写等量的代码。那么有没有什么方法，能够将这个映射过程自动化呢？可以借助反射。</p><p>通过反射，我们能够很容易获取某个结构体的所有方法，并且能通过所有方法，获取到该方法的所有参数类型与返回值。例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;    var wg sync.WaitGroup    typ :&#x3D; reflect.TypeOf(&amp;wg)    for i :&#x3D; 0; i &lt; typ.NumMethod(); i++ &#123;        method :&#x3D; typ.Method(i)        argv :&#x3D; make([]string, 0, method.Type.NumIn())        returns :&#x3D; make([]string, 0, method.Type.NumOut())        &#x2F;&#x2F; j从1开始，第0个入参是wg自己        for j :&#x3D; 1; j &lt; method.Type.In(j); j++ &#123;            argv &#x3D; append(argv, method.Type.In(j).Name())        &#125;        for j :&#x3D; 0; j &lt; method.Type.NumOut(); j++ &#123;            returns &#x3D; append(returns, method.Type.Out(j).Name())        &#125;        log.Printf(&quot;func (w *%s) %s(%s) %s&quot;,           typ.Elem().Name(),           method.Name,           strings.Join(argv, &quot;,&quot;),           strings.Join(returns, &quot;,&quot;))    &#125;&#125;</code></pre><p>运行结果为：</p><pre class="line-numbers language-none"><code class="language-none">func (w *WaitGroup) Add(int)func (w *WaitGroup) Done()func (w *WaitGroup) Wait()</code></pre><h4 id="通过反射实现-service">通过反射实现 service</h4><p>前两天我们完成了客户端和服务端，客户端相对来说功能是比较完整的，但是服务端的功能并不完整，仅仅将请求的 header 打印了出来，并没有真正地处理。那今天的主要目的是补全这部分功能。首先通过反射实现结构体与服务的映射关系，代码独立放置在<code>service.go</code>中。</p><p><strong>day3/service.go</strong></p><p>第一步，定义结构体 methodType：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type methodType struct &#123;    method    reflect.Method    ArgType   reflect.Type    ReplyType reflect.Type    numCalls  uint64&#125;func (m *methodType) NumCalls() uint64 &#123;    return atomic.LoadUint64(&amp;m.numCalls)&#125;func (m *methodType) newArgv() reflect.Value &#123;    var argv reflect.Value    &#x2F;&#x2F; arg may be a pointer type, or a value type    if m.ArgType.Kind() &#x3D;&#x3D; reflect.Ptr &#123;        argv &#x3D; reflect.New(m.ArgType.Elem())    &#125; else &#123;        argv &#x3D; reflect.New(m.ArgType).Elem()    &#125;    return argv&#125;func (m *methodType) newReplyv() reflect.Value &#123;    &#x2F;&#x2F; reply must be a pointer type    replyv :&#x3D; reflect.New(m.ReplyType.Elem())    switch m.ReplyType.Elem().Kind() &#123;    case reflect.Map:        replyv.Elem().Set(reflect.MakeMap(m.ReplyType.Elem()))    case refelct.Slice:        replyv.Elem().Set(reflect.MakeSlice(m.ReplyType.Elem(), 0, 0))    &#125;    return replyv&#125;</code></pre><p>每一个 methodType 实例包含了一个方法的完整信息。包括：</p><ul><li>method：方法本身</li><li>ArgType：第一个参数的类型</li><li>ReplyType：第二个参数的类型</li><li>numCalls：后续统计方法调用次数时会用到</li></ul><p>另外，我们还实现了2个方法<code>newArgv</code>和<code>newReplyv</code>，用于创建对应类型的实例。<code>newArgv</code>方法有一个小细节，指针类型和值类型创建实例的方法有细微区别。</p><p>第二部，定义结构体 service：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type service struct &#123;    name   string    typ    reflect.Type    rcvr   reflect.Value    method map[string]*methodType&#125;</code></pre><p>service 的定义也是非常简洁的，name 即映射的结构体的名称，比如<code>T</code>，比如<code>WaitGroup</code>；typ是结构体的类型；rcvr 即结构体的实例本身，保留 rcvr 是因为在调用时需要 rcvr 作为第0个参数；method 是 map 类型，储存映射的结构体的所有符合条件的方法。</p><p>接下来，完成构造函数<code>newService</code>，入参是任意需要映射为服务的结构体实例。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func newService(rcvr interface&#123;&#125;) *service &#123;    s :&#x3D; new(service)    s.rcvr &#x3D; reflect.ValueOf(rcvr)    s.name &#x3D; reflect.Indirect(s.rcvr).Type().Name()    s.typ &#x3D; reflect.TypeOf(rcvr)    if !ast.IsExported(s.name) &#123;        log.Fatalf(&quot;rpc server: %s is not a valid service name&quot;, s.name)    &#125;    s.registerMethods()    return s&#125;func (s *service) registerMethods() &#123;    s.method &#x3D; make(map[string]*methodType)    for i :&#x3D; 0; i &lt; s.typ.NumMethod(); i++ &#123;        method :&#x3D; s.typ.Method(i)        mType :&#x3D; method.Type        if mType.NumIn() !&#x3D; 3 || mType.NumOut() !&#x3D; 1 &#123;            continue        &#125;        if mType.Out(0) !&#x3D; reflect.TypeOf((*error)(nil)).Elem() &#123;            continue        &#125;        argType, replyType :&#x3D; mType.In(1), mType.In(2)        if !isExportedOrBuiltinType(argType) || !isExportedOrBuiltinType(replyType) &#123;            continue        &#125;        s.method[method.Name] &#x3D; &amp;methodType &#123;            method:    method,            ArgType:   argType,            ReplyType: replyType,        &#125;        log.Printf(&quot;rpc server: register %s.%s\n&quot;, s.name, method.Name)    &#125;&#125;func isExportOrBuiltinType(t reflect.Type) bool &#123;    return ast.IsExported(t.Name()) || t.PkgPath() &#x3D;&#x3D; &quot;&quot;&#125;</code></pre><p><code>registerMethods</code>过滤出了符合条件的方法：</p><ul><li>两个导出或内置类型的入参 (反射时为3个，第0个是自身，类似于 python 的 self，Java 中的this )</li><li>返回值有且只有一个，类型为 error</li></ul><p>最后，我们还需要实现<code>call</code>方法，即能够通过反射值调用方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (s *service) call(m *methodType, argv, replyv reflect.Value) error &#123;    atomic.AddUint64(&amp;m.numCalls, 1)    f :&#x3D; m.method.Func    returnValues :&#x3D; f.Call([]reflect.Value&#123;s.rcvr, argv, replyv&#125;)    if errInter :&#x3D; returnValues[0].Interface(); errInter !&#x3D; nil &#123;        return errInter.(error)    &#125;    return nil&#125;</code></pre><h4 id="service-的测试用例">service 的测试用例</h4><p>为了保证 service 实现的正确性，我们为 service.go 写了几个测试用例。</p><p><strong>day3/service_test.go</strong></p><p>定义结构体 Foo，实现2个方法，导出方法 Sum 和非导出方法 sum。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Foo inttype Args struct &#123; Num1, Num2 int&#125;func (f Foo) Sum(args Args, reply *int) error &#123;    *reply &#x3D; args.Num1 + args.Num2    return nil&#125;&#x2F;&#x2F; it&#39;s not a exported Methodfunc (f Foo) sum(args Args, reply *int) error &#123;    *reply &#x3D; args.Num1 + args.Num2    return nil&#125;&#x2F;&#x2F; 这里要注意，是两个不一样的函数，后面的测试中要注意写的函数名，会影响测试结果func _assert(condition bool, msg string, v ...interface&#123;&#125;) &#123;    if !condition &#123;        panic(fmt.Sprintf(&quot;assertion failed: &quot; + msg, v...))    &#125;&#125;</code></pre><p>测试 newService 和 call 方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func TestNewService(t *testing.T) &#123;    var foo Foo    s :&#x3D; newService(&amp;foo)    _assert(len(s.method) &#x3D;&#x3D; 1, &quot;wrong service Method, expect 1, but got %d&quot;, len(s.method))    mType :&#x3D; s.method[&quot;Sum&quot;]    _assert(mType !&#x3D; nil, &quot;wrong Method, Sum should&#39;t nil&quot;)&#125;func TestMethodType_Call(t *testing.T) &#123;    var foo Foo    s :&#x3D; newService(&amp;foo)    mType :&#x3D; s.method(&quot;Sum&quot;)        argv :&#x3D; mType.newArgv()    replyv :&#x3D; mType.newReplyv()    argv.Set(reflect.ValueOf(Args&#123;Num1: 1, Num2: 3&#125;))    err :&#x3D; s.call(mType, argv, replyv)    _assert(err &#x3D;&#x3D; nil &amp;&amp; *replyv.Interface().(*int) &#x3D;&#x3D; 4 &amp;&amp; mType.NumCalls() &#x3D;&#x3D; 1, &quot;failed to call Foo.Sum&quot;)&#125;</code></pre><p>这里的测试，卡了我大约2天了，开始一直没搞明白为什么注册的方法一直是 "Sum"，而不是 "sum"，然而，我一直在<code>service.go</code>里找，各种print打印相关信息，也还是找不出个所以然，其实我犯了个很低级的错误，<code>service.go</code>这一类是高度抽象的，一般不会有很具体的内容，问题只能出在<code>service_test.go</code>中，在无头绪找bug的第三天，我尝试改<code>Sum</code>函数，发现输出的内容变了，后面注意到导出和非导出函数，好吧，原来问题出在这，<code>Sum</code>和<code>sum</code>都是 Foo 有的函数，在golang中，小写字段不可从包外访问，所以注册的是大写的<code>Sum</code>。</p><h4 id="集成到服务端">集成到服务端</h4><p>通过反射结构体已经映射为服务，但请求的处理还没有完成。从接收到请求到回复还差以下几个步骤：</p><ul><li>根据入参类型，将请求的 body 反序列化。</li><li>调用<code>service.call</code>，完成方法调用。</li><li>将 reply 序列化为字节流，构造响应报文，返回。</li></ul><p>回到代码本身，补全之前在<code>server.go</code>中遗留的2个 TODO 任务<code>readRequest</code>和<code>handleRequest</code>即可。</p><p>在这之前，我们还需要为 Server 实现一个方法<code>Register</code>。</p><p><strong>day3/server.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Server represents an RPC Servertype Server struct &#123;    service sync.Map&#125;&#x2F;&#x2F; Register publishes in the server the set of methods func (server *Server) Register(rcvr interface&#123;&#125;) error &#123;    s :&#x3D; newService(rcvr)    if _, dup :&#x3D; server.serviceMap.LoadOrStore(s.name, s); dup &#123;        return errors.New(&quot;rpc: service already defined: &quot;, + s.name)    &#125;    return nil&#125;&#x2F;&#x2F; Register publishes the receiver&#39;s methods in the DefaultServerfunc Register(rcvr interface&#123;&#125;) error &#123;    return DefaultServer.Register(rcvr)&#125;</code></pre><p>配套实现<code>findService</code>方法，即通过<code>ServiceMethod</code>从 serviceMap 中找到对应的 service。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (server *Server) findService(serviceMethod string) (svc *service, mtype *methodType, err error) &#123;    dot :&#x3D; strings.LastIndex(serviceMethod, &quot;.&quot;)    if dot &lt; 0 &#123;        err :&#x3D; errors.New(&quot;rpc server: service&#x2F;method request ill-formed: &quot; + serviceMethod)        return    &#125;    serviceName, methodName :&#x3D; serviceMethod[:dot], serviceMethod[dot+1:]    svci, ok :&#x3D; server.serviceMap.Load(serviceName)    if !ok &#123;        err :&#x3D; errors.New(&quot;rpc server: can&#39;t find service &quot; + serviceName)        return    &#125;    svc &#x3D; svci.(*service)    mtype &#x3D; svc.method[methodName]    if mtype &#x3D;&#x3D; nil &#123;        err &#x3D; errors.New(&quot;rpc server: can&#39;t find method &quot; + methodName)    &#125;    return&#125;</code></pre><p><code>findService</code>的实现看似比较繁琐，但是逻辑还是非常清晰的。因为<code>ServiceMethod</code>的构成是 "Service.Method"，因此先将其分割成2部分，第一部分是 Service 的名称，第二部分即方法名。现在 serviceMap 中找到对应的 service 实例，再从 service 实例的 method 中，找到对应的 methodType。</p><p>准备工具已经就绪，我们首先补全 readRequest 方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; request stores all information of a calltype request struct &#123;    h            *codec.Header &#x2F;&#x2F; header of request    argv, replyv reflect.Value &#x2F;&#x2F; argv and replyv of request    mtype        *methodType    svc          *service&#125;func (server *Server) readRequest(cc codec.Codec) (*reqeust, error) &#123;    h, err :&#x3D; server.readRequest(cc)    if err !&#x3D; nil &#123;        return nil, err    &#125;    req :&#x3D; &amp;request&#123;h: h&#125;    req.svc, req.mtype, err &#x3D; server.findService(h.ServiceMethod)    if err !&#x3D; nil &#123;        return req, err    &#125;    req.argv &#x3D; req.mtype.newArgv()    req.replyv &#x3D; req.mtype.newReplyv()        &#x2F;&#x2F; make sure that argvi is a pointer, ReadBody need a pointer as parameter    argvi :&#x3D; req.argv.Interface()    if req.argv.Type().Kind() !&#x3D; reflect.Ptr &#123;        argvi &#x3D; req.argv.Addr().Interface()    &#125;    if err &#x3D; cc.ReadBody(argvi); err !&#x3D; nil &#123;        log.Println(&quot;rpc server: read body err: &quot;, err)        return req, err    &#125;    return req, nil&#125;</code></pre><p>readRequest 方法中最重要的部分，即通过<code>newArgv()</code>和<code>newReplyv()</code>两个方法创建出两个入参实例，然后通过<code>cc.ReadBody()</code>将请求报文反序列化为第一个入参 argv，在这里同样要注意 argv 可能是值类型，也可能是指针类型，所以处理方式有点差异。</p><p>接下来补全 handleRequest 方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (server *Server) handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup) &#123;    defer wg.Done()    err :&#x3D; req.svc.call(req.mtype, req.argv, req.replyv)    if err !&#x3D; nil &#123;        req.h.Error &#x3D; err.Error()        server.sendResponse(cc, req.h, invalidRequest, sending)        return    &#125;    server.sendResponse(cc, req.h, replyv.Interface(), sending)&#125;</code></pre><p>相对于 readRequest，handleRequest 的实现非常简单，通过<code>req.svc.call</code>完成方法调用，将 replyv 传递给 sendResponse 完成序列化即可。</p><p>到这里，今天所有内容已实现完成，成功在服务端实现了服务注册与调用。</p><h4 id="demo-1">Demo</h4><p>最后，修改下 main 验证成果。</p><p><strong>day3/main/main.go</strong></p><p>第一步，定义结构体 Foo 和方法 Sum。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;geerpc&quot;    &quot;log&quot;    &quot;net&quot;    &quot;sync&quot;    &quot;time&quot;)type Foo inttype Args struct&#123; Num1, Num2 int &#125;func (f Foo) Sum(args Args, reply *int) error &#123;    *reply &#x3D; args.Num1 + args.Num2    return nil&#125;</code></pre><p>第二步，注册 Foo 到 Server 中，并启动 RPC 服务。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func startServer(addr chan string) &#123;    var foo Foo    if err :&#x3D; geerpc.Register(&amp;foo); err !&#x3D; nil &#123;        log.Fatal(&quot;register error: &quot;, err)    &#125;    &#x2F;&#x2F;pick a free port    l, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)    if err !&#x3D; nil &#123;        log.Fatal(&quot;network error: &quot;, err)    &#125;    log.Println(&quot;start rpc server on&quot;, l.Addr())    addr &lt;- l.Addr().String()    geerpc.Accept(l)&#125;</code></pre><p>第三步，构造参数，发送 RPC 请求，并打印结果。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;    log.SetFlags(0)    addr :&#x3D; make(chan string)    go startServer(addr)    client, _ :&#x3D; geerpc.Dial(&quot;tcp&quot;, &lt;-addr)    defer func() &#123;        _ &#x3D; client.Close()    &#125;()        time.Sleep(time.Second)    &#x2F;&#x2F; send request &amp; receive response    var wg sync.WaitGroup    for i :&#x3D; 0; i &lt; 5; i++ &#123;        wg.Add(1)        go func(i int) &#123;            defer wg.Done()            args :&#x3D; &amp;Args&#123;Num1: i, Num2: i * i&#125;            var reply int            if err :&#x3D; client.Call(&quot;Foo.Sum&quot;, args, &amp;reply); err !&#x3D; nil &#123;                log.Fatal(&quot;call Foo.Sum error: &quot;, err)            &#125;            log.Printf(&quot;%d + %d &#x3D; %d&quot;, args.Num1, args.Num2, reply)        &#125;(i)    &#125;    wg.Wait()&#125;</code></pre><p>运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">rpc server: register Foo.Sumstart rpc server on [::]:575090 + 0 &#x3D; 02 + 4 &#x3D; 64 + 16 &#x3D; 203 + 9 &#x3D; 121 + 1 &#x3D; 2</code></pre><h3 id="day4.-超时处理">day4. 超时处理</h3><h4 id="为什么要超时处理机制">为什么要超时处理机制</h4><p>超时处理是 RPC 框架一个比较基本的能力，如果缺少超时处理机制，无论是服务端还是客户端都容易因为网络或其他错误导致挂死，资源耗尽，这些问题的出现大大降低了服务的可用性。因此，我们需要在 RPC 框架中加入超时处理的能力。</p><p>纵观整个远程调用的过程，需要客户端处理超时的地方有：</p><ul><li>与服务端建立连接，导致的超时。</li><li>发送请求到服务端，写报文导致的超时。</li><li>等待服务端处理时，等待处理导致的潮实 (比如服务端已挂死，迟迟不响应)</li><li>从服务端接收响应时，读报文导致的超时。</li></ul><p>需要服务端处理超时的地方有：</p><ul><li>读取客户端请求报文时，读报文导致的超时。</li><li>发送响应报文时，写报文导致的超时。</li><li>调用映射服务的方法时，处理报文导致的超时。</li></ul><p>GeeRPC 在3个地方添加了超时处理机制。分别是：</p><ul><li>客户端创建连接时。</li><li>客户端<code>Client.Call()</code>整个过程导致的超时 (包含发送报文，等待处理，接收报文所有阶段)。</li><li>服务端处理报文，即<code>Server.handleRequest</code>超时。</li></ul><h4 id="创建连接超时">创建连接超时</h4><p>为了实现上的简单，将超时设定放在了 Option 中。<code>ConnectTimeout</code>的默认值为 10s，<code>HandleTimeout</code>默认值为0，即不设限。</p><p><strong>day4/server.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Option struct &#123;    MagicNumber    int &#x2F;&#x2F; MagicNumber marks this&#39;s a geerpc request    CodecType      codec.Type &#x2F;&#x2F; client may choose different Codec to encode body    ConnectTimeout time.Duration &#x2F;&#x2F; 0 means no limit    HandleTimeout  time.Duration&#125;var DefaultOption &#x3D; &amp;Option &#123;    MagicNumber:    MagicNumber,    CodecType:      codec.GobType,    ConnectTimeout: time.Second * 10,&#125;</code></pre><p>客户端连接超时，只需要为 Dial 添加一层超时处理的外壳即可。</p><p><strong>day4/client.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type clientResult struct &#123;    client *Client    err    error&#125;type newClientFunc func(conn net.Conn, opt *Option) (client *Client, err error) &#123;    opt, err :&#x3D; parseOptions(opts...)    if err !&#x3D; nil &#123;        return nil, err    &#125;    conn, err :&#x3D; net.DialTimeout(network, address, opt.ConnectTimeout)    if err !&#x3D; nil &#123;        return nil, err    &#125;    &#x2F;&#x2F; close the connection if client is nil    defer func() &#123;        if err !&#x3D; nil &#123;            _ &#x3D; conn.Close()        &#125;    &#125;()    ch :&#x3D; make(chan clientResult)    go func() &#123;        client, err :&#x3D; f(conn, opt)        ch &lt;- clientResult&#123;client: client, err: err&#125;    &#125;()    select &#123;        case &lt;-time.After(opt.ConnectTimeout):            return nil, fmt.Errorf(&quot;rpc client: connect timeout: expect within %s&quot;, opt.ConnectTimeout)        case result :&#x3D; &lt;-ch:            return result.client, result.err    &#125;&#125;&#x2F;&#x2F; Dial connects to an RPC server at the specified network addressfunc Dial(network, address string, opts ...*Option) (*Client, error) &#123;    return dialTimeout(NewClient, network, address, opts...)&#125;</code></pre><p>在这里实现了一个超时处理的外壳<code>dialTimeout</code>，这个壳将<code>NewClient</code>作为入参，在2个地方添加了超时处理的机制。</p><ol type="1"><li>将<code>net.Dial</code>替换为<code>net.DialTimeout</code>，如果连接创建超时，将返回错误。</li><li>使用子协程执行<code>NewClient</code>，执行完成后则通过信道 ch 发送结果，如果<code>time.After()</code>信道先接收到消息，则说明<code>NewClient</code>执行超时，返回错误。</li></ol><h4 id="client.call-超时">Client.Call 超时</h4><p><code>Client.Call</code>的超时处理机制，使用 context 包实现，控制权交给用户，控制更为灵活。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Call invokes the named function, waits for it to complete,&#x2F;&#x2F; and returns its error status.func (client *Client) Call(ctx context.Context, serviceMethod string, args, reply interface&#123;&#125;) error &#123;    call :&#x3D; client.Go(serviceMethod, args, reply, make(chan *Call, 1))    select &#123;    case &lt;-ctx.Done():        client.removeCall(call.Seq)        return errors.New(&quot;rpc client: call failed: &quot; + ctx.Err().Error())    case call :&#x3D; &lt;-call.Done:        return call.Error    &#125;&#125;</code></pre><p>用户可以使用<code>context.WithTimeout</code>创建具备超时检测能力的 context 对象来控制，例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ctx, _ :&#x3D; context.WithTimeout(context.Background(), time.Second)var reply interr :&#x3D; client.Call(ctx, &quot;Foo.Sum&quot;, &amp;Args&#123;1, 2&#125;, &amp;reply)...</code></pre><h4 id="服务端处理超时">服务端处理超时</h4><p>这一部分的实现与客户端很接近，使用<code>time.After()</code>结合<code>select + chan</code>完成。</p><p><strong>day4/server.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (server *Server) handleRequest(cc codec.Codec, req *request, sending *sync.Mutex, wg *sync.WaitGroup, timeout time.Duration) &#123;    defer wg.Done()    called :&#x3D; make(chan struct&#123;&#125;)    sent :&#x3D; make(chan struct&#123;&#125;)    go func() &#123;        err :&#x3D; req.svc.call(req.mtype, req.argv, req.replyv)        called &lt;- struct&#123;&#125;&#123;&#125;        if err !&#x3D; nil &#123;            req.h.Error &#x3D; err.Error()            server.sendResponse(cc, req.h, invalidRequest, sending)            sent &lt;- struct&#123;&#125;&#123;&#125;            return         &#125;    &#125;()        if timeout &#x3D;&#x3D; 0 &#123;        &lt;-called        &lt;-sent        &#x2F;&#x2F; 从信道获取值，忽略结果(类似于pop())        return    &#125;    select &#123;    case &lt;-time.After(timeout):        req.h.Error &#x3D; fmt.Sprintf(&quot;rpc server: request handle timeout: expect within %s&quot;, timeout)        server.sendResponse(cc, req.h, invalidRequest, sending)    case &lt;-called:        &lt;-sent    &#125;&#125;</code></pre><p>这里需要确保<code>sendResponse</code>仅调用一次，因此将整个过程拆分为<code>called</code>和<code>sent</code>两个阶段，在这段代码中只会发生如下两种情况：</p><ul><li>called 信道接收到消息，代表处理没有超时，继续执行 <code>sendResponse</code>。</li><li><code>time.After()</code>先于 called 接收到消息，说明处理已经超时，called 和 sent 都将被阻塞。在<code>case &lt;-time.After(timeout)</code>处调用<code>sendResponse</code>。</li></ul><h4 id="测试用例">测试用例</h4><p><strong>day4/client_test.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func TestClient_dialTimeout(t *testing.T) &#123;    t.Parallel()    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)        f :&#x3D; func(conn net.Conn, opt *Option) (client *Client, err error) &#123;        _ &#x3D; conn.Close()        time.Sleep(time.Second * 2)        return nil, nil    &#125;    t.Run(&quot;timeout&quot;, func(t *testing.T) &#123;        _, err :&#x3D; dialTimeout(f, &quot;tcp&quot;, l.Addr().String(), &amp;Option&#123;ConnectTimeout: time.Second&#125;)        _assert(err !&#x3D; nil &amp;&amp; strings.Contains(err.Error(), &quot;connect timeout&quot;), &quot;expect a timeout error&quot;)    &#125;)    t.Run(&quot;0&quot;, func(t *testing.T) &#123;        _, err :&#x3D; dialTimeout(f, &quot;tcp&quot;, l.Addr().String(), &amp;Option&#123;ConnectTimeout: 0&#125;)        _assert(err &#x3D;&#x3D; nil, &quot;0 means no limit&quot;)    &#125;) &#125;</code></pre><p>第二个测试用例，用于测试处理超时。<code>Bar.Timeout</code>耗时2s，场景一：客户端设置超时时间为1s，服务端无限制；场景二，服务端设置超时时间为1s，客户端无限制。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Bar intfunc (b Bar) Timeout(argv int, reply *int) error &#123;    time.Sleep(time.Second * 2)    return nil&#125;func startServer(addr chan string) &#123;    var b Bar    _ &#x3D; Register(&amp;b)    &#x2F;&#x2F; pick a free port    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)    addr &lt;- l.Addr().String()    Accept(l)&#125;func TestClient_Call(t *testing.T) &#123;    t.Parallel()    addrChh :&#x3D; make(chan string)    go startServer(addrCh)    addr :&#x3D; &lt;-addrCh    time.Sleep(time.Second)    t.Run(&quot;client timeout&quot;, func(t *testing.T) &#123;        client, _ :&#x3D; Dial(&quot;tcp&quot;, addr)        ctx, _ :&#x3D; context.WithTimeout(context.Background(), time.Second)        var reply int        err :&#x3D; client.Call(ctx, &quot;Bar.Timeout&quot;, 1, &amp;reply)        _assert(err !&#x3D; nil &amp;&amp; strings.Contains(err.Error(), ctx.Err().Error()), &quot;expect a timeout error&quot;)    &#125;)    t.Run(&quot;server handle timeout&quot;, func(t *testing.T) &#123;        client, _ :&#x3D; Dial(&quot;tcp&quot;, addr, &amp;Option&#123;            HandleTimeout: time.Second,        &#125;)        var reply int        err :&#x3D; client.Call(context.Background(), &quot;Bar.Timeout&quot;, 1, &amp;reply)        _assert(err !&#x3D; nil &amp;&amp; strings.Contains(err.Error(), ctx.Err().Error()), &quot;expect a timeout error&quot;)    &#125;)    &#125;</code></pre><h3 id="day5.-支持http协议">day5. 支持HTTP协议</h3><ul><li>支持 HTTP 协议</li><li>基于 HTTP 实现一个简单的 Debug 页面，代码约 150 行。</li></ul><h4 id="支持-http-协议需要做什么">支持 HTTP 协议需要做什么？</h4><p>Web 开发中，我们经常使用 HTTP 协议中的 HEAD、GET、POST 等方式发送请求，等待响应。但 RPC 的消息格式与标准的 HTTP 协议并不兼容，在这种情况下，就需要一个协议的转换过程。HTTP 协议的 CONNECT 方法恰好提供了这个能力，CONNECT 一般用于代理服务。</p><p>假设浏览器与服务器之间的 HTTPS 通信都是加密的，浏览器通过代理服务器发起 HTTPS 请求时，由于请求的站点地址和端口号都是加密保存在 HTTPS 请求报文头中的，代理服务器如何直到往哪里发送请求呢？为了解决这个问题，浏览器通过 HTTP 明文形式向代理服务器发送一个 CONNECT 请求告诉代理服务器目标地址和端口，代理服务器接收到这个请求后，会在对应端口和目标站点建立一个 TCP 连接，连接建立成功后返回 HTTP 200 状态码告诉浏览器与该站点的加密通道已经完成。接下来代理服务器仅需透传浏览器和服务器之间的加密数据包即可，代理服务器无需解析 HTTPS 报文。</p><p>举一个简单的例子：</p><ol type="1"><li>浏览器向代理服务器发送 CONNECT 请求。</li></ol><pre class="line-numbers language-none"><code class="language-none">CONNECT jaydenchang.top:443 HTTP&#x2F;1.0 </code></pre><ol start="2" type="1"><li>代理服务器返回 HTTP 200 状态码表示连接已经建立。</li></ol><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.0 200 Connection Established</code></pre><ol start="3" type="1"><li>之后浏览器和服务器开始 HTTPS 握手并交换加密数据，代理服务器只负责传输彼此的数据包，并不能读取具体数据内容 (代理服务器也可以选择安装可信根证书解密 HTTPS 报文)。</li></ol><p>事实上，这个过程其实是通过代理服务器将 HTTP 协议转换为 HTTPS 协议的过程。对 RPC 服务端来说，需要做的事是将 HTTP 协议转换为 RPC 协议，对客户端来说，需要新增通过 HTTP CONNECT 请求创建连接的逻辑。</p><h4 id="服务端支持-http-协议">服务端支持 HTTP 协议</h4><p>那通信过程应该是这样的：</p><ol type="1"><li>客户端向 RPC 服务器发送 CONNECT 请求</li></ol><pre class="line-numbers language-none"><code class="language-none">CONNECT 10.0.0.1:9999&#x2F;geerpc HTTP&#x2F;1.0 </code></pre><ol start="2" type="1"><li>RPC 服务器返回 HTTP 200 状态码表示连接建立。</li></ol><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.0 200 Connected to Gee RPC</code></pre><ol start="3" type="1"><li>客户端使用创建好的连接发送 RPC 报文，先发送 Option，再发送 N 个请求报文，服务端处理 RPC 请求并响应。</li></ol><p>在<code>server.go</code>中新增如下的方法：</p><p><strong>day5/server.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">const (    connected        &#x3D; &quot;200 Connected to Gee RPC&quot;    defaultRPCPath   &#x3D; &quot;&#x2F;geerpc&quot;    defaultDebugPath &#x3D; &quot;&#x2F;debug&#x2F;geerpc&quot;)&#x2F;&#x2F; ServerHTTP implements an http.Handler that answer RPC requestsfunc (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;    if req.Method !&#x3D; &quot;CONNECT&quot; &#123;        w.Header().Set(&quot;Content-Type&quot;, &quot;text&#x2F;plain; charset&#x3D;utf-8&quot;)        w.WriteHeader(http.StatusMethodNotAllowed)        _, _ &#x3D; io.WriteString(w, &quot;405 must CONNECT\n&quot;)        return    &#125;    conn, _, err :&#x3D; w.(http.Hijacker).Hijack()    if err !&#x3D; nil &#123;        log.Print(&quot;rpc hijacking &quot;, req.RemoteAddr, &quot;: &quot;, err.Error())        return    &#125;    _, _ &#x3D; io.WriteString(conn, &quot;HTTP&#x2F;1.0 &quot; + connected + &quot;\n\n&quot;)    server.ServeConn(conn)&#125;&#x2F;&#x2F; HandleHTTP registers an HTTP handler for RPC messages on rpcPath&#x2F;&#x2F; It is still necessary to invoke http.Serve(), typically in a go statementfunc (server *Server) HandleHTTP() &#123;    http.Handle(defaultRPCPath, server)&#125;&#x2F;&#x2F; HandleHTTP is a convenient approach for default server to register HTTP handlersfunc HandleHTTP() &#123;    DefaultServer.HandleHTTP()&#125;</code></pre><p><code>defaultDebugPath</code>是后续 DEBUG 页面预留的地址。</p><p>在 GO 中处理 HTTP 请求是非常简单的一件事，Go 标准库中<code>http.Handle</code>的实现如下：</p><pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">package http&#x2F;&#x2F; Handle registers the handler for the given pattern.&#x2F;&#x2F; in the DefaultServeMux.&#x2F;&#x2F; The documentation for ServeMux explains how patterns are matched.func Handle(pattern string, handler Handler) &#123; DefaultServeMux.Handle(pattern, handler) &#125;</code></pre><p>第一个参数是支持统配的字符串 pattern，在这里，我们固定传入<code>/geerpc</code>，第二个参数是 Handler 类型，Handler 是一个接口类型，定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Handler interface &#123;    ServeHTTP(w ResponseWriter, r *Request)&#125;</code></pre><p>也就是说，只需要实现接口 Handler 即可作为一个 HTTP Handler 处理 HTTP 请求。接口 Handler 只定义了一个方法<code>ServeHTTP</code>，实现该方法即可。</p><h4 id="客户端支持-http-协议">客户端支持 HTTP 协议</h4><p>服务端已经能够接受 CONNECT 请求，并返回了 200 状态码<code>HTTP/1.0 200 Connected to Gee RPC</code>，客户端要做的，发起 CONNECT 请求，检查返回状态码即可成功建立连接。</p><p><strong>day5/client.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; NewHTTPClient new a Client instance via HTTP as transport protocolfunc NewHTTPClient(conn net.Conn, opt *Option) (*Client, err) &#123;    _, _ &#x3D; io.WriteString(conn, fmt.Sprintf(&quot;CONNECT %s HTTP&#x2F;1.0\n\n&quot;, defaultRPCPath))        &#x2F;&#x2F; Require successful HTTP reesponse    &#x2F;&#x2F; before switching to RPC protocol    resp, err :&#x3D; http.ReadResponse(bufio.NewReader(conn), &amp;http.Request&#123;Method: &quot;CONNECT&quot;&#125;)    if err &#x3D;&#x3D; nil &amp;&amp; resp.Status &#x3D;&#x3D; connected &#123;        return NewClient(conn, opt)    &#125;    if err &#x3D;&#x3D; nil &#123;        err &#x3D; errors.New(&quot;unexpected HTTP response: &quot; + resp.Status)    &#125;    return nil, err&#125;&#x2F;&#x2F; DialHTTP connectd to an HTTP RPC server at the specified network address &#x2F;&#x2F; listening on the default HTTP RPC path.func DialHTTP(network, address string, opts ...*Option) (*Client, error) &#123;    return dialTimeout(NewHTTPClient, network, address, opts...)&#125;</code></pre><p>通过 HTTP CONNECT 请求建立连接后，后续的通信过程就交给 NewClient 了。</p><p>为了简化调用，提供了一个统一入口<code>XDial</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; XDial calls different functions to connect to a RPC server&#x2F;&#x2F; according the first parameter rpcAddr.&#x2F;&#x2F; rpcAddr is a general format (protocol@addr) to represent a rpc server&#x2F;&#x2F; eg, http@10.0.0.1:7890, tcp@10.0.0.1:9999, unix@&#x2F;tmp&#x2F;geerpc.sockfunc XDial(rpcAddr string, opts ...*Option) (*Client, error) &#123;    parts :&#x3D; strings.Split(rpcAddr, &quot;@&quot;)    if len(parts) !&#x3D; 2 &#123;        return nil, fmt.Errorf(&quot;rpc client err: wrong format &#39;%s&#39;, expect protocol@addr&quot;, rpcAddr)    &#125;    protocol, addr :&#x3D; parts[0]. parts[1];    switch protocol &#123;    case &quot;http&quot;:        return DialHTTP(&quot;tcp&quot;, addr, opts...)    default:        &#x2F;&#x2F; tcp, unix or other transport protocol        return Dial(protocol, addr, opts...)    &#125;&#125;</code></pre><p>添加一个测试用例试一试，这个测试用例使用了 unix 协议创建 socket 连接，适用于本机内部的通信，使用上和 TCP 协议无区别。</p><p><strong>day5/client_test.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func TestXDial(t *testing.T) &#123;    if runtime.GOOS &#x3D;&#x3D; &quot;linux&quot; &#123;        ch :&#x3D; make(chan struct&#123;&#125;)        addr :&#x3D; &quot;&#x2F;tmp&#x2F;geerpc.sock&quot;        go func() &#123;            _ &#x3D; os.Remove(addr)            l, err :&#x3D; net.Listen(&quot;unix&quot;, addr)            if err !&#x3D; nil &#123;                t.Fatal(&quot;failed to listen unix socket&quot;)            &#125;            ch &lt;- struct&#123;&#125;&#123;&#125;            Accept(l)        &#125;()        &lt;-ch        _, err :&#x3D; XDial(&quot;unix@&quot; + addr)        _assert(err &#x3D;&#x3D; nil, &quot;failed to connect unix socket&quot;)    &#125;&#125;</code></pre><h4 id="实现简单的-debug-页面">实现简单的 DEBUG 页面</h4><p>支持 HTTP 协议的好处在于，RPC 服务仅仅使用了监听端口的<code>/geerpc</code>路径，在其他路径上我们可以提供诸如日志，统计等更为丰富的功能。接下来我们在<code>/debug/geerpc</code>上展示服务的调用统计视图。</p><p><strong>day5/debug.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package geerpcimport (    &quot;fmt&quot;    &quot;html&#x2F;template&quot;    &quot;net&#x2F;http&quot;)const debugText &#x3D; &#96;&lt;html&gt;&lt;body&gt;&lt;title&gt;GeeRPC Services&lt;&#x2F;title&gt;&#123;&#123;range .&#125;&#125;&lt;hr&gt;Service &#123;&#123;.Name&#125;&#125;&lt;hr&gt;&lt;table&gt;&lt;th align&#x3D;center&gt;Method&lt;&#x2F;th&gt;&lt;th align&#x3D;center&gt;Calls&lt;&#x2F;th&gt;&#123;&#123;range $name, $mtype :&#x3D; .Method&#125;&#125;&lt;tr&gt;&lt;td align&#x3D;left font&#x3D;fixed&gt;&#123;&#123;$name&#125;&#125;(&#123;&#123;$mtype.ArgType&#125;&#125;, &#123;&#123;$mtype.ReplyType&#125;&#125;) error&lt;&#x2F;td&gt;&lt;td align&#x3D;center&gt;&#123;&#123;$mtype.NumCalls&#125;&#125;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&#123;&#123;end&#125;&#125;&lt;&#x2F;table&gt;&#123;&#123;end&#125;&#125;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#96;var debug &#x3D; template.Must(template.New(&quot;RPC debug&quot;).Parse(debugText))type debugHTTP struct &#123;    *Server&#125;type debugService struct &#123;    Name   string    Method map[string]*methodType&#125;&#x2F;&#x2F; Runs at &#x2F;debug&#x2F;geerpcfunc (server debugHTTP) ServerHTTP(w http.ResponseWriter, req *http.Request) &#123;    &#x2F;&#x2F; build a sorted version of the data    var services []debugService    server.serviceMap.Range(func(namei, svci interface&#123;&#125;) bool &#123;        svc :&#x3D; svci.(*service)        services &#x3D; append(services, debugService&#123;            Name:   namei.(string),            Method: svc.method,        &#125;)        return true    &#125;)    err :&#x3D; debug.Execute(w, services)    if err !&#x3D; nil &#123;        _, _ &#x3D; fmt.Fprintln(w, &quot;rpc: error executing template:&quot;, err.Error())    &#125;&#125;</code></pre><p>在这里，我们将返回一个 HTML 报文，这个报文将展示注册所有的 service 的每一个方法的调用情况。</p><p>将 debugHTTP 实例绑定的地址<code>/debug/geerpc</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (server *Server) HandleHTTP() &#123;    http.Handle(defaultRPCPath, server)    http.Handle(defaultDebugPath, debugHTTP&#123;server&#125;)    log.Println(&quot;rpc server debug path:&quot;, defaultDebugPath)&#125;</code></pre><h4 id="demo-2">Demo</h4><p>到此，我们已经迫不及待地想看看最终的效果了。</p><p><strong>day5/main/main.go</strong></p><p>和之前的例子相比较，将 startServer 中的<code>geerpc.Accept()</code>替换为了<code>geerpc.HandleHTTP()</code>，端口固定为 9999。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Foo inttype Args struct &#123; Num1, Num2 int &#125;func (f Foo) Sum(args Args, reply *int) error &#123;    *reply &#x3D; args.Num1 + args.Num2    return nil&#125;func startServer(addrCh chan string) &#123;    var foo Foo    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;9999&quot;)    _ &#x3D; geerpc.Register(&amp;foo)    geerpc.HandleHTTP()    addrCh &lt;- l.Addr().String()    _ &#x3D; http.Serve(l, nil)&#125;</code></pre><p>客户端将<code>Dial</code>替换为<code>DialHTTP</code>，其余地方没有发生改变。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func call(addrCh chan string) &#123;    client, _ :&#x3D; geerpc.DialHTTP(&quot;tcp&quot;, &lt;-addrCh)    defer func() &#123; _ &#x3D; client.Close() &#125;()        time.Sleep(time.Second)    &#x2F;&#x2F; send a request &amp; receive response    var wg sync.WaitGroup    for i :&#x3D; 0; i &lt; 5; i++ &#123;        wg.Add(1)        go func(i int) &#123;            defer wg.Done()            args :&#x3D; &amp;Args&#123;Num1: i, Num2: i * i&#125;            var reply int            if err :&#x3D; client.Call(context.Background(), &quot;Foo.Sum&quot;, args, &amp;reply);err !&#x3D; nil &#123;                log.Fatal(&quot;call Foo.Sum error:&quot;, err)            &#125;            log.Fatal(&quot;%d + %d &#x3D; %d&quot;, args.Num1, args.Num2, reply)        &#125;(i)    &#125;    wg.Wait()&#125;func main() &#123;    log.SetFlags(0)    ch :&#x3D; make(chan string)    go call(ch)    startServer(ch)&#125;</code></pre><p>main 函数中，我们在最后调用<code>startServer</code>，服务启动后将一直等待。</p><p>运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">main$ go run.rpc server: register Foo.Sumrpc server debug path: &#x2F;debug&#x2F;geerpc4 + 16 &#x3D; 203 + 9 &#x3D; 120 + 0 &#x3D; 02 + 4 &#x3D; 61 + 1 &#x3D; 2</code></pre><p>服务已经启动，此时我们如果在浏览器中访问 <code>localhost:9999/debug/geerpc</code>，将会看到：</p><p>// img 0x0031-5</p><h3 id="day6.-负载均衡">day6. 负载均衡</h3><ul><li>通过随机选择和 Round Robin 轮询调度算法实现服务端负载均衡，约 250 行代码。</li></ul><h4 id="负载均衡策略">负载均衡策略</h4><p>假设有多个服务实例，每个实例提供相同的功能，为了提高整个系统的吞吐量，每个实例部署在不同的机器上。客户端可以选择任意一个实例进行调用，获取想要的结果。那如何选择呢？取决了负载均衡的策略。对于 RPC 框架来说，我们可以很容易地想到这么几种策略：</p><ul><li>随机选择策略 - 从服务列表中随机选择一个。</li><li>轮询算法 (Round Robin) - 依次调度不同的服务器，每次调度执行 i = (i + 1) mode n。</li><li>加权轮询 (Weight Round Robin) - 在轮询算法的基础上，为每个服务实例设置一个权重，高性能的机器赋予更高的权重，也可以根据服务实例的当前的负载情况做动态的调整，例如考虑最近 5 分钟部署服务器的 CPU 、内存消耗情况。</li><li>哈希 / 一致性哈希策略 - 依据请求的某些特征，计算一个 hash 值，根据 hash 值将请求发送到对应的机器，一致性 hash 还可以解决服务实例动态添加情况下，调度抖动的问题。一致性哈希的一个典型应用场景是分布式缓存服务。</li></ul><h4 id="服务发现">服务发现</h4><p>负载均衡的前提是有多个服务实例，那我们首先实现一个最基础的服务发现模块 Discovery。为了与通信部分解耦，这部分的代码统一放置在 xclient 子目录下。</p><p>定义 2 个类型：</p><ul><li>SelectMode 代表不同的负载均衡策略，简单起见，GeeRPC 仅实现 Random 和 RoundRobin 两种策略。</li><li>Discovery 是一个接口类型，包含了服务发现所需要的最基本的接口。<ul><li><code>Refresh()</code>从注册中心更新服务列表。</li><li><code>Update(servers []string)</code>手动更新服务列表。</li><li><code>Get(mode SelectMode)</code>根据负载均衡策略，选择一个服务实例。</li><li><code>GetAll()</code>返回所有的服务实例。</li></ul></li></ul><p><strong>day6/xclient/discovery.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package xclientimport (    &quot;errors&quot;    &quot;math&quot;    &quot;math&#x2F;rand&quot;    &quot;sync&quot;    &quot;time&quot;)type SelectMode intconst (    RandomSelect SelectMode &#x3D; iota &#x2F;&#x2F; select randomly    RoundRobinSelect               &#x2F;&#x2F; select using Robbin algorithm)type Discovery interface &#123;    Refresh() error &#x2F;&#x2F; refresh from remote registry    Update(servers []string) error    Get(mode SelectMode) (string, error)    GetAll() ([]string, error)&#125;</code></pre><p>紧接着，我们实现一个不需要注册中心，服务列表由手工维护的服务发现的结构体：MultiServersDiscovery</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type MultiServersDiscovery struct &#123;    r       *rand.Rand   &#x2F;&#x2F; generate random number    mu      sync.RWMutex &#x2F;&#x2F; protect following    servers []string     index   int          &#x2F;&#x2F; record the selected position for robin algorithm&#125;&#x2F;&#x2F; NewMultiServerDiscovery creates a MultiServersDiscovery instancefunc NewMultiServerDiscovery(servers []string) *MultiServersDiscovery &#123;    d :&#x3D; &amp;MultiServersDiscovery &#123;        servers: servers,        r:       rand.New(rand.NewSource(time.Now().UnixNano())),    &#125;    d.index &#x3D; d.r.Intn(math.MaxInt32 - 1)    return d&#125;</code></pre><ul><li>r 是一个产生随机数的实例，初始化时使用时间戳设定随机数种子，避免每次产生相同的随机数序列。</li><li>index 记录 Round Robin 算法已经轮询到的位置，为了避免每次从 0 开始，初始化时随机设定一个值。</li></ul><p>然后，实现 Discovery 接口</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var _ Discovery &#x3D; (*MultiServersDiscovery)(nil)&#x2F;&#x2F; Refresh doesn&#39;t make sense for MultiServersDiscovery, so ignore itfunc (d *MultiServersDiscovery) Refresh() error &#123;    return nil&#125;&#x2F;&#x2F; Update the servers of discovery dynamically if neededfunc (d *MultiServersDiscovery) Update(servers []string) error &#123;    d.mu.Lock()    defer d.mu.Unlock()    d.servers &#x3D; servers    return nil&#125;&#x2F;&#x2F; Get a server according to modefunc (d *MultiServersDiscovery) Get(mode SelectMode) (string, error) &#123;    d.mu.Lock()    defer d.mu.Unlock()    n :&#x3D; len(d.servers)    if n &#x3D;&#x3D; 0 &#123;        return &quot;&quot;, errors.New(&quot;rpc discovery: no available servers&quot;)    &#125;    switch mode &#123;    case RandomSelect:        return d.servers[d.r.Intn(n)], nil    case RoundRobinSelect:        s :&#x3D; d.servers[d.index % n] &#x2F;&#x2F; servers could be updated, so mode n to ensure safety        d.index &#x3D; (d.index + 1) % n        return s, nil    default:        return &quot;&quot;, errors.New(&quot;rpc discovery: not supported select mode&quot;)    &#125;&#125;&#x2F;&#x2F; returns all servers in discoveryfunc (d *MultiServersDiscovery) GetAll() ([]string, error) &#123;    d.mu.RLock()    defer d.mu.RUnlock()    &#x2F;&#x2F; return a copy of d.servers    servers :&#x3D; make([]string, len(d.servers), len(d.servers))    copy(servers, d.servers)    return servers, nil&#125;</code></pre><h4 id="支持负载均衡的客户端">支持负载均衡的客户端</h4><p>接下来，我们向用户暴露一个支持负载均衡的客户端的 XClient。</p><p><strong>day6/xclient/xclient.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package xclientimport (    &quot;context&quot;    . &quot;geerpc&quot;    &quot;io&quot;    &quot;reflect&quot;    &quot;sync&quot;)type XClient struct &#123;    d       Discovery    mode    SelectMode    opt     *Option    mu      sync.Mutex &#x2F;&#x2F; protect following    clients map[string]*Client&#125;var _ io.Closer &#x3D; (*XClient)(nil)func NewXClient(d Discovery, mode SelectMode, opt *Option) *XClient &#123;    return &amp;XClient&#123;d: d, mode: mode, opt: opt, clients make(map[string]*Client)&#125;&#125;func (xc *XClient) Close() error &#123;    xc.mu.Lock()    defer xc.mu.Unlock()    for key, client :&#x3D; range xc.clients &#123;        &#x2F;&#x2F; I hava no idea how to deal with error, just ignore it.        _ &#x3D; client.Close()        delete(xc.clients, key)    &#125;    return nil&#125;</code></pre><p>XClient 的构造函数需要传入三个参数，服务发现实例 Discovery、负载均衡模式 SelectMode 以及协议选项 Option。为了尽量地复用已经创建好的 Socket 连接，使用 clients 保存创建成功的 Client 实例，并提供 Close 方法在结束后，关闭已经创建的连接。</p><p>接下来，实现客户端最基本的功能<code>Call</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (xc *Client) dial(rpcAddr string) (*Client, error) &#123;    xc.mu.Lock()    defer xc.mu.Unlock()    client, ok :&#x3D; xc.clients[rpcAddr]    if ok &amp;&amp; !client.IsAvailable() &#123;        _ &#x3D; client.Close()        delete(xc.clients, rpcAddr)        client &#x3D; nil    &#125;    if client &#x3D;&#x3D; nil &#123;        var err error        client, err &#x3D; XDial(rpcAddr, xc.opt)        if err !&#x3D; nil &#123;            return nil, err        &#125;        xc.clients[rpcAddr] &#x3D; client    &#125;    return client, nil&#125;func (xc *XClient) call(rpcAddr string, ctx context.Context, serviceMethod string, args, reply interface&#123;&#125;) error &#123;    client, err :&#x3D; xc.dial(rpcAddr)    if err !&#x3D; nil &#123;        return err    &#125;    return client.Call(ctx, serviceMethod, args, reply)&#125;&#x2F;&#x2F; Call invokes the named function, waits for it to complete,&#x2F;&#x2F; and returns its error status.&#x2F;&#x2F; xc will choose a proper server.func (xc *XClient) Call(ctx context.Context, serviceMethod string, args, reply interface&#123;&#125;) error &#123;    rpcAddr, err :&#x3D; xc.d.Get(xc.mode)    if err !&#x3D; nil &#123;        return err    &#125;    return xc.call(rpcAddr, ctx, serviceMethod, args, reply)&#125;</code></pre><p>我们将复用 Client 的能力封装在方法<code>dial</code>中，<code>dial</code>的处理逻辑如下：</p><ol type="1"><li>检查<code>xc.clients</code>是否有缓存的 Client，如果有，检查是否时可用状态，如果是，则返回缓存的 Client，如果不可用，则从缓存中删除。</li><li>如果步骤 1 没有返回缓存的 Client，则说明需要创建新的 Client，缓存并返回。</li></ol><p>另外，我们为 XClient 添加一个常用功能：<code>Broadcast</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Broadcast invokes the named function for every server registered in discoveryfunc (xc *XClient) Broadcast(ctx context.Context, serviceMethod string, args, reply interface&#123;&#125;) error &#123;    servers, err :&#x3D; xc.d.GetAll()    if err !&#x3D; nil &#123;        return err    &#125;    var wg sync.WaitGroup    var mu sync.Mutex &#x2F;&#x2F; protect e and replyDone    var e error    replyDone :&#x3D; reply &#x3D;&#x3D; nil &#x2F;&#x2F; if reply is nil, don&#39;t need to set value    ctx, cancel :&#x3D; context.WithCancel(ctx)    for _, rpcAddr :&#x3D; range servers &#123;        wg.Add(1)        go func(rpcAddr string) &#123;            defer wg.Done()            var clonedReply interface&#123;&#125;            if reply !&#x3D; nil &#123;                clonedReply &#x3D; reflect.New(reflect.ValueOf(reply).Elem().Type()).Interface()                            &#125;            err :&#x3D; xc.call(rpcAddr, ctx, serviceMethod, args, clonedReply)            mu.Lock()            if err !&#x3D; nil &amp;&amp; e &#x3D;&#x3D; nil &#123;                e &#x3D; err                cancel() &#x2F;&#x2F; if any call failed, cancel unfinished calls            &#125;            if err &#x3D;&#x3D; nil &amp;&amp; !replyDone &#123;                reflect.ValueOf(reply).Elem().Set(reflect.ValueOf(clonedReply).Elem())                replyDone &#x3D; true            &#125;            mu.Unlock()        &#125;(rpcAddr)    &#125;    wg.Wait()    return e&#125;</code></pre><p>Broadcast 将请求广播到所有的服务实例，如果任意一个实例发生错误，则返回其中一个错误；如果调用成功，则返回其中一个的结果。有以下几点需要注意：</p><ol type="1"><li>为了提升性能，请求是并发的。</li><li>并发情况下需要使用互斥锁保证 error 和 reply 能被正确赋值。</li><li>借助<code>context.WithCancel</code>确保有错误发生时，快速失败。</li></ol><h4 id="demo-3">Demo</h4><p>首先，启动 RPC 服务的代码还是类似的，Sum 时正常的方法，Sleep 用于验证 XClient 的超时机制能否正常运作。</p><p><strong>day6/main/main.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;context&quot;    &quot;geerpc&quot;    &quot;geerpc&#x2F;xclient&quot;    &quot;log&quot;    &quot;net&quot;    &quot;sync&quot;    &quot;time&quot;)type Foo inttype Args struct&#123; Num1, Num2 int &#125;func (f Foo) Sum(args Args, reply *int) error &#123;    time.Sleep(time.Second * time.Duration(args.Num1))    *reply &#x3D; args.Num1 + args.Num2    return nil&#125;func (f Foo) Sleep(args Args, reply *int) error &#123;    var foo Foo    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)    server :&#x3D; geerpc.NewServer()    &#x2F;&#x2F; send request &amp; receive response    var wg sync.WaitGroup    for i :&#x3D; 0; i &lt; 5; i++ &#123;        wg.Add(1)        go func(i int) &#123;            defer wg.Done()            foo(xc, context.Background(), &quot;call&quot;, &quot;Foo.Sum&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)        &#125;(i)    &#125;    wg.Wait()&#125;func broadcast(addr1, addr2 string) &#123;    d :&#x3D; xclient.NewMultiServerDiscovery([]string&#123;&quot;tcp&quot; + addr1, &quot;tcp@&quot; + addr2&#125;)    xc :&#x3D; xclient.NewXClient(d, xclient.RandomSelect, nil)    defer func() &#123; _ &#x3D; xc.Close() &#125;()    var wg sync.WaitGroup    for i :&#x3D; 0; i &lt; 5; i++ &#123;        wg.Add(1)        go func(i int) &#123;            defer wg.Done()            foo(xc, context.Background(), &quot;broadcast&quot;, &quot;Foo.Sum&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)            &#x2F;&#x2F; expect 2 - 5 timeout            ctx, _ :&#x3D; context.WithTimeout(context.Background(), time.Second * 2)            foo(xc, ctx, &quot;broadcast&quot;, &quot;Foo.Sleep&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)        &#125;(i)    &#125;    wg.Wait()&#125;func main() &#123;    log.SetFlags(0)    ch1 :&#x3D; make(chan string)    ch2 :&#x3D; make(chan string)    &#x2F;&#x2F; start two servers    go startServer(ch1)    go startServer(ch2)        addr1 :&#x3D; &lt;-ch1    addr@ :&#x3D; &lt;-ch2        time.Sleep(time.Second)    call(addr1, addr2)    broadcast(addr1, addr2)&#125;</code></pre><p>运行结果如下</p><pre class="line-numbers language-none"><code class="language-none">*main.Foo    Sleeprpc server: register Foo.Sleep*main.Foo    Sumrpc server: register Foo.Sum*main.Foo    Sleeprpc server: register Foo.Sleep*main.Foo    Sumrpc server: register Foo.Sumcall Foo.Sum success: 3 + 9 &#x3D; 12call Foo.Sum success: 4 + 16 &#x3D; 20call Foo.Sum success: 2 + 4 &#x3D; 6call Foo.Sum success: 0 + 0 &#x3D; 0call Foo.Sum success: 1 + 1 &#x3D; 2broadcast Foo.Sum success: 4 + 16 &#x3D; 20broadcast Foo.Sum success: 2 + 4 &#x3D; 6broadcast Foo.Sum success: 1 + 1 &#x3D; 2broadcast Foo.Sum success: 0 + 0 &#x3D; 0broadcast Foo.Sum success: 3 + 9 &#x3D; 12broadcast Foo.Sleep success: 0 + 0 &#x3D; 0broadcast Foo.Sleep success: 1 + 1 &#x3D; 2broadcast Foo.Sleep error: rpc client: call failed: context deadline exceededbroadcast Foo.Sleep error: rpc client: call failed: context deadline exceededbroadcast Foo.Sleep error: rpc client: call failed: context deadline exceeded</code></pre><h3 id="day7.-服务发现与注册中心">day7. 服务发现与注册中心</h3><p>// header 一定要一致，不然一直错</p><ul><li>实现一个简单的注册中心，支持服务注册，接收心跳等功能。</li><li>客户端实现基于注册中心的服务发现机制。</li></ul><h4 id="注册中心的位置">注册中心的位置</h4><p>// img</p><p>注册中心的位置如上图所示。注册中心的好处在于，客户端和服务端都只需要感知注册中心的存在，而无需感知对方的存在。更具体一点：</p><ol type="1"><li>服务端启动后，向注册中心发送注册信息，注册中心得知该服务已经启动，处于可用状态。一般来说，服务端还需要定期向注册中心发送心跳，证明自己还活着。</li><li>客户端向注册中心询问，当前哪天服务是可用的，注册中心将可用的服务列表返回客户端。</li><li>客户端根据注册中心得到的服务列表，选择其中一个发起调用。</li></ol><p>如果没有注册中心，就像 GeeRPC 第六天实现的一样，客户端需要硬编码服务端的地址，而且没有机制保证服务端是否处于可用状态。当然注册中心的功能还有很多，比如配置的动态同步，通知机制等。比较常用的注册中心有 etcd、zookeeper、consul，一般比较出名的微服务或者 RPC 框架，这些主流的注册中心都是支持的。</p><h4 id="gee-registry">Gee Registry</h4><p>主流的注册中心 etcd、zookeeper 等功能强大，与这类注册中心的对接代码量是比较大的，需要实现的接口很多。GeeRPC 选择自己实现一个简单的支持心跳保活的注册中心。</p><p>GeeRegistry 的代码独立放置在子目录 registry 中。</p><p>首先定义 GeeRegistry 结构体，默认超时时间设置为 5 min，也就是说，任何注册的服务超过 5 min，即视为不可用状态。</p><p><strong>day7/registry/registry.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type GeeRegistry struct &#123;    timeout time.Duration    mu      sync.Mutex &#x2F;&#x2F; protect following    servers map[string]*ServerItem&#125;type ServerItem struct &#123;    Addr string    start time.Time&#125;const (defaultPath    &#x3D; &quot;&#x2F;geerpc&#x2F;registry&quot;    defaultTimeout &#x3D; time.Minute * 5)&#x2F;&#x2F; New create a registry instance with timeout settingfunc New(timeout time.Duration) *GeeRegistry &#123;    return &amp;GeeRegistry &#123;        servers: make(map[string]*ServerItem),        timeout: timeout,    &#125;&#125;var DefaultGeeRegister &#x3D; New(defaultTimeout)</code></pre><p>为 GeeRegistry 实现添加服务实例和返回服务列表的方法。</p><ul><li>putServer：添加服务实例，如果服务已存在，则更新 start。</li><li>aliveServers：返回可用的服务列表，如果存在超时的服务，则删除。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (r *GeeRegistry) putServer(addr string) &#123;    r.mu.Lock()    defer r.mu.Unlock()    s :&#x3D; r.servers[addr]    if s &#x3D;&#x3D; nil &#123;        r.servers[addr] &#x3D; &amp;ServerItem&#123;Addr: addr, start: time.Now()&#125;    &#125; else &#123;        s.start &#x3D; time.Now() &#x2F;&#x2F; if exists, update start time to keep alive    &#125;&#125;func (r *GeeRegistry) aliveServers() []string &#123;    r.mu.Lock()    defer r.mu.Unlock()    var alive []string    for addr, s :&#x3D; range r.servers &#123;        if r.timeout &#x3D;&#x3D; 0 || s.start.Add(r.timeout).After(time.Now()) &#123;            alive &#x3D; append(alive, addr)        &#125; else &#123;            delete(r.servers, addr)        &#125;        sort.Strings(alive)        return alive    &#125;&#125;</code></pre><p>为了实现上的简单，GeeRegistry 采用 HTTP 协议提供服务，且所有的有用信息都承载在 HTTP Header 中。</p><ul><li>Get：返回所有可用的服务列表，通过自定义字段 X-Geerpc-Servers 承载。</li><li>Post：添加服务实例或发送心跳，通过自定义字段 X-Geerpc-Server 承载。</li></ul><blockquote><p>这里要注意，Get 和 Post 各自使用的 header 一定要一样，不然就会出现<code>rpc discovery: no available servers</code>的错误</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (r *GeeRegistry) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;    switch req.Method &#123;    case &quot;GET&quot;:        &#x2F;&#x2F; keep it simple, server is in req.Header        w.Header().Set(&quot;X-Geerpc-Servers&quot;, strings.Join(r.aliveServers(), &quot;,&quot;))    case &quot;POST&quot;:        &#x2F;&#x2F; keep it simple, server is in req.Header        addr :&#x3D; req.Header.Get(&quot;X-Geerpc-Server&quot;)        if addr &#x3D;&#x3D; &quot;&quot; &#123;            w.WriteHeader(http.StatusInternalServerError)            return        &#125;        r.putServer(addr)    default:        w.WriteHeader(http.StatusInternalServerError)    &#125;&#125;&#x2F;&#x2F; HandleHTTP registers an HTTP handler for GeeRegistry messages on registryPathfunc (r *GeeRegistry) HandleHTTP(registryPath string) &#123;    http.Handle(registryPath, r)    log.Println(&quot;rpc registry path:&quot;, registryPath)&#125;func HandleHTTP() &#123;    DefaultGeeRegister.HandleHTTP(defaultPath)&#125;</code></pre><p>另外，提供 Heartbeat 方法，便于服务启动时定时向注册中心发送心跳，默认周期比注册中心设置的过期时间少 1 min。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Heartbeat send a heartbeat message every once in a while&#x2F;&#x2F; it&#39;s a helper function for a server to register or send heartbeatfunc Heartbeat(registry, addr string, duration time.Duration) &#123;    if duration &#x3D;&#x3D; 0 &#123;        &#x2F;&#x2F; make sure there is enough time to send heart beat        &#x2F;&#x2F; before it&#39;s removed from registry        duration &#x3D; defaultTimeout - time.Duration(1)*time.Minute    &#125;    var err error    err &#x3D; sendHeartbeat(registry, addr)    go func() &#123;        t :&#x3D; time.NewTicker(duration)        for err &#x3D;&#x3D; nil &#123;            &lt;-t.C            err &#x3D; sendHeartbeat(registry, addr)        &#125;    &#125;()&#125;func sendHeartbeat(registry, addr string) error &#123;    log.Println(addr, &quot;send heart beat to registry&quot;, registry)    httpClient :&#x3D; &amp;http.Client&#123;&#125;    req, _ :&#x3D; http.NewRequest(&quot;POST&quot;, registry, nil)    req.Header.Set(&quot;X-Geerpc-Server&quot;, addr)    if _, err :&#x3D; httpClient.Do(req); err !&#x3D; nil &#123;        log.Println(&quot;rpc server: heart beat err:&quot;, err)        return err    &#125;    return nil&#125;</code></pre><h4 id="geeregistrydiscovery">GeeRegistryDiscovery</h4><p>在 xclient 中对应实现 Discovery。</p><p><strong>day7/xclient/discovery_gee.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package xclienttype GeeRegistryDiscovery struct &#123;    *MultiServersDiscovery     registry   string    timeout    time.Duration    lastUpdate time.Time&#125;const defaultUpdateTimeout &#x3D; time.Second * 10func NewGeeRegistryDiscovery(registerAddr string, timeout time.Duration) *GeeRegistryDiscovery &#123;    if timeout &#x3D;&#x3D; 0 &#123;        timeout &#x3D; defaultUpdateTimeout    &#125;    d :&#x3D; &amp;GeeRegistryDiscovery &#123;        MultiServerDiscovery: NewMultiServerDiscovery(make([]string, 0))        registry:             registerAddr,        timeout:              timeout,    &#125;    return d&#125;</code></pre><ul><li>GeeRegistryDiscovery 嵌套了 MultiServersDiscovery，很多能力可以复用。</li><li>registry 即注册中心的地址。</li><li>timeout 服务列表的过期时间。</li><li>lastUpdate 是代表最后从注册中心更新服务列表的时间，默认 10s 过期，即 10s 之后，需要从注册中心更新新的列表。</li></ul><p>实现 Update 和 Refresh 方法，超时重新获取的逻辑在 Refresh 中实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (d *GeeRegistryDiscovery) Update(servers []string) error &#123;    d.mu.Lock()    defer d.mu.Unlock()    d.servers &#x3D; servers    d.lastUpdate &#x3D; time.Now()    return nil&#125;func (d *GeeRegistryDiscovery) Refresh() error &#123;    d.mu.Lock()    defer d.mu.Unlock()    if d.lastUpdate.Add(d.timeout).After(time.Now()) &#123;        return nil    &#125;    log.Println(&quot;rpc registry: refresh servers form registry&quot;, d.registry)    resp, err :&#x3D; http.Get(d.registry)    if err !&#x3D; nil &#123;        log.Println(&quot;rpc registry refresh err:&quot;, err)        return err    &#125;    servers :&#x3D; strings.Split(resp.Header.Get(&quot;X-Geerpc-Server&quot;, &quot;,&quot;))    d.server &#x3D; make([]string, 0, len(servers))    for _, server :&#x3D; range servers &#123;        if strings.TrimSpace(server) !&#x3D; &quot;&quot; &#123;            d.servers &#x3D; append(d.servers, strings.TrimSpace(server))        &#125;    &#125;    d.lastUpdate &#x3D; time.Now()    return nil&#125;</code></pre><p><code>Get</code>和<code>GetAll</code>与<code>MultiServersDiscovery</code>相似，唯一不同的在于，<code>GeeRegistryDiscovery</code>需要先调用 Refresh 确保服务列表没有过期。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (d *GeeRegistryDiscovery) Get(mode SelectMode) (string, error) &#123;    if err :&#x3D; d.Refresh(); err !&#x3D; nil &#123;        return &quot;&quot;, err    &#125;    return d.MultiServersDiscovery.Get(mode)&#125;func (d *GeeRegistryDiscovery) GetAll() ([]string, error) &#123;    if err :&#x3D; d.Refresh(); err !&#x3D; nil &#123;        return nil, err    &#125;    return d.MultiServersDiscovery.GetAll()&#125;</code></pre><h4 id="demo-4">Demo</h4><p>最后，依旧通过简单的 Demo 验证今天的成果。</p><p>添加函数 startRegistry，稍微修改 startServer，添加调用注册中心的<code>Heartbeat</code>方法的逻辑，定期向注册中心发送心跳。</p><p><strong>day7/main/main.go</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func startRegistry(wg *sync.WaitGroup) &#123;    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:9999&quot;)    registry.HandleHTTP()    wg.Done()    _ &#x3D; http.Serve(l, nil)&#125;func startServer(registryAddr string, wg *sync.WaitGroup) &#123;    var foo Foo    l, _ :&#x3D; net.Listen(&quot;tcp&quot;, &quot;:0&quot;)    server :&#x3D; geerpc.NewServer()    _ &#x3D; server.Register(&amp;foo)    registry.Heartbeat(registryAddr)    wg.Done()    server.Accept(l)&#125;</code></pre><p>接下来，将 call 和 broadcast 的 MultiServersDiscovery 替换为 GeeRegistryDiscovery，不再需要硬编码服务列表。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func call(registry string) &#123;    d :&#x3D; xclient.NewGeeRegistryDiscovery(registry, 0)    xc :&#x3D; xclient.NewXClient(d, xclient.RandomSelect, nil)    defer func() &#123; _ &#x3D; xc.Close() &#125;()    &#x2F;&#x2F; send request &amp; receive response    var wg sync.WaitGroup    for i :&#x3D; 0; i &lt; 5; i++ &#123;        wg.Add(1)        go func(i int) &#123;            defer wg.Done()            foo(xc, context.Background(), &quot;call&quot;, &quot;Foo.Sum&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)        &#125;(i)    &#125;    wg.Wait()&#125;func broadcast(registry string) &#123;    d :&#x3D; xclient.NewGeeRegistryDiscovery(registry, 0)    xc :&#x3D; xclient.NewXClient(d, xclient.RandomSelect, nil)    defer func() &#123; _ &#x3D; xc.Close() &#125;()    var wg sync.WaitGroup    for i :&#x3D; 0; i &lt; 5; i++ &#123;        wg.Add(1)        go func(i int) &#123;            defer wg.Done()            foo(xc, context.Background(), &quot;broadcast&quot;, &quot;Foo.Sum&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)            &#x2F;&#x2F; expect 2- 5 timeout            ctx, _ :&#x3D; context.WithTimeout(context.Background(), time.Second*2)            foo(xc, ctx, &quot;broadcast&quot;, &quot;Foo.Sleep&quot;, &amp;Args&#123;Num1: i, Num2: i * i&#125;)        &#125;(i)    &#125;    wg.Wait()&#125;</code></pre><p>最后在 main 函数中，将所有的逻辑串联起来，确保注册中心启动后，再启动 RPC 服务端，最后客户端远程调用。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;    log.SetFlags(0)    registryAddr :&#x3D; &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;geerpc&#x2F;registry&quot;    var wg sync.WaitGroup    wg.Add(1)    go startRegistry(&amp;wg)    wg.Wait()        time.Sleep(time.Second)    wg.Add(2)    go startServer(registryAddr, &amp;wg)    go startServer(registryAddr, &amp;wg)    wg.Wait()        time.Sleep(time.Second)    call(registryAddr)    broadcast(registryAddr)    &#125;</code></pre><p>运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">rpc registry path: &#x2F;geerpc&#x2F;registry*main.Foo    Sleeprpc server: register Foo.Sleep*main.Foo    Sumrpc server: register Foo.Sumtcp@[::]:46043 send heart beat to registry http:&#x2F;&#x2F;localhost:9999&#x2F;geerpc&#x2F;registry*main.Foo    Sleeprpc server: register Foo.Sleep*main.Foo    Sumrpc server: register Foo.Sumtcp@[::]:45079 send heart beat to registry http:&#x2F;&#x2F;localhost:9999&#x2F;geerpc&#x2F;registryrpc registry: refresh servers from registry http:&#x2F;&#x2F;localhost:9999&#x2F;geerpc&#x2F;registrycall Foo.Sum success: 2 + 4 &#x3D; 6call Foo.Sum success: 4 + 16 &#x3D; 20call Foo.Sum success: 1 + 1 &#x3D; 2call Foo.Sum success: 0 + 0 &#x3D; 0call Foo.Sum success: 3 + 9 &#x3D; 12rpc registry: refresh servers from registry http:&#x2F;&#x2F;localhost:9999&#x2F;geerpc&#x2F;registrybroadcast Foo.Sum success: 3 + 9 &#x3D; 12broadcast Foo.Sum success: 2 + 4 &#x3D; 6broadcast Foo.Sum success: 4 + 16 &#x3D; 20broadcast Foo.Sum success: 1 + 1 &#x3D; 2broadcast Foo.Sum success: 0 + 0 &#x3D; 0broadcast Foo.Sleep success: 0 + 0 &#x3D; 0broadcast Foo.Sleep success: 1 + 1 &#x3D; 2broadcast Foo.Sleep error: rpc client: call failed: context deadline exceededbroadcast Foo.Sleep error: rpc client: call failed: context deadline exceededbroadcast Foo.Sleep error: rpc client: call failed: context deadline exceeded</code></pre><p>七天时间，参照 golang 标准库 net/rpc，实现了服务端以及支持并发的客户端，并且支持选择不同的序列化与反序列化方式；为了防止服务挂死，在其中一些关键部分添加蓝超时处理机制；支持 TCP、Unix、HTTP 等多种传输协议；支持多种负载均衡模式，最后还实现了一个简易的服务注册和发现中心。</p><h3 id="一些想法">一些想法</h3><p>其实我学习这个的目的是为了尝试完成 mit 6.824，它的 lab1 里，要求使用利用 rpc 来完成客户端和服务器之间的通信，但无奈，学习 golang 的时间并不是很长，恰巧留意到 geektutu 有发过 rpc 的七天项目，那么，正好，来敲一敲练练手。</p><p>那么来提炼一些个人觉得比较重要的知识。</p><h4 id="典型的-rpc-调用过程">典型的 RPC 调用过程</h4><p>感觉，这个项目中的 rpc 的一些定义我不是很能理解，那么根据自己在别的网站上学到的，以及在做 6.824 lab1时的一些经验，重新总结下相关 rpc 的基本结构。</p><p><strong>server</strong></p><p>这里的定义，结合了 6.824 lab1 的实验要求进行总结，当然下面举的例子也只是简要说明下 rpc 的组成。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Task struct &#123;    FileName string    TaskType int&#125;type Coordinator struct &#123;    task Task&#125;</code></pre><p><strong>client</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type client struct &#123;    clientID int    mapf     func(string, string) []KeyValue    reducef  func(string, []string) string&#125;</code></pre><p><strong>rpc</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type TaskRequest struct &#123;    X int&#125;&#x2F;&#x2F; 用于获取任务的请求结构体，在 lab1 中不携带信息type TaskReply struct &#123;    X int&#125;&#x2F;&#x2F; 回复任务的结构体，在 lab1 中不需要携带信息</code></pre><p>server 中定义了一个函数 <code>func()</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (s *Server)Func() &#123;    &#x2F;&#x2F; code&#125;</code></pre><p>然后在 client 里有一个 <code>CallGetFunc()</code>， 用于远程调用。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func CallGetFunc() &#123;    args :&#x3D; TaskRequest&#123;&#125;    reply :&#x3D; TaskReply&#123;&#125;    call(&quot;Server.Func&quot;, &amp;args, &amp;reply)&#125;</code></pre><p>这样子，就完成了一个基本的 rpc 调用过程。</p>]]></content>
    
    
    <summary type="html">用七天时间实现用Golang一个RPC框架</summary>
    
    
    
    <category term="BackEnd" scheme="https://jaydenchang.top/categories/BackEnd/"/>
    
    
    <category term="Golang" scheme="https://jaydenchang.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Java swing实现应用程序对数据库的访问</title>
    <link href="https://jaydenchang.top/post/0x0030.html"/>
    <id>https://jaydenchang.top/post/0x0030.html</id>
    <published>2022-09-18T16:00:00.000Z</published>
    <updated>2022-09-21T00:25:53.760Z</updated>
    
    <content type="html"><![CDATA[<p>最近在完成软件体系结构上机实验时，遇到一个有点点小难度的选做题，题目信息如下：</p><blockquote><p>利用套接字技术实现应用程序中对数据库的访问。应用程序只是利用套接字连接向服务器发送一个查询的条件，而服务器负责对数据库的查询，然后服务器再将查询的结果利用建立的套接字返回给客户端，如下图所示。</p></blockquote><p><img src="https://jaydenchang.gitee.io/images/images/0x0030/0x0030_1.png"></p><p>本来吧，选做题，不太想做的，但是考虑到以后工作的方向和后端相关，那还是做吧。</p><p>本次实验需要做一个GUI界面和一个连接查询功能，在论坛上借鉴了其他大佬获取网站内容的部分代码，然后自己做了一个及其简陋的swing界面，算是把这个实验完成了。</p><p>本次实验项目结构如下</p><pre class="line-numbers language-none"><code class="language-none">--socketProject    |--Client.java    |--GUI.java    |--SearchInfo.java    |--Server.java    |--ServerThread.java</code></pre><h4 id="client.java"><code>Client.java</code></h4><p>客户端使用<code>dis.readUTF()</code>时，要注意再发送个字符或者空字符，这里发送<code>end</code>，表示关闭连接。不然会出现<code>EOFException</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package socketProject;import java.io.*;import java.net.*;public class Client &#123;    String studentNum &#x3D; null;    String result &#x3D; null;    public void setStudentNum(String num) &#123;        this.studentNum &#x3D; num;        System.out.println(&quot;stu: &quot; + studentNum);    &#125;    public void run() throws IOException &#123;        Socket ss &#x3D; new Socket(&quot;127.0.0.1&quot;, 8888);        System.out.println(&quot;Socket: &quot; + ss);        try &#123;            DataInputStream dis &#x3D; new DataInputStream(ss.getInputStream());            DataOutputStream dos &#x3D; new DataOutputStream(ss.getOutputStream());            &#x2F;&#x2F; the interaction            dos.writeUTF(studentNum); &#x2F;&#x2F; 向服务器发送学号            dos.flush();            result &#x3D; dis.readUTF().toString(); &#x2F;&#x2F; 获得客户端的json字符串            System.out.println(result);            dos.writeUTF(&quot;end&quot;); &#x2F;&#x2F; 不加这句会报错            dos.flush();            if (dos !&#x3D; null)                dos.close();            if (dis !&#x3D; null)                dis.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (ss !&#x3D; null)                ss.close();        &#125;    &#125;&#x2F;&#x2F; gui界面用于获取json结果    public String getResult() &#123;        return result;    &#125;&#125;</code></pre><h4 id="server.java"><code>Server.java</code></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package socketProject;import java.io.*;import java.net.*;public class Server extends Thread &#123;    public static final int PORT &#x3D; 8888;    &#x2F;&#x2F; public static void main(String[] args) throws IOException &#123;    public void run() &#123;        try (ServerSocket serverSocket &#x3D; new ServerSocket(PORT)) &#123;            System.out.println(&quot;ServerSocket: &quot; + serverSocket);            try &#123;                while (true) &#123;                    Socket socket &#x3D; serverSocket.accept();                    System.out.println(&quot;Socket accept: &quot; + socket);                    Thread thread &#x3D; new Thread(new ServerThread(socket));                    thread.start(); &#x2F;&#x2F; 开启一个线程，使之支持接收多个客户端的请求                &#125;            &#125; finally &#123;                serverSocket.close();            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="serverthread.java"><code>ServerThread.java</code></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package socketProject;import java.io.*;import java.net.*;public class ServerThread extends Thread &#123;    Socket socket &#x3D; null;    public ServerThread(Socket socket) &#123;        this.socket &#x3D; socket;    &#125;    public void run() &#123;        try &#123;            DataInputStream dis &#x3D; new DataInputStream(socket.getInputStream());            DataOutputStream dos &#x3D; new DataOutputStream(socket.getOutputStream());            while (true) &#123;                String str &#x3D; dis.readUTF().toString();                String data &#x3D; new SearchInfo().run(str);                if (str.equals(&quot;end&quot;))                    break;                dos.writeUTF(data);            &#125;            dos.close();            dis.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="searchinfo.java"><code>SearchInfo.java</code></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package socketProject;import java.io.*;import java.net.*;public class SearchInfo &#123;    public String run(String s) &#123;        String url &#x3D; &quot;your database interface&quot;;        String param &#x3D; s;        String sendGET &#x3D; GetUrl(url, param);        return sendGET;    &#125;        public static String GetUrl(String url, String param) &#123;        String result &#x3D; &quot;&quot;; &#x2F;&#x2F; define the result str        BufferedReader read &#x3D; null; &#x2F;&#x2F; define the access result                try &#123;            URL realUrl &#x3D; new URL(url + param);            URLConnection connection &#x3D; realUrl.openConnection();                        connection.setRequestProperty(&quot;accept&quot;, &quot;*&#x2F;*&quot;);            connection.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);            connection.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;);            &#x2F;&#x2F; 这里补充通用的请求属性            connection.connect(); &#x2F;&#x2F; 建立实际的连接                        read &#x3D; new BufferedReader(new InputStreamReader(connection.getInputStream(), &quot;UTF-8&quot;));            String line;            while ((line &#x3D; read.readLine()) !&#x3D; null) &#123;                result +&#x3D; line;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (read !&#x3D; null) &#123;&#x2F;&#x2F; 关闭流                try &#123;                    read.close();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return result;    &#125;        public String getJSON(String param) &#123;        return param;    &#125;&#125;</code></pre><h4 id="gui.java"><code>GUI.java</code></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package socketProject;import java.awt.*;import java.awt.event.*;import java.io.IOException;import javax.swing.*;public class GUI extends JFrame &#123;    private JButton connectDataBase;    private JLabel entryStudentNum;    private JTextField studentNum;    private JButton sendRequest;    private JLabel showResponseMsg;    private JPanel northPanel;    private JPanel southPanel;    public GUI() &#123;        init();    &#125;    public void init() &#123;        setTitle(&quot;没啥技术含量的东西&quot;);        &#x2F;&#x2F; define the component for the window        connectDataBase &#x3D; new JButton(&quot;连接数据库&quot;);        entryStudentNum &#x3D; new JLabel(&quot;输入学号&quot;);        studentNum &#x3D; new JTextField();        sendRequest &#x3D; new JButton(&quot;发送&quot;);        showResponseMsg &#x3D; new JLabel();        &#x2F;&#x2F; add the component to the panel        this.setLayout(new GridLayout(2, 1));        northPanel &#x3D; new JPanel(new GridLayout(1, 4));        northPanel.add(connectDataBase);        northPanel.add(entryStudentNum);        northPanel.add(studentNum);        northPanel.add(sendRequest);        southPanel &#x3D; new JPanel(new GridLayout(1, 1));        southPanel.add(showResponseMsg);        setButtons();        this.add(northPanel);        this.add(southPanel);        &#x2F;&#x2F; initial the window        setBounds(400, 200, 600, 120);        setResizable(false);        setDefaultCloseOperation(EXIT_ON_CLOSE);        setVisible(true);    &#125;    public void setButtons() &#123;        connectDataBase.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                &#x2F;&#x2F; 这里初始化服务端                Server server1 &#x3D; new Server();                Thread th1 &#x3D; new Thread(server1);                th1.start();                &#x2F;&#x2F; 这里一定要开启服务端线程，否则在点击此按钮后，整个界面会卡住，无法进行下一步操作            &#125;        &#125;);        sendRequest.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                Client client1 &#x3D; new Client();                client1.setStudentNum(studentNum.getText());                &#x2F;&#x2F; 获取文本框的文字，并赋给客户端的studentNum保存                try &#123;                    client1.run();                &#125; catch (IOException e1) &#123;                    e1.printStackTrace();                &#125;                showResponseMsg.setText(client1.getResult());                &#x2F;&#x2F; 将得到的数据显示在界面上            &#125;        &#125;);    &#125;    public static void main(String[] args) &#123;        new GUI();    &#125;&#125;</code></pre><p>最终效果如下：</p><p><img src="https://jaydenchang.gitee.io/images/images/0x0030/0x0030_2.png"></p><p>使用时，先点击连接数据库，然后根据学校提供的接口，输入自己的学号，点击发送，即可查询个人信息。</p><p>不过由于项目工作区非maven以及未来方向非Java的缘故，没有去深究如何提取json的值 <del>(偷个懒)</del>。</p><h4 id="参考链接">参考链接</h4><p><a href="https://blog.csdn.net/dmkaadmk/article/details/52679925">Java请求一个URL，获取返回的数据_杜岚特的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_34697393/article/details/114620733">java.io.datainputstream.readunsignedshort_socket编程报异常java.io.EOFException_窦月汐的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">用Java swing实现一个套接字访问数据库</summary>
    
    
    
    <category term="BackEnd" scheme="https://jaydenchang.top/categories/BackEnd/"/>
    
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>七天用go实现一个web框架</title>
    <link href="https://jaydenchang.top/post/0x002F.html"/>
    <id>https://jaydenchang.top/post/0x002F.html</id>
    <published>2022-08-06T16:00:00.000Z</published>
    <updated>2022-09-30T09:15:50.827Z</updated>
    
    <content type="html"><![CDATA[<hr/><h3 id="前言">前言</h3><p>本文学习自<a href="https://geetktutu.com">geektutu</a> , 大部分内容摘自 <a href="https://geektutu.com/post/gee.html">7天用Go从零实现Web框架Gee教程 | 极客兔兔 (geektutu.com)</a>，并在此基础上稍加个人的学习历程和理解。</p><p>作者仓库地址：<a href="https://github.com/geektutu/7days-golang">geektutu/7days-golang: 7 days golang programs from scratch (web framework Gee, distributed cache GeeCache, object relational mapping ORM framework GeeORM, rpc framework GeeRPC etc) 7天用Go动手写/从零实现系列 (github.com)</a></p><h3 id="day0.-设计一个框架">day0. 设计一个框架</h3><p>大部分时候 , 实现一个Web应用 , 第一反应是用哪个框架 , 在Golang中 , 新框架层出不穷 , 例如<code>Beego</code> , <code>Gin</code> , <code>Iris</code> 等 , 那为什么不用标准库 , 而必须使用框架呢 ? 在设计一个框架时 , 我们需要知道核心框架为我们解决了什么问题 , 只有明白这一点 , 才能想明白我们要在框架内实现什么功能。</p><p>刚好最近学院开展了一个软件实训课程 , 在五天之内搭好了一个Java游戏框架 , 基本框架搭好之后 , 只需要替换配置文档和游戏元素 , 就可以做出另一款新的游戏 , 当然 , 在理解这个框架的搭建思路的背后是异常痛苦的 (前后花了6天左右去看课程视频 , 各种修bug) , 在做出作品那一刻，虽然运行起来的会让人莫名想笑 , 心情舒畅，不过总算实现了代码和人一个能跑了bushi , 很敬佩游戏框架设计师的奇思妙想 <del>(脑洞)</del> 。</p><p>有点扯远了 , 我们先看看Golang标准库<code>net/http</code>如何处理一个请求。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;net&#x2F;http&quot;    &quot;fmt&quot;)func main() &#123;    http.HandleFunc(&quot;&#x2F;&quot;, handler)    http.HandleFunc(&quot;&#x2F;count&quot;, handler)    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))&#125;func handler(w http.ResponseWriter, r *http.Request) &#123;    fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, r.URL.Path)&#125;</code></pre><h5 id="基础知识">基础知识</h5><h6 id="interface">interface</h6><p>首先定义一个<code>Animal</code>的接口</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Animal interface &#123;    Speak() string&#125;</code></pre><p>golang中没有 implements 关键字，那么如何实现接口呢？</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Dog struct &#123;&#125;func (d Dog) Speak() string &#123;    return &quot;Woof!&quot;&#125;type Cat struct &#123;&#125;func (c Cat) Speak() string &#123;    return &quot;Meow!&quot;&#125;&#x2F;&#x2F; 只要实现了Speak()，就算是实现了Animal接口</code></pre><h6 id="interface-1">interface</h6><p>interface{} 类型，空接口，很容易和interface弄混。interface{} 是没有方法的接口。由于没有 implements 关键字，所以所有类型都至少实现了0个方法，所以 <strong>所有类型都实现了空接口</strong>。这意味着，如果在写一个函数以 interface{} 为参数，那么可以为该函数提供任何值。例如</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func DoSomething(v interface&#123;&#125;) &#123;    &#x2F;&#x2F; ...&#125;</code></pre><p>在DoSomething 内部，开始我也认为v时任意类型，但这是错误的，v 不是任意类型，它的静态类型是<code>interface&#123;&#125;</code>类，动态类型由传入的参数的类型决定，当然返回参数时，就不要返回<code>interface&#123;&#125;</code>类了。</p><p><code>interface&#123;&#125;</code>可以承载任意值，但不代表任意类型就可以承接空接口类型的值。当将值传递给DoSomething 函数时，golang将执行类型转换 (if necessary)，并将值转换为<code>interface&#123;&#125;</code>类型的值。</p><blockquote><p>题外话，<code>interface&#123;&#125;</code>动态类型慎用，特别是面对需求容易改动的项目，另外，一般不要对动态类型的值进行比较操作</p></blockquote><h6 id="http.responsewriter">http.ResponseWriter</h6><p>首先需要了解<code>HandleFunc</code>这个函数的一些信息，其声明如下。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;    DefaultServeMux.HandleFunc(pattern, handler)&#125;</code></pre><p>在main函数中，字符串部分容易理解，那handler呢，来看看它的参数的源码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type ResponseWriter interface &#123;    Header() Header    Write([]byte) (int, error)    WriteHeader(statusCode int)&#125;</code></pre><p>还是不太清楚，再点击<code>Header</code>看看。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Header map[string][]string</code></pre><p>http.Header结构包含请求头信息，常见信息实例如下。</p><pre class="line-numbers language-none"><code class="language-none">Host: example.comaccept-encoding: gzip, deflateAccept-Language: en-usfoo: Bar</code></pre><p>接下来看看<code>Write([]byte) (int, error)</code>，这是一个接口，实现通用的<code>io.Writer</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Writer interface &#123;    Write(p []byte) (n int, err error)    &#x2F;&#x2F; 这个byte其实是个切片,而Write方法在server.go里被重写了,具体先不贴代码,本身含有Fprintf方法,后文会用到&#125;</code></pre><p>最后到<code>WriteHeader(statusCode int)</code>。</p><p><code>WriteHeader</code>这个方法名有点误导，并不是来设置响应头的，该方法支持传入一个整形数据表示响应状态码，不调用该方法的话，默认值是<code>200 OK</code>。</p><h6 id="http.request">http.Request</h6><p>直接看源码的声明。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Request struct &#123;    Method string    URL *url.URL    Proto string   &#x2F;&#x2F;eg &quot;HTTP&#x2F;1.0&quot;    ProtoMajor int      ProtoMinor int    Header Header    Body io.ReaderCloser    GetBody func() (io.ReadCloser, error)    ContentLength int64    TransferEncoding []string    Close bool    Host string    Form url.Values    PostForm url.Values    MultipartForm *multipart.Form    Trailer Header    RemoteAddr string    RequestURI string    TLS *tls.ConnectionState    Cancel &lt;-chan struct&#123;&#125;    Response *Response    ctx context.Context&#125;</code></pre><p>常见的Request报文段信息如下：</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day0_2.jpg'></p><h6 id="http.listenandserve">http.ListenAndServe</h6><pre class="line-numbers language-go" data-language="go"><code class="language-go">func ListenAndServe(addr string, handler Handler) error &#123;    server :&#x3D; &amp;Server&#123;Addr: addr, Handler: handler&#125;    return server.ListenAndServe()&#125;</code></pre><p>在<code>ListenAndServe</code>中，再查看<code>Server</code>和<code>ListenAndServe()</code>的源码</p><blockquote><p>http.Server</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Server struct &#123;Addr string   &#x2F;&#x2F; 服务器的IP地址和端口信息    Handler Handler  &#x2F;&#x2F; 请求处理函数的路由复用器    ReadTimeout time.Duration    WriteTimeout time.Duration    MaxHeaderBytes int    TLSConfig *tls.Config    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)    ConnState func(net.Conn, ConnState)    ErrorLog *log.Logger    disableKeepAlives int32&#125;</code></pre><blockquote><p>http.ListenAndServe()</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (srv *Server) ListenAndServe() error &#123;    if srv.shuttingDown() &#123;        return ErrServerClosed  &#x2F;&#x2F; 如果Server已关闭，直接返回ErrServerClosed    &#125;    addr :&#x3D; srv.Addr    if addr &#x3D;&#x3D; &quot;&quot; &#123;        addr &#x3D; &quot;:http&quot;    &#125;    ln, err :&#x3D; net.Listen(&quot;tcp&quot;, addr)     if err !&#x3D; nil &#123;        return err    &#125;    return srv.Serve(ln)&#125;</code></pre><p>在本例中，传入了端口号和handler，如果不指定ip就用本机地址 (localhost)，如果不指定服务器地址信息，则默认以<code>:http</code>作为地址信息</p><h6 id="fmt.fprintf">fmt.Fprintf</h6><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Fprintf(w io.Writer, format string, a ...any) (n int, err error) &#123;    p :&#x3D; newPrinter()    p.doPrintf(format, a)    n, err &#x3D; w.Write(p.buf)    p.free()    return&#125;</code></pre><h6 id="log.fatal">log.Fatal</h6><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Fatal(v ...any) &#123;    std.Output(2, fmt.Sprint(v...))    os.Exit(1)&#125;</code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (l *Logger) Fatal(v ...any) &#123;    l.Output(2, fmt.Sprint(v...))    os.Exit(1)&#125;</code></pre><p>在函数上面的定义，Fatal等价于<code>Print()</code>，执行完打印直接退出程序，之前通过<code>defer</code>设置延迟的函数不会被运行</p><h5 id="框架说明">框架说明</h5><p><code>net/http</code>提供了基础的Web功能 , 即监听端口 , 解析HTTP报文。一些Web开发中简单的需求并不支持，需要手工实现。</p><ul><li>动态路由 : 例如<code>hello/:name</code> , <code>hello/*</code>这类的规则</li><li>鉴权 (authentication) : 没有分组/统一鉴权的能力 , 需要在每个路由映射的handler中实现</li><li>模板 : 没有统一简化的HTML机制</li><li>...</li></ul><p>可以发现，当我们离开框架，使用基础库时，需要频繁手工处理的地方，就是框架的价值所在。</p><h3 id="day1.-http.handler">day1. http.Handler</h3><h4 id="base1">base1</h4><h5 id="标准库启动web服务">标准库启动Web服务</h5><p>Golang内置了<code>net/http</code>库 , 封装了HTTP网络编程的基础的接口 , 本次复刻的<code>Gee</code> Web框架便是基于<code>net/http</code>的 , 下面通过一个例子 , 简单介绍下这个库的使用。</p><blockquote><p>day1/base1/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;fmt&quot;    &quot;net&#x2F;http&quot;    &quot;log&quot;)func main() &#123;    http.HandleFunc(&quot;&#x2F;&quot;, indexHandler)    http.HandleFunc(&quot;&#x2F;hello&quot;, helloHandler)    log.Fatal(http.ListenAndServe(&quot;:9999&quot;, nil))&#125;func indexHandler(w.http.ResponseWriter, req *http.Request) &#123;    fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, req.URL.Path)&#125;func helloHandler(w http.ResponseWriter, req *http.Request) &#123;    for k, v :&#x3D; range req.Header &#123;        fmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\n&quot;, k, v)    &#125;&#125;</code></pre><p>在上面 , 设置了两个路由 , <code>/</code>和<code>/hello</code> , 分别绑定<code>indexHandler</code>和<code>helloHandler</code> , 根据不同的HTTP请求会调用不同的处理函数 , 访问<code>/</code> , 响应是<code>URL.Path=/</code> , 而<code>/hello</code>的相应则是请求头 (header)中键值对信息。</p><p>用curl工具测试 , 会得到以下结果。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;URL.Path &#x3D; &quot;&#x2F;&quot;$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloHeader[&quot;User-Agent&quot;]&#x3D;[&quot;curl&#x2F;7.68.0&quot;]Header[&quot;Accept&quot;]&#x3D;[&quot;*&#x2F;*&quot;]$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloWorldURL.Path &#x3D; &quot;&#x2F;helloWorld&quot;</code></pre><p>main函数的最后一行 , 是来启动服务的 , 第一个是参数地址 , <code>:9999</code>表示在<code>9999</code>端口监听 , 而第二个参数则代表处理所有的HTTP请求的实例 , <code>nil</code>代表使用标准库中的实例处理 , 也是我们基于<code>net/http</code>标准库实现Web框架的入口。</p><p>这里第三个命令 , 访问了<code>/helloWorld</code> , 而在文件中未定义<code>/helloWorld</code>这个路由 , 用curl工具仅从测试 , 得到的却是<code>URL.Path</code> , 关于这个bug , 后文会进行修改。</p><h5 id="实现http.handler接口">实现http.Handler接口</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go">package httptype Handler interface &#123;    ServeHTTP(w ResponseWriter, r *Request)&#125;func ListenAndServe(address string, h Handler) error</code></pre><p>查阅<code>net/http</code>源码发现 , <code>Handler</code>是一个接口 , 需要实现方法 ServeHTTP , 也就是说 , 只要传入任何实现了 ServeHTTP接口的实例 , 所有的HTTP请求 , 就都交给了该实例处理。</p><h4 id="base2">base2</h4><blockquote><p>day1/base2/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;fmt&quot;    &quot;log&quot;    &quot;net&#x2F;http&quot;)type Engine struct&#123;&#125;&#x2F;&#x2F; 定义一个空的结构体,并命名为Engine,后期可以直接用Engine加&#39;.&#39;加成员名的方式调用func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;    &#x2F;&#x2F; 这里engine作为Engine类型的对象,拥有Engine的所有方法    switch req.URL.Path &#123;        case &quot;&#x2F;&quot;:            fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, req.URL.Path)        case &quot;&#x2F;hello&quot;:            for k, v :&#x3D; range req.Header &#123;                fmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\n&quot;, k, v)            &#125;        default:            fmt.Fprintf(w, &quot;404 NOT FOUND: %s\n&quot;, req.URL)    &#125;&#125;func main() &#123;    engine :&#x3D; new(Engine)    log.Fatal(http.ListenAndServe(&quot;:9999&quot;, engine))&#125;</code></pre><p>后面复盘时，有一点一直搞不懂，究竟<code>ServeHTTP</code>是怎么被调用的？在这个go文件里面，感觉还是得从<code>ListenAndServe</code>下手，<code>ListenAndServe</code>的定义是这样的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func ListenAndServe(addr string, handler Handler) error &#123;    serve :&#x3D; &amp;Server&#123;Addr: addr, Handler: handler&#125; &#x2F;&#x2F; 创建一个Server结构体    return server.ListenAndServe()    &#x2F;&#x2F; 这里开始也还是没怎么看懂,后面也去查了下资料,这里返回的ListenAndServe,传入到Fatal里,如果不报错的话,是正常打印switch中的内容,有错误就打印错误信息&#125;</code></pre><p>继续追溯<code>server.ListenAndServe()</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (srv *Server) ListenAndServe() error &#123;    addr :&#x3D; srv.Addr    if addr &#x3D;&#x3D; &quot;&quot; &#123;        addr &#x3D; &quot;:http&quot;    &#125;    ln, err :&#x3D; net.Listen(&quot;tcp&quot;, addr)    if err !&#x3D; nil &#123;        return err    &#125;    return srv.Serve(ln)&#125;</code></pre><p>此方法只是开始侦听给定的地址,并用新创建的侦听器调用<code>Server</code>方法</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (srv *Server) Serve(l net.Listener) error &#123;    defer l.close()    ...    for&#123;        rw, e :&#x3D; l.Accept()        ...        c :&#x3D; srv.newConn(rw)        c.setState(c.rwc, StateNew)        go c.serve(ctx)    &#125;&#125;</code></pre><p>从<code>Serve</code>方法我们可以看到 , 这是我们接受新连接并开始在它自己的<code>goroutine</code>中处理它的地方</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (c *Conn) serve(ctx context.Context) &#123;    ...    for &#123;        w, err :&#x3D; c.readRequest(ctx)        ...        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)        ...    &#125;&#125;</code></pre><p>在这里 , 才调用了<code>ServeHTTP</code>方法 , 正如我们在上面看到的 , 我们对这个ServeHTTP方法进行重写 , 打印输出HTTP请求的信息</p><hr><p>回到<code>main.go</code> , 这里定义了一个空的结构体<code>Engine</code> , 实现了方法<code>ServrHTTP</code> , 这个方法有两个参数 , 第二个参数是Request , 该对象包含了该HTTP请求的所有信息 , 比如请求地址 , Header和Body等信息 ; 第一个参数是ResponseWriter , 利用ResponseWriter可以构造指针对该请求的相应。</p><p>在main函数里 , 我们给ListenAndServe方法的第二个参数传入了刚才创建的<code>engine</code>实例 , 至此已经踏出了实现Web框架的第一步 , 即将所有的HTTP请求转向了我们自己的处理逻辑 。</p><p>在实现<code>Engine</code>之前 , 我们调用<code>http.HandleFunc</code>实现了路由和Handler的映射 , 也就是只能针对具体的路由写处理逻辑 , 比如<code>\hello</code> , 但在实现<code>engine</code>后 , 我们拦截了所有的HTTP请求 , 拥有了统一的控制入口 , 在这里我们可以自由定义路由映射的规则 , 也可以统一添加一些处理逻辑 , 例如日志 , 异常处理等。</p><p>代码运行结果前两行代码的结果一致 , 第三行代码结果如下。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloWorld404 NOT FOUND: &#x2F;helloWorld</code></pre><h4 id="base3">base3</h4><h5 id="gee框架的雏形">Gee框架的雏形</h5><p>下面重新来组织上面的代码 , 搭建整个框架的雏形。</p><pre class="line-numbers language-none"><code class="language-none">gee&#x2F;  |--gee.go  |--go.modmain.gogo.mod</code></pre><blockquote><p>day1/base3/go.mod</p></blockquote><pre class="line-numbers language-none"><code class="language-none">module examplego 1.18require gee v1.0.0replace gee &#x3D;&gt; .&#x2F;gee</code></pre><blockquote><p>day1/base3/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;fmt&quot;    &quot;net&#x2F;http&quot;    &quot;gee&quot;)func main() &#123;    r :&#x3D; gee.New()    r.GET(&quot;&#x2F;&quot;, func(w http.ResponseWriter, req *http.Request) &#123;        fmt.Fprintf(w, &quot;URL.Path &#x3D; %q\n&quot;, req.URL.Path)    &#125;)        r.GET(&quot;&#x2F;hello&quot;, func(w http.RequestWriter, req *http.Request) &#123;        for k, v :&#x3D; range req.Header &#123;            fmt.Fprintf(w, &quot;Header[%q] &#x3D; %q\n&quot;, k, v)        &#125;    &#125;)        r.Run(&quot;:9999&quot;)&#125;</code></pre><p>在这里 , 使用<code>GET()</code>方法添加路由 , 最后使用<code>Run()</code>启动Web服务 , 这里的路由 , 只是静态路由 , 不支持<code>/hello/:name</code>这样的动态路由 , 动态路由将在下一次实现。</p><blockquote><p>day1/base3/gee/go.mod</p></blockquote><pre class="line-numbers language-none"><code class="language-none">module geego 1.18</code></pre><p>因为我是用vscode进行代码编辑，工作区选择gee的根目录，而不是<code>src</code>，这里的<code>go.mod</code>管理需要做一点额外工作，按照教程写好mod后，会提示无法导入gee模块，查了各种帖子，对<code>Go111Module</code>进行设置也没效果，后面查到了一篇帖子，要在设置里搜 <strong>go.useLanguageServer</strong>，并将其关闭</p><blockquote><p>day1/base3/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package geeimport (    &quot;fmt&quot;    &quot;net&#x2F;http&quot;)type HandlerFunc func(http.ResponseWriter, *http.Request) &#x2F;&#x2F; 定义了一个HandlerFunc的函数类型,其签名必须符合输入为 http.ResponseWriter和*http.Requesttype Engine struct &#123;    router map[string]HandlerFunc&#125;func New() *Engine &#123;    return &amp;Engine&#123;router: make(map[string]HandlerFunc)&#125;&#125;func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) &#123;    key :&#x3D; method + &quot;-&quot; +pattern    engine.router[key] &#x3D; router&#125;func (engine *Engine) GET(pattern string, handler HandlerFunc) &#123;    engine.addRoute(&quot;GET&quot;, pattern, handler)&#125;func (engine *Engine) POST(pattern string, handler HandlerFunc) &#123;    engine.addRoute(&quot;POST&quot;, pattern, handler)&#125;func (engine *Engine) Run(addr string) (err error) &#123;    return http.ListenAndServe(addr, engine)&#125;func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;    key :&#x3D; req.Method + &quot;-&quot; + req.URL.Path    if handlerm ok :&#x3D; engine.router[key]; ok &#123;        hanlder(w, req)    &#125; else &#123;        fmt.Fprintf(w, &quot;404 NOT FOUND: %s\n&quot;, req.URL)    &#125;&#125;</code></pre><p>在<code>gee.go</code> , 介绍下这几部分的实现。</p><ul><li>定义了类型<code>HandlerFunc</code> , 这是提供给框架用户的 , 用来定义路由映射的基本方法。我们在<code>Engine</code>中，添加了一张路由映射表<code>router</code>，key由请求方法和静态路由地址构成，例如<code>GET-/</code>，<code>GET-/hello</code>，<code>POST-/hello</code>，这样针对相同的路由，如果请求方式不同，可以映射不同的处理方法(Handler)，value是用户映射的处理方法。</li><li>当用户调用<code>(*Engine).Run()</code>方法，会将路由和处理方法注册到映射表router中，<code>(*Engine).Run()</code>，是 ListenAndServe的包装。</li><li><code>Engine</code>实现的ServeHTTP方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法，如果查不到，就返回404 NOT FOUND。</li></ul><p>执行<code>go run main.go</code>，再用curl访问，结果和base2的结果一致</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;URL.Path &#x3D; &quot;&#x2F;&quot;$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloHeader[&quot;Accept&quot;] &#x3D; [&quot;*&#x2F;*&quot;]Header[&quot;User-Agent&quot;] &#x3D; [&quot;curl&#x2F;7.68.0&quot;]$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;helloWorld404 NOT FOUND: &#x2F;helloWorld</code></pre><p>至此，整个Gee框架的原型就已经出来了。有了基本路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。当然到目前为止，我们还没有实现比<code>net/http</code>标准库更强大的能力，这些会在后面将动态路由、中间件等功能添加上去。</p><h3 id="day2.-上下文-context">day2. 上下文 Context</h3><ul><li>将 路由(router) 独立出来 , 方便之后改进。</li><li>设计 上下文 (Context)，封装 Request和 Response，提供对JSON、HTML等返回类型的支持。</li><li>第二天的框架内容，代码约140行，新增约90行。</li><li>后面每一天贴出的代码基本为原文件基础上新增的内容或修改后的内容</li></ul><h4 id="设计context">设计Context</h4><h5 id="必要性">必要性</h5><ol type="1"><li>对Web服务来说，无非是根据请求<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的相应，需要考虑消息头(Header)和消息体(Body)，而Header包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写大量重复、繁冗的代码，且容易出错。针对常用场景，能够高效地构造出HTTP相应是一个好的框架必须考虑的点。</li></ol><p>用返回JSON数据作比较，对比封装前后的差异：</p><blockquote><p>封装前</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">obj &#x3D; map[string]interface&#123;&#125; &#123;    &quot;name&quot;: &quot;abc&quot;,    &quot;password&quot;: &quot;1234&quot;,&#125;w.Header().Set(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)w.WriteHeader(http.StatusOK)encoder :&#x3D; json.NewEncoder(w)if err :&#x3D; encoder.Encode(obj); err !&#x3D; nil &#123;    http.Error(w, err.Error(), 500)&#125;</code></pre><blockquote><p>封装后</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">c.JSON(http.StatusOK, gee.H&#123;    &quot;username&quot;: c.PostForm(&quot;username&quot;),    &quot;password&quot;: c.PostForm(&quot;password&quot;),&#125;)</code></pre><ol start="2" type="1"><li>针对使用场景，封装<code>*http.Request</code>和<code>http.ResponseWriter</code>的方法，简化相关接口的调用，只是设计Context的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由<code>/hello/:name</code>，参数<code>name</code>的值放在哪？再比如，框架需要支持中间件，那中间件产生的信息放在哪？Context随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由Context承载。因此，设计Context结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都统一使用Context实例</li></ol><h5 id="具体实现">具体实现</h5><blockquote><p>day2/gee/context.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type H map[string]interface&#123;&#125;type Context struct &#123;    &#x2F;&#x2F; origin objects    Writer http.ResponseWriter    Req *http.Request    &#x2F;&#x2F; request info    Path string    Method string    &#x2F;&#x2F; response info    StatusCode int&#125;func newContext(w http.ResponseWriter, req *http.Request) *Context &#123;    return &amp;Context &#123;        Writer: w,        Req req,        Path: req.URL.Path,        Method: req.Method,    &#125;&#125;func (c *Context) PostForm(key string) string &#123;    return c.Req.FormValue(key)&#125;func (c *Context) Query(key string) string &#123;    return c.Req.URL.Query().Get(key)&#125;func (c *Context) Status(code int) &#123;    c.StatusCode &#x3D; code    c.Writer.WriteHeader(code)&#125;func (c *Context) SetHeader(key string, value string) &#123;    c.Writer.Header().Set(key, value)&#125;func (c *Context) String(code int, format string, values ...interface&#123;&#125;) &#123;    c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;plain&quot;)    c.Status(code)    c.Writer.Write([]byte(fmt.Sprintf(format, values...)))&#125;func (c *Context) JSON(code int, obj interface&#123;&#125;) &#123;    c.SetHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)    c.Status(code)    encoder :&#x3D; json.NewEncoder(c.Writer)    if err :&#x3D; encoder.Encode(obj); err !&#x3D; nil &#123;        http.Error(c.Writer, err.Error(), 500)    &#125;    &#x2F;&#x2F; 这里的obj,在后文的测试中,就是一个map,输出为[&quot;passowrd&quot;:&quot;xxx&quot;,&quot;username&quot;:&quot;xxx&quot;]&#125;func (c *Context) Data(code int, data []byte) &#123;    c.Status(code)    c.Writer.Write(data)&#125;func (c *Context) HTML(code int, html string) &#123;    c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;)    c.Status(code)    c.Writer.Write([]byte(html))&#125;</code></pre><ul><li>代码最开头，给<code>map[string]interface&#123;&#125;</code>起了一个别名<code>gee.H</code>，构建JSON数据时，显得更简洁。</li><li><code>Context</code>目前只包含了<code>http.ResponseWriter</code>和<code>*http.Request</code>，另外提供了对Method和Path这两个常用的属性的直接访问。</li><li>提供了访问Query和PostForm参数的方法。</li><li>提供了快速构造String/Data/JSON/HTML相应的方法。</li></ul><h4 id="路由router">路由(Router)</h4><p>我们将和路由相关的方法和结构提取了出来，放到了一个新的文件<code>router.go</code>，方便下一次对router的功能进行增强，例如提供动态路由的支持。router的handle方法作了一个细微的调整，即handler的参数，变成了Context。</p><blockquote><p>day2/gee/router.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type router struct &#123;    handlers map[string]HandlerFunc&#125;func newRouter() *router &#123;    return &amp;router&#123;handlers: make(map[string]HandlerFunc)&#125;&#125;func (r *router) addRoute(method string, pattern string, handler HandlerFunc) &#123;    log.Printf(&quot;Route %4s - %s&quot;, method, pattern)    key :&#x3D; method + &quot;-&quot; + pattern    r.handlers[key] &#x3D; handler    &#x2F;&#x2F; 注册路由&#125;func (r *router) handle(c *Context) &#123;    key :&#x3D; c.Method + &quot;-&quot; + c.Path    if handler, ok :&#x3D; r.handlers[key]; ok &#123;        &#x2F;&#x2F; 这里根据输入的方法和路径查找handlers中值,返回HandlerFunc,赋给handler,此时handler就是一个带有HandlerFunc签名的函数(http.ResponseWriter和*http.Request),输入的参数类型为*Context,handler再根据输入的Context        handler(c)    &#125; else &#123;        c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\n&quot;, c.Path)    &#125;&#125;</code></pre><h4 id="框架入口">框架入口</h4><blockquote><p>day2/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package geeimport &quot;net&#x2F;http&quot;&#x2F;&#x2F; HandlerFunc defines the request handler used by gee&#x2F;&#x2F; HandlerFunc包含Context所有属性和方法type HandlerFunc func(*Context)&#x2F;&#x2F; Engine implement the interface of ServeHTTPtype Engine struct &#123;    router *router&#125;&#x2F;&#x2F; New is the constructor of gee.Enginefunc New() *Engine &#123;    return &amp;Engine&#123;router: newRouter()&#125;&#125;func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) &#123;    engine.router.addRoute(method, pattern, handler) &#x2F;&#x2F; 调用router的addRoute方法    &#x2F;&#x2F; router的addRoute方法类似于一个私有函数,通过engine的addRoute传入参数再传递给router&#125;&#x2F;&#x2F; 把第一天的addRoute修改为这样,</code></pre><p>将<code>router</code>相关的代码独立后，<code>gee.go</code>简单了不少。最重要的还是通过实现了ServeHTTP接口，接管了所有的HTTP请求。相比第一天的diamond，这个方法也有细微的调整，在调用router.handle之前，构造了一个Context对象。这个对象目前还非常简单，仅仅是包装了原来的两个参数，之后我们会慢慢地给Context加上更多内容。</p><blockquote><p>day2/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport(    &quot;net&#x2F;http&quot;    &quot;gee&quot;)func main() &#123;    r :&#x3D; gee.New()    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;\n&quot;)    &#125;)     &#x2F;&#x2F; 思路: 向GET传入一个&quot;&#x2F;&quot;的路由和一个匿名的HandlerFunc函数,该函数内部含有相关HTTP请求信息(HTML函数),然后GET把这个路由和handler传给engine的addRoute,经过套娃,再到达router的addRoute    &#x2F;&#x2F; 下面的GET也同理,只不过String和HTML传入的切片不同    r.GET(&quot;&#x2F;hello&quot;, func(c *gee.Context) &#123;        &#x2F;&#x2F; expect &#x2F;hello?name&#x3D;abc        c.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Query(&quot;name&quot;), c.Path)    &#125;)    r.POST(&quot;&#x2F;login&quot;, func(c *gee.Context) &#123;        &#x2F;&#x2F; 在服务器端输出的是 &quot;POST - &#x2F;login&quot;        c.JSON(http.StatusOK, gee.H&#123;            &quot;username&quot;: c.PostForm(&quot;username&quot;),            &quot;password&quot;: c.PostForm(&quot;password&quot;),        &#125;)    &#125;)    r.Run(&quot;:9999&quot;)&#125;</code></pre><p>运行<code>main.go</code>，看看day2的成果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">$ curl -i http:&#x2F;&#x2F;localhost:9999&#x2F;HTTP&#x2F;1.1 200 OKContent-Type: text&#x2F;htmlDate: Fri, 08 Jul 2022 08:29:52 GMTContent-Length: 19&lt;h1&gt;Hello Gee&lt;&#x2F;h1&gt;$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;hello?name&#x3D;abchello abc, you&#39;re at&#x2F;hello$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;login -X POST -d &quot;username&#x3D;abc&amp;password&#x3D;1234&quot;&#123;&quot;password&quot;:&quot;1234&quot;,&quot;username&quot;:&quot;abc&quot;&#125;$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;xxx404 NOT FOUND: &#x2F;xxx</code></pre><p>服务器端输出</p><pre class="line-numbers language-none"><code class="language-none">2022&#x2F;07&#x2F;09 11:38:15 Route  GET - &#x2F;2022&#x2F;07&#x2F;09 11:38:15 Route  GET - &#x2F;hello2022&#x2F;07&#x2F;09 11:38:15 Route POST - &#x2F;login</code></pre><h3 id="day3-前缀树路由router">day3 前缀树路由Router</h3><ul><li>使用Trie树实现动态路由(dynamic route)解析。</li><li>支持两种模式<code>:name</code>和<code>*filepath</code>，代码约150行。</li></ul><h4 id="trie树简介">Trie树简介</h4><p>之前，用了一个非常简单的<code>map</code>结构存储了路由表，用<code>map</code>存储键值对，索引非常高效，但是有一个弊端，键值对的存储方式，只能来索引静态路由。如果我们想支持类似于<code>/hello/:name</code>这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类型而并非某一条固定的路由，例如<code>/hello/:name</code>，可以匹配<code>/hello/abc</code>，<code>/hello/jayden</code>等。</p><p>动态路由有很多种实现方式，支持的规则，性能等有很大的差异。例如开源的路由实现<code>gorouter</code>支持在路由规则种嵌入正则表达式，例如<code>/p/[0-9A-Za-z]+</code>，即路径种的参数仅匹配数字和字母；另一个开源实现<code>httprouter</code>就不支持正则表达式。Web开源框架<code>gin</code>在早期的版本没有实现自己的路由，而是直接用了<code>httprouter</code>，后来又放弃了<code>httprouter</code>，自己实现了一个版本。</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day3_trie_tree.jpg'></p><p>实现动态路由最常用的数据结构，被称为前缀树(Trie树)。每个节点的所有子节点都有相同的前缀。这种结构非常适用于路由匹配，例如我们定义了如下路由规则：</p><ul><li><code>/:lang/doc</code></li><li><code>/:lang/tutorial</code></li><li><code>/:lang/intro</code></li><li><code>/about</code></li><li><code>/p/blog</code></li><li><code>/p/related</code></li></ul><p>我们用前缀树表示，是这样的：</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day3_trie_tree_web.jpg'></p><p>HTTP请求的路径恰好是由<code>/</code>分割的多端构成的，因此，每一段可以作为前缀树的一个节点。我们通过树结构查询，如果中间某一层的节点都不满足条件，那么就说明没有匹配到的路由，查询结束。</p><p>接下来我们实现的动态路由具备以下俩功能：</p><ul><li>参数匹配：例如<code>/p/:lang/doc</code>，可以匹配<code>/p/c/doc</code>和<code>p/go/doc</code>。</li><li>通配<code>*</code>，例如<code>/static/*filepath</code>，可以匹配<code>/static/fav.ico</code>，也可以匹配<code>/static/js/jQuery.js</code>，这种模式常用于静态服务器，能够递归地匹配子路径。</li></ul><h4 id="trie树实现">Trie树实现</h4><p>首先需要设计树节点上应存储哪些信息。</p><blockquote><p>day3/gee/trie.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type node struct &#123;    pattern string &#x2F;&#x2F; 待匹配路由，例如 &#x2F;p&#x2F;:lang    part string &#x2F;&#x2F; 路由中一部分，例如 :lang    children []*node &#x2F;&#x2F; 子节点，例如 [doc, tutorial, intro]    isWild bool &#x2F;&#x2F; 是否精确匹配，part含有 : 或 * 时为true&#125;&#x2F;&#x2F; 这里重写String函数,便于后期查看相关参数的值(直接输出n.children是打印地址)func (n node) String() string &#123;    return fmt.Sprintf(&quot;pattern:%s, part:%s, children:%s, isWild:%t&quot;, n.pattern, n.part, n.children, n.isWild)&#125;</code></pre><p>与普通的树不同，为了实现动态路由匹配，加上了<code>isWild</code>这个参数。即当我们匹配<code>/p/go/doc</code>这个路由时 (<code>/</code>算0个节点) ，第一层节点，<code>p</code>精确匹配到了<code>p</code>，第二层节点，<code>go</code>模糊匹配到<code>:lang</code>，那么会将<code>lang</code>这个参数赋值为<code>go</code>，继续下一层匹配。我们将匹配的逻辑，包装为一个辅助函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 第一个匹配成功的节点，用于插入func (n *node) matchChild(part string) *node &#123;    for _, child :&#x3D; range n.children &#123;        &#x2F;&#x2F; 这里之前一直没搞懂为什么要忽略range的第一个参数,查阅资料后发现,第一个参数是索引值index,第二个参数是value,这里第二个参数,就是n的子节点        if child.part &#x3D;&#x3D; part || child.isWild &#123;            return child        &#125;    &#125;    return nil&#125;&#x2F;&#x2F; 所有匹配成功的节点，用于查找func (n *node) matchChildren(part string) []*node &#123;    nodes :&#x3D; make([]*node, 0) &#x2F;&#x2F; new一个长度为0的切片    for _, child :&#x3D; range n.children &#123;        if child.part &#x3D;&#x3D; part || child.isWild &#123;            nodes &#x3D; append(nodes, child)            &#x2F;&#x2F; 将匹配成功的节点加入到nodes中        &#125;    &#125;    return nodes&#125;</code></pre><p>对于路由来说，最重要的当然是注册于匹配了。开发服务时，注册路由规则，映射handler；访问时，匹配路由规则，查找到对应的handler。因此，Trie树需要支持节点的插入与查询。插入功能很简单，递归查找每一层的节点，如果没有匹配到当前<code>part</code>的节点，则新建一个，有一点需要注意，<code>/p/:lang/doc</code>只有在第三层节点，即<code>doc</code>节点，<code>pattern</code>才会设置为<code>/p/:lang/doc</code>。<code>p</code>和<code>:lang</code>节点的<code>pattern</code>属性皆为空。因此，当匹配结束时，我们可以用<code>n.pattern == ""</code>来判断路由规则是否匹配成功。例如，<code>/p/python</code>虽能成功匹配到<code>:lang</code>，但<code>:lang</code>的<code>pattern</code>值为空，因此匹配失败。查询功能，同样也是递归查询每一层的节点，退出规则是，匹配到 * ，匹配失败，或匹配到第<code>len(parts)</code>层节点。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (n *node) insert(pattern string, parts []string, height int) &#123;    if len(parts) &#x3D;&#x3D; height &#123;&#x2F;&#x2F; 这里其实是层层递归        n.pattern &#x3D; pattern        return    &#125;        part :&#x3D; parts[height]    child :&#x3D; n.matchChild(part)    if child &#x3D;&#x3D; nil &#123;        child &#x3D; &amp;node&#123;part: part, isWild: part[0] &#x3D;&#x3D; &#39;:&#39; || part[0] &#x3D;&#x3D; &#39;*&#39;&#125;        n.children &#x3D; append(n.children, child)    &#125;    child.insert(pattern, parts, height + 1)&#125;func (n *node) search(parts []string, height int) *node &#123;    if len(parts) &#x3D;&#x3D; height || strings.HasPrefix(n.part, &quot;*&quot;) &#123;        if n.pattern &#x3D;&#x3D; &quot;&quot; &#123;            return nil        &#125;        &#x2F;&#x2F; 若以*为开头的字串,直接以此节点为当前分支尾节点        return n    &#125;        part :&#x3D; parts[height]    &#x2F;&#x2F; (height+1)的值是当前搜索的层数    children :&#x3D; n.matchChildren(part)    &#x2F;&#x2F; children则含有搜索到每一层的part        for _, child :&#x3D; range children &#123;        result :&#x3D; child.search(parts, height + 1)        if result !&#x3D; nil &#123;            return result        &#125;    &#125;        return nil&#125;func (n *node) travel(list *([]*node)) &#123;    if n.pattern !&#x3D; &quot;&quot; &#123;        *list &#x3D; append(*list, n)    &#125;    for _, child :&#x3D; range n.children &#123;        child.travel(list)    &#125;&#125;</code></pre><h4 id="router">Router</h4><p>Trie树的插入与查找都成功实现了，接下来我们将Trie树应用到路由中。我们用roots来存储每种请求方式的Trie树根节点。使用handlers存储每种请求方式的HandlerFunc。getRoute函数中，还解析了<code>:</code>和<code>*</code>两种匹配符的参数，返回一个 map。例如<code>/p/go/doc</code>匹配到<code>/p/:lang/doc</code>，解析结果为<code>&#123;lang: "go"&#125;</code>，<code>/static/css/gee.css</code>匹配到<code>/static/*filepath</code>，解析结果为<code>&#123;filepath: "css/gee.css"&#125;</code>。</p><blockquote><p>day3/gee/router.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type router struct &#123;    roots map[string]*node    handlers map[string]HandlerFunc&#125;&#x2F;&#x2F; roots key eg, roots[&#39;GET&#39;] roots[&#39;POST&#39;]&#x2F;&#x2F; handlers key eg, handlers[&#39;GET-&#x2F;p&#x2F;:lang&#x2F;doc&#39;], handlers[&#39;POST-&#x2F;p&#x2F;book&#39;]func newRouter() *router &#123;    return &amp;router &#123;        roots: make(map[string]*node),        handlers: make(map[string]HandlerFunc),    &#125;&#125;&#x2F;&#x2F; Only one * is allowedfunc parsePattern(pattern string) []string &#123;    vs :&#x3D; strings.Split(pattern, &quot;&#x2F;&quot;)    &#x2F;&#x2F; 一层层获取并判断是否为有效节点字串    parts :&#x3D; make([]string, 0)    for _, item :&#x3D; range vs &#123;        if item !&#x3D; &quot;&quot; &#123;            parts &#x3D; append(parts, item)            if item[0] &#x3D;&#x3D; &#39;*&#39; &#123;                break                &#x2F;&#x2F; 这里只要当前节点为*,则结束后面的遍历,以*为当前分支尾节点            &#125;        &#125;    &#125;    return parts&#125;func (r *router) addRoute(method string, path string) (*node, map[string]string) &#123;    searchParts :&#x3D; parsePattern(pattern)        key :&#x3D; method + &quot;-&quot; + pattern    _, ok :&#x3D; r.roots[method]&#x2F;&#x2F; 这里卡的比较久,第一个返回值是获取的值,第二个是判断值是否获取成功    if !ok &#123;        r.roots[method] &#x3D; &amp;node&#123;&#125;        &#x2F;&#x2F; 一般来说,对于一个新路由,node默认是空,    &#125;    r.roots[method].insert(pattern, parts, 0)    r.handlers[key] &#x3D; handler&#125;func (r *router) getRoute(method string, path string) (*node, map[string]string) &#123;    searchParts :&#x3D; parsePattern(path)    params :&#x3D; make(map[string]string)    root, ok :&#x3D; r.roots[method]        if !ok &#123;        return nil, nil    &#125;        n :&#x3D; roots.search(searchParts, 0)        if n !&#x3D; nil &#123;        parts :&#x3D; parsePattern(n.pattern)        for index, part :&#x3D; range parts &#123;            &#x2F;&#x2F; getRoute的参数匹配,这里匹配:和*两种字符            if part[0] &#x3D;&#x3D; &#39;:&#39; &#123;                params[part[1:]] &#x3D; searchParts[index]            &#125;            if part[0] &#x3D;&#x3D; &#39;*&#39; &amp;&amp; len(part) &gt;1 &#123;                params[part[1:]] &#x3D; strings.Join(searchParts[index:], &quot;&#x2F;&quot;)                break            &#125;        &#125;        return n, params    &#125;    return nil, nil&#125;func (r *router) getRoutes(method string) []*node &#123;    root, ok :&#x3D; r.roots[method]    if !ok &#123;        return nil    &#125;    nodes :&#x3D; make([]*node, 0)    root.travel(&amp;nodes)    return nodes&#125;</code></pre><h4 id="context与handle的变化">Context与handle的变化</h4><p>在HandleFunc中，希望能够访问到解析的参数，因此，需要对Context对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数储存到<code>Params</code>中，通过<code>c.Param("lang")</code>的方式获取到对应的值。</p><blockquote><p>day3/gee/context.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Context struct &#123;    &#x2F;&#x2F; origin objects    Writer http.ResponseWriter    Req *http.Request    &#x2F;&#x2F; request info    Path string    Method string    Params map[string]string    &#x2F;&#x2F; response info    StatusCode int&#125;func (c *Context) Param(key string) string &#123;    value :&#x3D; c.Params[key]     return value&#125;</code></pre><blockquote><p>day3/gee/router.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (r *router) handle(c *Context) &#123;    n, params :&#x3D; r.getRoute(c.Method, c.Path)    if n !&#x3D; nil &#123;        c.Params &#x3D; params        key :&#x3D; c.Method + &quot;-&quot; +n.pattern        r.handlers[key](c)    &#125; else &#123;        c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\n&quot;, c.Path)    &#125;&#125;</code></pre><p><code>router.go</code>的变化比较小，比较重要的一点是，在调用匹配到的<code>handler</code>前，将解析出来的路由参数赋值给了<code>c.Params</code>。这样就能够在<code>handler</code>中，通过<code>Context</code>对象访问到具体的值了</p><h4 id="单元测试">单元测试</h4><blockquote><p>router_test.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package geeimport (    &quot;fmt&quot;    &quot;reflect&quot;    &quot;testing&quot;)func newTestRouter() *router &#123;    r :&#x3D; newRouter()    r.addRoute(&quot;GET&quot;, &quot;&#x2F;&quot;, nil)    r.addRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;:name&quot;, nil)    r.addRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;b&#x2F;c&quot;, nil)    r.addRoute(&quot;GET&quot;, &quot;&#x2F;hi&#x2F;:name&quot;, nil)    r.addRoute(&quot;GET&quot;, &quot;&#x2F;assets&#x2F;*filepath&quot;, nil)    return r&#125;func TestParsePattern (t *testing.T) &#123;    r :&#x3D; newTestRouter()    ok :&#x3D; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;:name&quot;), []string&#123;&quot;p&quot;, &quot;:name&quot;&#125;)    ok &#x3D; ok &amp;&amp; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;*&quot;), []sring&#123;&quot;p&quot;, &quot;*&quot;&#125;)    ok &#x3D; ok &amp;&amp; reflect.DeepEqual(parsePattern(&quot;&#x2F;p&#x2F;*name&#x2F;*&quot;), []string&#123;&quot;p&quot;, &quot;*name&quot;&#125;)    if !ok &#123;        t.Fatal(&quot;test parsePattern failed&quot;)    &#125;    &#125;func TestGetRoute(t *testing.T) &#123;    r :&#x3D; newTestRouter()    n, ps :&#x3D; r.getRoute(&quot;GET&quot;, &quot;&#x2F;hello&#x2F;gee&quot;)        if n &#x3D;&#x3D; nil &#123;        t.Fatal(&quot;nil shouldn&#39;t be returned&quot;)    &#125;        if n.pattern !&#x3D; &quot;&#x2F;hello&#x2F;:name&quot; &#123;        t.Fatal(&quot;should match &#x2F;hello&#x2F;:name&quot;)    &#125;        if ps[&quot;name&quot;] !&#x3D; &quot;gee&quot; &#123;        t.Fatal(&quot;should match be equal to gee&quot;)    &#125;        fmt.Printf(&quot;matched path: %s, params[&#39;name&#39;]: %s\n&quot;, n.pattern, ps[&quot;name&quot;])&#125;func TestGetRoute2(t *testing.T) &#123;    r :&#x3D; newTestRouter()    n1, ps1 :&#x3D; r.getRoute(&quot;GET&quot;, &quot;&#x2F;assets&#x2F;file1.txt&quot;)    ok1 :&#x3D; n1.pattern &#x3D;&#x3D; &quot;&#x2F;assets&#x2F;*filepath&quot; &amp;&amp; ps1[&quot;filepath&quot;] &#x3D;&#x3D; &quot;file1.txt&quot;    if !ok1 &#123;        t.Fatal(&quot;pattern should be &#x2F;assets&#x2F;*filepath &amp; filepath should be file1.txt&quot;)    &#125;        n2, ps2 :&#x3D; r.getRoute(&quot;GET&quot;, &quot;&#x2F;assets&#x2F;css&#x2F;test.css&quot;)    ok2 :&#x3D; n2.pattern &#x3D;&#x3D; &quot;&#x2F;assets&#x2F;*filepath&quot; &amp;&amp; ps2[&quot;filepath&quot;] &#x3D;&#x3D; &quot;css&#x2F;test.css&quot;    if !ok2 &#123;        t.Fatal(&quot;pattern should be &#x2F;assets&#x2F;*filepath &amp;filepath should be css&#x2F;test.css&quot;)    &#125;&#125;func TestGetRoutes(t *testing.T) &#123;    r :&#x3D; newTestRouter()    nodes :&#x3D; r.getRoutes(&quot;GET&quot;)    for i, n :&#x3D; range nodes &#123;        fmt.Println(i+1, n)    &#125;        if len(nodes) !&#x3D; 5 &#123;        t.Fatal(&quot;the number of routes should be 4&quot;)    &#125;&#125;</code></pre><h4 id="使用demo">使用DEMO</h4><blockquote><p>day3/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;gee&quot;    &quot;net&#x2F;http&quot;)func main() &#123;    r :&#x3D; gee.New()    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;&lt;h1&gt;Hello gee&lt;&#x2F;h1&gt;&quot;)    &#125;)        r.GET(&quot;&#x2F;hello&quot;, func(c *gee.Context) &#123;        &#x2F;&#x2F; expect &#x2F;hello?name&#x3D;xxx        c.String(http.StatucOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Query(&quot;name&quot;), c.Path)    &#125;)        r.GET(&quot;&#x2F;assets&#x2F;*filepath&quot;, func(c *gee.Context) &#123;        c.JSON(http.StatusOK, gee.H&#123;&quot;filepath&quot;: c.Param(&quot;filepath&quot;)&#125;)    &#125;)        r.Run(&quot;:9999&quot;)&#125;</code></pre><p>使用curl测试</p><pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;hello&#x2F;abchello abd, you&#39;re at &#x2F;hello&#x2F;abc$ curl &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;assets&#x2F;css&#x2F;abc.css&quot;&#123;&quot;filepath&quot;:&quot;css&#x2F;abc.css&quot;&#125;</code></pre><h4 id="day3小结">day3小结</h4><p>之前因为一项暑期实践活动的工作 , 我没有很认真地过一遍 , 也只是草草地敲一遍代码 , 简单地挖几个函数的源码来看 , 后面因为实训项目就先搁置了这个gee框架的学习 , 等做完实训项目后 , 花了半天把代码敲了一遍 , 也运行了一遍 , 但还是觉得心里心里很没底，于是想着，从第一天的内容开始认真看一遍，然后就开始对着前两天的源码一顿操作，开始不断查看源码中函数引用的内容，在关键函数print相关变量，前两天内容并不算很难，到了第三天，可能是跳跃性太大，加上前两天基础不牢，我在这里卡了4天，加上这几天状态不太好，就学的比较慢，这几天意识到事情的严重性，稍微加快了脚步，对第三天的路由部分进行了更多的测试，也对这个路由部分有了更深的认识</p><h3 id="day4.-分组控制group">day4. 分组控制Group</h3><ul><li>本次实现路由分组控制(Route Group Control)，代码约50行。</li></ul><h4 id="分组的意义">分组的意义</h4><p>分组控制(Route Group Control) 是Web框架应提供的基础功能之一。所谓分组，是指的路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如：</p><ul><li>以<code>/post</code>开头的路由匿名可访问</li><li>以<code>/admin</code>开头的路由需要鉴权</li><li>以<code>/api</code>开头的路由时RESTful接口 , 可以对接第三方平台 , 需要三方平台鉴权</li></ul><p>大部分情况下的路由分组 , 是以相同的前缀来区分的。因此，我们今天实现的分组控制也是以前缀来区分，并支持分组的嵌套。例如<code>/post</code>是一个分组，<code>/post/a</code>和<code>/post/b</code>可以是该分组下的子分组。作用在<code>/post</code>分组上 中间件(middleware)，也都会作用在子分组，子分组还可以应用自己特有的中间件。</p><p>中间件可以给框架提供无限的扩展能力，应用在分组上，可以使得分组控制的收益更为明显，而不是共享相同的路由前缀这么简单。例如<code>/admin</code>的分组，可以应用鉴权中间件；<code>/</code>分组应用日志中间件，<code>/</code>是默认的最顶层的分组，也就意味着给所有的路由，即整个框架增加了日志的能力。</p><p><strong>分组嵌套</strong></p><p>一个Group对象需要具备哪些属性呢？首先是前缀(prefix)，比如<code>/</code>，或者<code>/api</code>；要支持分组嵌套，那么需要知道当前分组的父亲(parent)是谁；当然了，按照我们一开始的分析，中间件是应用在分组上的，那还需要储存应用在该分组上的中间件(middlewares)。还记得，我们之前调用函数<code>*(Engine).addRoute()</code>来映射所有的路由规则和 Handler。如果Group对象需要直接映射路由规则的画，比如我们想在使用框架时，这么调用</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r :&#x3D; gee.New()v1 :&#x3D; r.Group(&quot;&#x2F;v1&quot;)v1.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;    c.HTML(http.StatusK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;&quot;)&#125;)</code></pre><p>那么Group对象，还需要有访问<code>Router</code>的能力，为了方便，我们可以在Group中，保存一个指针，指向<code>Engine</code>，整个框架的所有资源都是由<code>Engine</code>统一协调的，那么就可以通过<code>Engine</code>间接地访问各种接口了。</p><p>所以，最后的Group做出以下改动：</p><blockquote><p>day4/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type HandlerFunc func(*Context)type (    RouterGroup struct &#123;        prefix string        middlewares []HandlerFunc        parent *RouterGroup        engine *Engine    &#125;    &#x2F;&#x2F; 进一步抽象，将Engine作为最顶层的分组，也就是说Engine拥有RouterGroup的所有能力    Engine struct &#123;        *RouterGroup        router *router        groups []*RouterGroup    &#125;)&#x2F;&#x2F; 下面是实现和路由有关的函数func New() *Engine &#123;    engine :&#x3D; &amp;Engine&#123;router: newRouter()&#125;    engine.RouterGroup &#x3D; &amp;RouterGroup&#123;engine: engine&#125;    engine.groups &#x3D; []*RouterGroup&#123;engine.RouterGroup&#125;    return engine&#125;func (group *RouterGroup) Group(prefix string) *RouterGroup &#123;    engine :&#x3D; group.engine    newGroup :&#x3D; &amp;RouterGroup &#123;        prefix: group.prefix + prefix,        &#x2F;&#x2F; parent: group,        engine: engine,        &#x2F;&#x2F; 查阅评论区后，作者用gruop.prefix+prefix的方式初始化已经拼接了完整的prefix，不需要parent，于是可以删除    &#125;    engine.groups &#x3D; append(engine.groups, newGroup)    return newGroup&#125;func (group *RouterGroup) addRoute(method string, comp string, handler HandlerFunc) &#123;    pattern :&#x3D; group.prefix + comp    log.Printf(&quot;Route %4s - %s&quot;, method, pattern)    group.engine.router.addRoute(method, pattern, handler)&#125;func (group *RouterGroup) GET(pattern string, handler HandlerFunc) &#123;    group.addRoute(&quot;GET&quot;, pattern, handler)&#125;func (group *RouteGroup) POST(pattern string, handler HandlerFunc) &#123;    gourp.addRoute(&quot;POST&quot;, pattern, handler)&#125;</code></pre><p>在这里可以观察到<code>addRoute</code>函数，调用了<code>group.engine.router.addRoute</code>来实现了路由的映射。由于<code>Engine</code>从某种意义上继承了<code>RouterGroup</code>的所有属性和方法，因为<code>(*Engine).engine</code>是指向自己的。这样实现，我们既可以像原来一样添加路由，也可以通过分组添加路由。</p><h4 id="使用demo-1">使用Demo</h4><blockquote><p>day4/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;    r :&#x3D; gee.New()    r.GET(&quot;&#x2F;index&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;&lt;h1&gt;Index Page&lt;&#x2F;h1&gt;&quot;)    &#125;)    v1 :&#x3D; r.Group(&quot;&#x2F;v1&quot;)    &#123;        v1.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;            c.HTML(http.StatusOK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;&quot;)        &#125;)                v1.GET(&quot;&#x2F;hello&quot;, func(c *gee.Context) &#123;            &#x2F;&#x2F; expect &#x2F;hello?name&#x3D;abc            c.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Query(&quot;name&quot;), c.Path)        &#125;)    &#125;    v2 :&#x3D; r.Group(&quot;&#x2F;v2&quot;)    &#123;        v2.GET(&quot;&#x2F;hello&#x2F;:name&quot;, func(c *gee.Context) &#123;            &#x2F;&#x2F; expect &#x2F;hello&#x2F;abc            c.String(http.StatusOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Param(&quot;name&quot;), c.Path)        &#125;)        v2.POST(&quot;&#x2F;login&quot;, func(c *gee.Context) &#123;            c.JSON(http.StatusOK, gee.H&#123;                &quot;username&quot;: c.PostForm(&quot;username&quot;),                &quot;password&quot;: c.PostForm(&quot;password&quot;),            &#125;)        &#125;)    &#125;        r.Run(&quot;:9999&quot;)&#125;</code></pre><p>通过curl的简单测试：</p><pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">$ curl &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;v1&#x2F;hello?name&#x3D;abc&quot;hello abc, you&#39;re at &#x2F;v1&#x2F;abc$ curl &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;v2&#x2F;hello&#x2F;abc&quot;hello abc, you&#39;re at &#x2F;hello&#x2F;abc</code></pre><h3 id="day5.-中间件-middleware">day5. 中间件 Middleware</h3><ul><li>设计并实现Web 框架的中间件 (Middlewares)机制</li><li>实现通用的 Logger 中间件，能够记录请求到响应所花费的时间，代码约50行</li></ul><h4 id="中间件是什么">中间件是什么</h4><p>中间件(middlewares)，简单说，就是非业务的技术类组件。Web框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此，框架需要有一个插口，允许用户自定义功能，嵌入到框架中，仿佛这个功能是框架原生支持的一样。因此，对中间件而言，需要考虑2个比较关键的点：</p><ul><li>插入点在哪？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件逻辑就会非常复杂</li><li>中间件的输入是什么？中间件的输入，决定了扩展能力。暴露的参数太少，用户发挥空间有限。</li></ul><p>那对于一个Web框架而言，中间件应该设计成什么样呢？接下来的实现，基本参考了Gin框架。</p><h4 id="中间件设计">中间件设计</h4><p>Gee的中间件的定义与路由映射的Handler一致，处理的是输入的<code>Context</code>对象。插入点是框架接收到请求初始化<code>Context</code>对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对<code>Context</code>进行二次加工。另外通过调用<code>(*Context).Next()</code>函数，中间件可等待用户自己定义的<code>Handler</code>处理结束后，做一些额外的操作，例如计算本次处理所用时间等。即Gee的中间件支持用户在请求被处理的前后，做一些额外的操作。举个例子，我们希望最终能够支持如下定义的中间件，<code>c.Next()</code>表示等待执行其他的中间件或用户的<code>Handler</code>：</p><blockquote><p>day4/gee/logger.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Logger() HandlerFunc &#123;    return func(c *Context) &#123;        &#x2F;&#x2F; start timer        t :&#x3D; time.Now()        &#x2F;&#x2F; process request        c.Next()        &#x2F;&#x2F; calculate resolution time        log.Printf(&quot;[%d] %s in %v&quot;, c.StatusCode, c.Req.RequestURI, time.Since(t))    &#125;&#125;</code></pre><p>另外，支持设置多个中间件，依次进行调用。</p><p>在第四天的 "分组控制 Group Control"讲到，中间件是应用在<code>RouterGroup</code>上的，应用在最顶层的Group，相当于作用域全局，所有的请求都会被中间件处理。那为什么不作用在每一条路由规则上呢？作用在某条路由规则，那还不如用户直接在Handler中调用。只作用在某条路由规则的功能通透性太差，不适合定义为中间件。</p><p>我们之前的框架设计是这样的，当接收到请求后，匹配路由，该请求的所有信息都保存在<code>Context</code>中。中间件也不例外，接收到请求后，应查找所有应作用于该路由的中间件，保存在<code>Context</code>中，依次进行调用。为什么依次调用后，还需要在<code>Context</code>中保存呢？因为在设计中，中间件不仅作用在处理流程前，也可以作用在处理流程后，即在用户定义的Handler处理完毕后，还可以执行剩下的操作。</p><blockquote><p>day4/gee/context.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Context struct &#123;    &#x2F;&#x2F; origin objects    Writer http.ResponseWriter    Req *http.Request    &#x2F;&#x2F; request info    Path string    Method string    Params map[string]string    &#x2F;&#x2F; response info    StatusCode int    &#x2F;&#x2F; middleware    handlers []HandlerFunc    index int&#125;func newContext(w http.RequestWriter, req *http.Request) *Context &#123;    return &amp;Context &#123;        Path: req.URL.Path,        Method: req.Method,        Req: req,        Writer: w,        index: -1,    &#125;&#125;func (c *Context) Next() &#123;    c.index++    s :&#x3D; len(c.handlers)    for ; c.index &lt; s; c.index++ &#123;        c.handlers[c.index](c)    &#125;&#125;</code></pre><p><code>index</code>是记录当前执行到第几个中间件，当在中间件调用<code>Next</code>方法时，控制权交给了下一个中间件，直到调用到最后一个中间件，然后再从后往前，调用每个中间件在<code>Next</code>方法之后定义的部分。如果我们将用户在映射路由时定义的<code>Handler</code>添加到<code>c.handlers</code>列表中，结果会怎么样呢？</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func A(c *Context) &#123;    part1    c.Next()    part2&#125;func B(c *Context) &#123;    part3    c.Next()    part4&#125;</code></pre><p>假设我们应用了中间件A和B，和路由映射的Handler。<code>c.handlers</code>是这样的 <code>[A, B, Handler]</code>，<code>c.index</code>初始化为-1。调用<code>c.Next()</code>，接下来的流程是这样的：</p><ul><li>c.index++ , c.index=0</li><li>0 &lt; 3 , 调用<code>c.handlers[0]</code>，即A</li><li>执行part1，调用<code>c.Next()</code></li><li>c.index++，c.index=1</li><li>1 &lt; 3 , 调用<code>c.handlers[1]</code>，即B</li><li>执行part3，调用<code>c.Next()</code></li><li>c.index++ , c.index=2</li><li>2 &lt; 3 , 调用<code>c.handlers[2]</code>，即Handler</li><li>Handler调用完毕，返回到B中的part4，执行part4</li><li>part4执行完毕，返回到A中的part2，执行part2</li><li>part2执行完毕，结束</li></ul><p>说重点，执行顺序是<code>part1 -&gt; part3 -&gt; Handler -&gt; part4 -&gt;part2</code>。恰恰满足了我们对中间件的要求，接下来看调用部分的代码，就能全部串起来了。</p><h4 id="代码实现">代码实现</h4><p>定义<code>Use</code>函数，将中间件应用到某个Group</p><blockquote><p>day4/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Use is defined to add middlewares to the groupfunc (group *RouterGroup) Use(middlewares ...HandlerFunc) &#123;    group.middlewares &#x3D; append(group.middlewares, middlewares...)&#125;func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;    var middlewares []HandlerFunc    for _, group :&#x3D; range engine.groups &#123;        if strings.HasPrefix(req.URL.Path, group.prefix) &#123;            middlewares &#x3D; append(middlewares, group.middlewares...)        &#125;    &#125;    c :&#x3D; newContext(w, req)    c.handlers &#x3D; middlewares    engine.router.handle(c)&#125;</code></pre><p>ServeHTTP函数也有变化，当我们接收到一个具体请求时，要判断该请求适用于哪些中间件，在这里我们简单通过URL的前缀来判断。得到中间件列表，赋值给<code>c.handlers</code>。</p><p>handle函数中，将从路由匹配得到的Handler添加到<code>c.handlers</code>列表中，执行<code>c.Next()</code>。</p><blockquote><p>day4/gee/router.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (r *router) handle(c *Context) &#123;    n, params :&#x3D; r.getRoute(c.Method, c.Path)        if n !&#x3D; nil &#123;        key :&#x3D; c.Method + &quot;-&quot; +n.pattern        c.Params &#x3D; params        c.handlers &#x3D; append(c.handlers, r.handlers[key])    &#125; else &#123;        c.handlers &#x3D; append(c.handlers, func(c *Context) &#123;            c.String(http.StatusNotFound, &quot;404 NOT FOUND: %s\n&quot;, c.Path)        &#125;)    &#125;    c.Next()&#125;</code></pre><h4 id="使用demo-2">使用demo</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">func onlyForV2() gee.HandlerFunc &#123;    return func(c *gee.Context) &#123;        &#x2F;&#x2F; start timer        t :&#x3D; time.Now()        &#x2F;&#x2F; if a server error occurred        c.Fail(500, &quot;Internal Server Error&quot;)        &#x2F;&#x2F; Calculate resolution time        log.Printf(&quot;[%d] %s in %v for group v2&quot;, c.StatusCode, c.Req.RequestURI, time.Since(t))    &#125;&#125;func main() &#123;    r :&#x3D; gee.New()    r.Use(gee.Logger()) &#x2F;&#x2F; global middleware    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;&lt;h1&gt;hello gee&lt;&#x2F;h1&gt;&quot;)    &#125;)        v2 :&#x3D; r.Group(&quot;&#x2F;v2&quot;)    v2.Use(onlyForV2())    &#123;        v2.GET(&quot;&#x2F;hello&#x2F;:name&quot;, func(c *gee.Context) &#123;            &#x2F;&#x2F; expect &#x2F;hello&#x2F;gee            c.String(http.StatisOK, &quot;hello %s, you&#39;re at %s\n&quot;, c.Param(&quot;name&quot;), c.Path)        &#125;)    &#125;        c.Run(&quot;:9999&quot;)&#125;</code></pre><p><code>gee.Logger()</code>即我们一开始就介绍的中间件，我们将这个中间件和框架代码放在了一起，作为框架默认提供的中间件。在这个例子中，我们将<code>gee.Logger()</code>应用在了全局，所有的路由都会应用该中间件。<code>onlyForV2()</code>是用来测试功能的，尽在<code>v2</code>对应的Group中应用了。</p><p>接下来使用curl测试，可以看到，v2 Group 2个中间件都生效了。</p><pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;&lt;h1&gt;Hello Gee&lt;&#x2F;h1&gt;$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;v2&#x2F;hello&#x2F;abc&#123;&quot;message&quot;:&quot;Internal Server Error&quot;&#125;</code></pre><p>服务器端</p><pre class="line-numbers language-none"><code class="language-none">2022&#x2F;07&#x2F;27 16:00:01 [200] &#x2F; in 300ns2022&#x2F;07&#x2F;27 16:00:28 [500] &#x2F;v2&#x2F;hello&#x2F;abc in 0s for group v22022&#x2F;07&#x2F;27 16:00:28 [500] &#x2F;v2&#x2F;hello&#x2F;abc in 1.6176ms</code></pre><p>这里的测试v2中间件，一开始，测试了很多次，返回的都是500错误码，比对了源码很久，没发现问题，再次运行curl测试，还是返回500错误码。后面查阅了第五天的评论区，发现，day5的中间件仅仅用来演示，发送500错误码表示中间件起作用了。</p><h3 id="day6.-模板-html-template">day6. 模板 (HTML Template)</h3><ul><li>实现静态资源服务 (Static Resource)</li><li>支持HTML模板渲染</li></ul><h4 id="服务器渲染">服务器渲染</h4><p>现在越来越流行前后端分离的开发模式，即 Web 后端提供RESTful接口，返回结构化的数据 (通常为JSON或XML)。前端使用AJAX 技术请求到所需的数据，利用 JavaScript 进行渲染。Vue/React 等前端框架持续火热，这种开发模式前后端解耦，优势很突出。后端打工人专心解决资源利用，并发，数据库等问题，只需要考虑数据如何生成；前端打工人专注于界面设计实现，只需要考虑拿到数据后如何渲染即可。后端只关注于数据，接口返回值是结构化的，于前端解耦。同一套后端服务能够同时支撑小程序，移动app，pc端 Web界面，以及对外提供的接口。随着前端工程化的不断发展，Webpack，gulp等工具层出不穷，前端技术越来越自成体系了。</p><p>但是前后端分离的一大问题在于，页面是在客户端渲染的，比如浏览器，这对爬虫并不友好。</p><p>今天的内容便是介绍 Web框架如何支持服务端渲染的场景。</p><h4 id="静态文件-serve-static-files">静态文件 (Serve Static Files)</h4><p>网页三剑客，js，css，html。要做到服务端渲染，第一步便是要支持js，css等静态文件。之前设计动态路由的时候，支持通配符<code>*</code>匹配多级子路径。比如路由规则<code>/assets/*filepath</code>，可以匹配<code>/assets/</code>开头的所有地址。例如<code>/assets/js/geek.js</code>，匹配后，参数<code>filepath</code>旧赋值为<code>js/geek.js</code>。</p><p>那么如果我们将所有静态文件放在<code>/usr/web</code>目录下，那么<code>filepath</code>的值既是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。</p><p>找到文件后，如何返回这一文件，<code>net/http</code>库已经实现了。因此，gee框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给<code>http.FileServer</code>处理就好了。</p><blockquote><p>day6/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; create static handlerfunc (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc &#123;    absolutePath :&#x3D; path.Join(group.prefix, relativePath)    fileServer :&#x3D; http.StripPrefix(absolutePath, http.FileServer(fs))    return func(c *Context) &#123;        file :&#x3D; c.Param(&quot;filepath&quot;)        &#x2F;&#x2F; check if file exists and&#x2F;or if we have permission to access it        if _, err :&#x3D; fs.Open(file); err !&#x3D; nil &#123;            c.Status(http.StatusNotFound)            return        &#125;                fileServer.ServeHTTP(c.Writer, c.Req)    &#125;&#125;&#x2F;&#x2F; serve static filesfunc (group *RouterGroup) Static(relativePath string, root string) &#123;    handler :&#x3D; group.createStaticHandler(relativePath, http.Dir(root))    urlPattern :&#x3D; path.Join(relativePath, &quot;&#x2F;*filepath&quot;)    &#x2F;&#x2F; Register GET handlers    group.GET(urlPattern, handler)&#125;</code></pre><p>我们给<code>RouterGroup</code>添加了两个方法，<code>Static</code>这个方法是暴露给用户的。用户可以将磁盘上的某个文件夹<code>root</code>映射到路由<code>relativePath</code>。例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r :&#x3D; gee.New()r.Static(&quot;&#x2F;assets&quot;, &quot;&#x2F;usr&#x2F;Jayden&#x2F;blog&#x2F;static&quot;)&#x2F;&#x2F; 或者相对路径 r.Static(&quot;&#x2F;assets&quot;, &quot;.&#x2F;static&quot;)r.Run(&quot;:9999&quot;)</code></pre><p>用户访问<code>localhost:9999/assets/js/geek.js</code></p><p>最终返回<code>/usr/geek/blog/static/js/geek.js</code>。</p><h4 id="html-模板渲染">HTML 模板渲染</h4><p>golang内置了<code>text/template</code>和<code>html/template</code>2个模板标准库，其中 <a href='https://golang.org/pkg/html/template'>html/template</a> 为 HTML提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。gee框架的模板渲染直接使用了<code>html/template</code>提供的能力。</p><blockquote><p>day6/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">Engine struct &#123;    *RouterGroup    router *router    groups []*RouterGroup &#x2F;&#x2F; store all groups    htmlTemplate *template.Template &#x2F;&#x2F; for html render    funcMap template.FuncMap &#x2F;&#x2F; for html render&#125;func (engine *Engine) SetFuncMap(funcMap template.FuncMap) &#123;    engine.funcMap &#x3D; funcMap&#125;func (engine *Engine) LoadHTMLGlob(pattern string) &#123;    engine.htmlTemplates &#x3D; template.Must(template.New(&quot;&quot;).Funcs(engine.funcMap).ParseGlob(pattern))&#125;</code></pre><p>首先为 Engine 实例添加了<code>*template.Template</code>和<code>template.FuncMap</code>对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。</p><p>另外，给用户分别提供了设置自定义渲染函数<code>funcMap</code>和加载模板的方法。</p><p>接下来，对原来的<code>(*Context).HTML()</code>方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p><blockquote><p>day6/gee/context.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Context struct &#123;    &#x2F;&#x2F; ..    &#x2F;&#x2F; engine pointer    engine *Engine&#125;func (c *Context) HTML(code int, name string, data interface&#123;&#125;) &#123;    c.SetHeader(&quot;Content-Type&quot;, &quot;text&#x2F;html&quot;)    c.Status(code)    if err :&#x3D; c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err !&#x3D; nil &#123;        c.Fail(500, err.Error())    &#125;&#125;</code></pre><p>我们在<code>Context</code>中添加了成员变量<code>engine *Engine</code>，这样就能够通过Context访问 Engine 中的HTML模板。实例化Context时，还需要给<code>c.engine</code>赋值。</p><blockquote><p>day6/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;    &#x2F;&#x2F; ...    c :&#x3D; newContext(w, req)    c.handlers &#x3D; middlewares    c.engine &#x3D; engine    engine.router.handle(c)&#125;</code></pre><h4 id="使用demo-3">使用Demo</h4><p>最终目录结构</p><pre class="line-numbers language-none"><code class="language-none">---gee&#x2F;---static&#x2F;   |---css&#x2F;       |---geek.css   |---file1.txt---template   |---arr.tmpl   |---css.tmpl   |---custom_func.tmpl---main.go</code></pre><blockquote><p>day6/templates/arr.tmpl</p></blockquote><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;html&gt;    &lt;body&gt;        &lt;p&gt;hello, &#123;&#123;.title&#125;&#125;&lt;&#x2F;p&gt;        &#123;&#123;range $index, $ele :&#x3D;.stuArr&#125;&#125;        &lt;p&gt;&#123;&#123; $index&#125;&#125;: &#123;&#123;$ele.Name&#125;&#125; is &#123;&#123; $ele.Age&#125;&#125; years old&lt;&#x2F;p&gt;        &#123;&#123;end&#125;&#125;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><blockquote><p>day6/template/css.tmpl</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;html&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;assets&#x2F;css&#x2F;geek.css&quot;&gt;    &lt;p&gt;geek.css is loaded&lt;&#x2F;p&gt;&lt;&#x2F;html&gt;</code></pre><blockquote><p>day6/template/custom_func.tmpl</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;html&gt;    &lt;body&gt;        &lt;p&gt;hello, &#123;&#123;.title&#125;&#125;&lt;&#x2F;p&gt;        &lt;p&gt;Date: &#123;&#123;.now | FormatDate&#125;&#125;&lt;&#x2F;p&gt;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><blockquote><p>day6/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">type student struct &#123;    Name string    Age int8&#125;func FormatAsDate(t time.Time) string &#123;    year, month, day :&#x3D; t.Date()    return fmt.Sprintf(&quot;%d-%02d-%02d&quot;, year, month, day)&#125;func main() &#123;    r :&#x3D; gee.New()    r.Use(gee.Logger())    r.SetFuncMap(template.FuncMap&#123;        &quot;FormatAsDate&quot;: FormatAsDate,    &#125;)    r.LoadHTMLGlob(&quot;templates&#x2F;*&quot;)    r.Static(&quot;&#x2F;assets&quot;, &quot;.&#x2F;static&quot;)        stu1 :&#x3D; &amp;student&#123;Name: &quot;gee&quot;, Age: 20&#125;    stu2 :&#x3D; &amp;student&#123;Name: &quot;Jay&quot;, Age: 22&#125;    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;css.tmpl&quot;, nil)    &#125;)    r.GET(&quot;&#x2F;students&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK), &quot;arr.tmpl&quot;, gee.H&#123;            &quot;title&quot;: &quot;gee&quot;,            &quot;stuArr&quot;: [2]*student&#123;stu1, stu2&#125;,        &#125;)    &#125;)        r.GET(&quot;&#x2F;students&quot;, func(c *gee.Context) &#123;        c.HTML(http.StatusOK, &quot;custom_func.tmpl&quot;, gee.H&#123;            &quot;title&quot;: &quot;gee&quot;,            &quot;now&quot;: time.Date(2019,8,17,0,0,0,0,time.UTC)        &#125;)    &#125;)        r.Run(&quot;:9999&quot;)&#125;</code></pre><p>在浏览器访问主页，模板正常渲染，css静态文件加载成功</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002F/gee_day6.png'></p><h3 id="day7.-错误恢复-panic-recover">day7. 错误恢复 (Panic Recover)</h3><blockquote><p>实现错误处理机制</p></blockquote><h4 id="panic">panic</h4><p>golang中，比较常见的错误处理方法是返回error，由调用者决定后续如何处理。但是如果是无法恢复的错误，可以手动触发panic，当然如果在程序运行过程中出现了类似于数组越界的错误，panic也会被触发。panic会中止当前执行的程序，退出。</p><p>下面是主动触发的例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package main&#x2F;&#x2F; hello.gofunc main() &#123;    fmt.Println(&quot;before panic&quot;)    panic(&quot;crash&quot;)    fmt.Println(&quot;after panic&quot;)&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">$ go run hello.gobefore panic panic: crashgoroutine 1 [running]:main.main()        ~&#x2F;*your path*&#x2F;hello.go:5 +0x95exit status 2</code></pre><p>下面是数组越界触发的panic</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package main&#x2F;&#x2F; hello.gofunc main() &#123;    arr :&#x3D; []int&#123;1, 2, 3&#125;    fmt.Println(arr[4])&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">$ go run hello.gopanic: runtime error: index out of range [4] with legnth 3</code></pre><h4 id="defer">defer</h4><p>panic会导致程序被中止，但是在退出前，会先处理完当前携程上已经defer的任务，执行完成后再退出。效果类似于Java语言的<code>try...catch</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package main&#x2F;&#x2F; hello.gofunc main() &#123;    defer func() &#123;        fmt.Println(&quot;defer func&quot;)    &#125;()        arr :&#x3D; []int &#123;1, 2, 3&#125;    fmt.Println(arr[4])&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">$ go run hello.godefer funcpanic: runtime error: index out of range [4] with length 3</code></pre><p>可以defer多个任务，在同一个函数中defer多个任务，会逆序执行。即先执行最后的defer的任务 (类似于栈)。</p><p>在这里，defer的任务执行完成之后，panic还会继续被抛出，导致程序非正常结束。</p><h4 id="recover">recover</h4><p>golang还提供了recover函数，可以避免因为panic发生而导致整个程序终止，recover函数只在defer中生效</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; recover.gofunc test_recover() &#123;    defer func() &#123;        fmt.Println(&quot;defer func&quot;)        if err :&#x3D; recover(); err !&#x3D; nil &#123;            fmt.Println(&quot;recover success&quot;)        &#125;    &#125;()        arr :&#x3D; []int&#123;1, 2, 3&#125;    fmt.Println(arr[4])    fmt.Println(&quot;after panic&quot;)&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">$ go run recover.godefer funcrecover successafter recover</code></pre><p>我们可以看到，recover捕获了panic，程序正常结束。<code>test_recover()</code>中的after panic没有打印，这是正确的，当panic被触发时，控制权就被交给了defer。就像在Java中，<code>try</code>代码块中发生了异常，控制权交给了<code>catch</code>，接下来执行catch代码块中的代码。而在<code>main()</code>中打印了after recover，说明程序已经恢复正常，继续往下执行到结束。</p><h4 id="gee的错误处理机制">Gee的错误处理机制</h4><p>对一个Web框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。</p><p>我们在第六天实现的框架并没有加入异常处理机制，如果代码中存在会触发panic的bug，就很容易宕机。</p><p>看下面示例代码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; hello.gofunc main() &#123;    r :&#x3D; gee.New()    r.GET(&quot;&#x2F;panic&quot;, func(c *gee.Context) &#123;        names :&#x3D; []string&#123;&quot;gee&quot;&#125;        c.String(http.StatusOK, names[100])    &#125;)    r.Run(&quot;:9999&quot;)&#125;</code></pre><p>在上面的代码中，我们为gee注册了路由<code>/panic</code>，而这个路由的处理函数内部存在数组越界<code>names[100]</code>，如果访问<code>localhost:9999/panic</code>，web服务器就会宕掉。</p><p>今天，我们将在gee中添加一个添加一个非常简单的错误处理机制，即在此类错误发生时，向用户返回 Internal Server Error，并且在日志中打印必要的错误信息，方便进行错误定位。</p><p>我们之前实现了中间件机制，错误处理也可以作为一个中间件，增强gee框架的能力。</p><blockquote><p>day7/gee/recovery.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package geeimport (    &quot;fmt&quot;    &quot;log&quot;    &quot;net&#x2F;http&quot;    &quot;runtime&quot;    &quot;strings&quot;)&#x2F;&#x2F; print stack trace for debugfunc trace(message string) string &#123;    var pcs [32]uintptr    n :&#x3D; runtime.Callers(3, pcs[:]) &#x2F;&#x2F; skip first 3 caller        var str strings.Builder    str.WriteString(message + &quot;\nTraceback: &quot;)    for _, pc :&#x3D; range pcs[:n] &#123;        fn :&#x3D; runtime.FuncForPC(pc)        file, line :&#x3D; fn.FileLine(pc)        str.WriteString(fmt.Sprintf(&quot;\n\t%s:%d&quot;, file, line))    &#125;    return str.String()&#125;func Recovery() HandlerFunc &#123;    return func(c *Context) &#123;        defer func() &#123;            if err :&#x3D; recover(); err !&#x3D; nil &#123;                message :&#x3D; fmt.Sprintf(&quot;%s&quot;, err)                log.Printf(&quot;%s\n\n&quot;, trace(message))                c.Fail(http.StatusInternalServerError, &quot;Internal Server Error&quot;)            &#125;        &#125;()        c.Next()    &#125;&#125;</code></pre><p><code>Recovery()</code>的实现很简单，使用defer挂载上错误恢复的函数，在这个函数中调用<code>recover()</code>，捕获panic，并且将堆栈信息打印在日志里，向用户返回Internal Server Error。</p><p>在<code>trace()</code>中，调用了<code>runtime.Callers(3, pcs[:])</code>，Callers用来返回调用栈的程序计数器，第0个Caller是Callers本身，第一个是上一层trace，第二个是再上一层的<code>defer func</code>。因此，为了日志简洁一点，我们跳过前三个Caller。</p><p>接下来，通过<code>runtime.FuncForPC(pc)</code>获取对应的函数，再通过<code>fn.FileLine(pc)</code>获取到调用该函数的文件名和行号，打印在日志里。</p><p>至此，gee框架的错误处理机制就完成了。</p><blockquote><p>day7/gee/gee.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Default() *Engine &#123;    engine :&#x3D; New()    engine.Use(Logger(), Recovery())    return engine&#125;</code></pre><h4 id="使用demo-4">使用Demo</h4><blockquote><p>day7/main.go</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;net&#x2F;http&quot;    &quot;gee&quot;)func main() &#123;    r :&#x3D; gee.Default()    r.GET(&quot;&#x2F;&quot;, func(c *gee.Context) &#123;        c.String(http.StatusOK, &quot;hello gee\n&quot;)    &#125;)    &#x2F;&#x2F; index out of range for testing Recovery()    r.GET(&quot;&#x2F;panic&quot;, func(c *gee.Context) &#123;        names :&#x3D; []string&#123;&quot;gee&quot;&#125;\        c.String(http.StatusOK, names[100])    &#125;)    r.Run(&quot;:9999&quot;)&#125;</code></pre><p>下面来进行测试，先访问一个主页，访问一个有bug的<code>/panic</code>，服务正常返回。接下来我们再一次成功访问了主页，说明服务完全运转正常。</p><blockquote><p>Client</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$ curl http:&#x2F;&#x2F;localhost:9999hello gee$ curl http:&#x2F;&#x2F;localhost:9999&#x2F;panic&#123;&quot;message&quot;:&quot;Internal Server Error&quot;&#125;$ curl http:&#x2F;&#x2F;localhost:9999hello gee</code></pre><blockquote><p>Server</p></blockquote><p>我们可以在后台日志中看到如下内容，引发错误的原因和堆栈信息都被打印了出来，通过日志，我们可以很容易知道，在day7/main.go:47的地方出现了<code>index out of range</code>的错误。</p><pre class="line-numbers language-none"><code class="language-none">2022&#x2F;07&#x2F;29 22:15:43 Route  GET - &#x2F;2022&#x2F;07&#x2F;29 22:15:43 Route  GET - &#x2F;panic2022&#x2F;07&#x2F;29 22:15:45 runtime error: index out of range [100] with length 1Traceback:    &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;panic.go:838        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;panic.go:89        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;main.go:17        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;context.go:41        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;recovery.go:56        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;context.go:41        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;logger.go:15        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;context.go:41        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;router.go:101        &#x2F;root&#x2F;code&#x2F;go&#x2F;src&#x2F;gee_web&#x2F;dev&#x2F;gee&#x2F;gee.go:121        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;http&#x2F;server.go:2917        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;net&#x2F;http&#x2F;server.go:1967        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;asm_amd64.s:15722022&#x2F;07&#x2F;29 22:15:45 [500] &#x2F;panic in 103.5μs</code></pre><h3 id="一些想法">一些想法</h3><p>其实整篇做下来吧，其实到现在对整个框架只能够说是大概了解，自己也跟着博客敲了一遍，也大概能看懂作者的设计思路，先做一个简单的http相应，后面再添加Context、前缀树等等。</p><p>在做的过程中，也会遇到很多bug，不同于c，Java，golang这门语言，个人感觉抽象程度比Java这些高，有时候出现panic，找到了出错的行数，还得去翻阅源码，不过吧，这个也算是在锻炼自己的动手能力和解决问题的能力，也算是有些收获吧。</p><h3 id="参考链接">参考链接</h3><p><a href="https://geektutu.com/post/gee.html">7天用Go从零实现Web框架Gee教程 | 极客兔兔 (geektutu.com)</a></p><p><a href="https://blog.csdn.net/m0_52649917/article/details/121640535">(79条消息) 解决vscode和go mod 导包冲突的问题_sora!的博客-CSDN博客_gomod vscode</a></p><p><a href="https://blog.csdn.net/qiu_huouho/article/details/120733522">(80条消息) vscode使用go get 之后无法import_Restart丶的博客-CSDN博客</a></p><p><a href="https://vimsky.com/examples/usage/fmt-fprintf-function-in-golang-with-examples.html">Golang fmt.Fprintf()用法及代码示例 - 纯净天空 (vimsky.com)</a></p><p><a href="https://www.cnblogs.com/maji233/p/11178413.html">理解Golang中的interface和interface{} - maji233 - 博客园 (cnblogs.com)</a></p><p><a href="https://laravelacademy.org/post/21639">Go 语言通过 Request 对象读取 HTTP 请求报文 | 请求处理 | Go Web 编程 (laravelacademy.org)</a></p><p><a href="https://www.imooc.com/wenda/detail/664445#:~:text=http.ResponseWriter用来配置HTTP响应和发送数据给客户端的也是这样一个，io.Writer你要发送的数据（响应体）是通过调用组装的（不一定只有一次）ResponseWriter.Write,()（这是实现通用的io.Writer）.">ResponseWriter.Write 和 io.WriteString 有什么区别？_慕课猿问 (imooc.com)</a></p><p><a href="https://blog.csdn.net/qwe1765667234/article/details/124299251?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-124299251-blog-109959201.pc_relevant_multi_platform_whitelistv1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-124299251-blog-109959201.pc_relevant_multi_platform_whitelistv1&amp;utm_relevant_index=10">(79条消息) Go net.http包下的ListenAndServe函数的参数问题_qwe1765667234的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_34021712/article/details/109959201">(79条消息) Go使用net/http标准库(二)源码学习之- http.ListenAndServe()_这个名字想了很久的博客-CSDN博客</a></p><p><a href="https://cloud.tencent.com/developer/ask/sof/206511">ServeHTTP是如何工作的？ - 问答 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
    
    
    <summary type="html">用七天实现一个类Gin的Web框架</summary>
    
    
    
    <category term="BackEnd" scheme="https://jaydenchang.top/categories/BackEnd/"/>
    
    
    <category term="Golang" scheme="https://jaydenchang.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>摄影的哲与思</title>
    <link href="https://jaydenchang.top/post/0x002E.html"/>
    <id>https://jaydenchang.top/post/0x002E.html</id>
    <published>2022-07-19T16:00:00.000Z</published>
    <updated>2022-07-20T14:43:56.191Z</updated>
    
    <content type="html"><![CDATA[<p>其实这篇文章，我已经酝酿了很久了，因为各种原因，又搁置了一段时间，恰好后面受软协技术部的邀请，我去做了一次面向软协内部的分享会。当然，由于各种原因，本次分享会没什么人听 <del>(好像是撞上了香农班)</del>，不过也在我意料之中 <del>(这样就越少人能看到我口糊的一面)</del>。</p><p>关于那天，其实我并不认为是一次分享会，更多的是一种聊天吧。</p><h4 id="缘起">缘起</h4><p>其实我在大二以前，完全可以说是对摄影没有任何概念，就算拍的话，也只是一些简单的路人照，对构图、颜色搭配没有什么研究。记得当时好像是在大一暑假吧，那时和Sam外出散心，路过沙面，被眼前的欧式风格吸引，于是拿出手机咔咔几张，也没去考虑构图啥的，觉得还挺好看，就直接放到了pyq上。</p><p>到后面吧，有一次准备出宿舍时，看到了很好看的晚霞，顺手拍了下来，还特意下了"SnapSeed"去调色，虽然调的有点离谱，饱和度调太过了，不过也还是满足了我的虚荣，包括两周后的一个早晨，看到了很好看的天，马上拍下来，调出了一种 "你的名字" 的感觉。</p><p><a href="https://mp.weixin.qq.com/s/9NDb9Ez4JAwsYsPe-_Eyhg">Jayden的2021摄影集</a></p><p>再后来，到了12月，我借到了相机，这才算是我正式踏上了摄影的路，开始去考虑快门，ISO，光圈的搭配，也开始去尝试不同焦段下，拍到不同的照片，虽然还是拍的不咋地，不过审美相较于以往有了较大的进步。</p><p>寒假在家的日子，是没有相机的，但我又不能不出片吧，也罢，拿起手机去外面瞎拍，也许是整个二月都处于阴雨天吧，拍出来的照片的风格都不合我意，但还是选了一两张出来添加到摄影集里。</p><h4 id="跳出困局">跳出困局</h4><p>回到学校了，又借到相机了，拍没几天，新鲜感又过去了，校园的角角落落基本都走遍了，能拍的新事物，也所剩无几。既然一个人出不了什么好点子，那就找一群人。清明期间，我找了几个朋友外出闲逛，社牛一次去搭讪路人给她们拍照，这也算是人像摄影的启蒙吧 (虽然之后到现在也没拍过人像)。</p><p>我觉得我真正觉得自己摄影技术的提高，是在五一吧，去到了更远的地方，见到了更多的风景，去记录一些城市风光，当然，我也开始研究照片的后期技术，除了基本的曝光，对比度等，也开始去探索曲线对照片整体颜色走向，亮度的影响。</p><p>端午时期，我拿起相机，借了长焦，再次来到广州，依旧是那些熟悉的角落，不过在新的视角下，我也有了更深的体会。明明这条路，我走了很多遍，但我还依然走下去，并乐此不疲，或许是对这座城市的感情，我住在广州也有20年了，这里有我们的生活轨迹，也有属于我们这座城市的骄傲！</p><h4 id="哲与思">哲与思</h4><p>要说摄影给我带来了什么吧，其实开始我只是很沉浸在其中而已，并没有多想，真要我真的静下来想，emm……应该是一下这些吧</p><ul><li>一种记录生活的方式</li><li>对取景框里的主角的把握</li><li>对生活态度的改变</li><li>生活虽忙，但别忘了摄影</li><li>less is more</li></ul><p>在我没拿起相机的日子，我走在路上，也会用我心中的取景框去构图，像一只窥伺的猫，当我被某一瞬间的画面打动时，我会连忙倒退几步，伫立观望，然后再心满意足地继续上路。</p><p>这篇从开始构思，到下笔，再到结束，经历了好几个月。真的，摄影改变了我太多。我在街头无休止地穿梭，表面上看似在旁观生活，实则想作为一个体验者，寻求与某个事物在精神上的突然邂逅。</p><p>继续拍下去吧！</p>]]></content>
    
    
    <summary type="html">一些碎碎念, 浅聊我对摄影的看法和摄影对我的改变</summary>
    
    
    
    <category term="随笔" scheme="https://jaydenchang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://jaydenchang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>只是一期唠嗑</title>
    <link href="https://jaydenchang.top/post/0x002D.html"/>
    <id>https://jaydenchang.top/post/0x002D.html</id>
    <published>2022-03-10T16:00:00.000Z</published>
    <updated>2022-03-10T23:52:26.144Z</updated>
    
    <content type="html"><![CDATA[<p>断断续续记录一些自己的想法</p><h4 id="section">2.25</h4><p><strong>首先很感谢每位点进来并且看完的朋友，非常感谢你们抽出你们宝贵的时光听我扯皮、吹牛，在这个快节奏的时代，能静下来写一篇随笔、读一篇文章也是不容易。</strong></p><p>整个二月，几乎可以说是属于阴雨天的，从大年初一开始，到整个二月结束，阴雨不断，当然中间也出过几天晴天，而我也因为一些琐事，让我心情变得有些低落，有人说，天气会影响心情，我对此半信半疑。从大年初一开始，一连下了3天大雨，我的心情也是压抑的，终于在2月4日那天，出了太阳，我也有了外出取景的机会，拍了些照，和附近的小朋友打球，但我还是提不起精神，第二天，和Sam相约出去走走，与其说是走，其实更多时间花在了骑行上面，那天，花了俩小时骑行26km，夜间骑行，耳机里播放着R&amp;B歌曲，江岸沿途的灯柱，对岸大厦的广告牌，我放慢了步调，贪婪地享受这夜色，回到家后，整理今天所摄照片，心情好一些了。</p><p>估计是多巴胺分泌不太够吧，第二天，又回到了前几天的状态，身体的预警机制提醒我，学不进去，那总得找些事情做，那不如看书吧，于是我开始尝试每天睡醒看半小时书，睡前看半小时书。开始那几天，多少有些不习惯，心静不下来，总是想去看手机，后面索性直接把手机锁了，丢到沙发上，尝试了几天，貌似感觉还不错。</p><p>单单只是看书吧，总感觉少了点什么，我尝试开始写日记，每天写点东西，记录转瞬即逝的想法，顺便练练字。</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002D/0x002D_1.jpg' style="zoom: 30%;" ></p><p><img src='https://jaydenchang.gitee.io/images/images/0x002D/0x002D_2.jpg' style="zoom:33%;" ></p><center>字写的不太好，应该还能看得清写的啥吧 [狗头</center><h4 id="section-1">3.3</h4><p>写着发现好像跑题了，就是从过年后开始，我把我的睡前睡后的安排稍作调整，用来看书和复盘一天。这学期，从图书馆和好友那借了些书来看，首先看的是《追风筝的人》吧，在很早之前就有人推荐过我去看这本书，翻了几页，记录的是阿米尔的赎罪之旅，当阿米尔将索拉博带到美国，带着索拉博追风筝，索拉博渐渐打开心结，向着阿米尔微笑，而阿米尔此时也对着索拉博说着小时候哈桑经常对阿米尔说的话，"为你，千千万万遍"。</p><p>看完整本书吧，不由自主地想到了《肖申克的救赎》这本书(尽管我看的是电影的版本)，安迪在狱中服役了19年，也可以说是花了19年来救赎自己，在他即将越狱之时，他向瑞德提及了自己对妻子的爱与悔意。</p><p>"妻子说她很难了解我，我像一本合起来的书，她整天这样抱怨。她很漂亮，damn，我是多么爱她啊。我只是不擅表达。对，是我杀了她，枪不是我开的，但我害她离我远去，是我的脾气害死了她。"</p><p>这一段，我刷了好几遍，一直以为是安迪越狱前的某种仪式，到后面某天在外骑单车时，脑子里飘过一个想法，那一番对话，代表着安迪对自己的救赎，不是生命形式的救赎，不是生活方式上的救赎，而是灵魂层面上的救赎，在灵魂层面真正意义上的的自我重新认知。</p><p>同时也包括瑞德，前几次假释检验时，老老实实回答问题都被驳回，在第四十年，破罐子破摔，说出了自己在监狱四十年的感受，"我想对年轻的自己说……"，这一段，我同样也是看了好几遍，套路经不住灵魂的拷问，<strong>人可以通过模仿别人长大，但最终还是要用自己的语言面对这个世界</strong>。</p><p>再回到《追风筝的人》，阿米尔目睹哈桑被阿塞夫强暴而无动于衷，主要内心活动却是嫉妒父亲对哈桑的偏爱。移民美国后，阿米尔被羞愧自责的阴影所缠绕，他决定回阿富汗找哈桑。在解救索拉博时，面对阿塞夫的铁拳套，阿米尔没有退缩了，看到这里吧，阿米尔在赎罪的道路上已经跨出了一大半。</p><p>追完风筝，走进了围城，最近刚把《围城》看完，表面上吧，是写方鸿渐的早年经历，留学——求爱——婚姻，实际上，钱钟书刻画了三座围城，婚姻之城、事业之城，自我之城。这本书，看到后面，愈感觉讽刺性愈强，读完合上书那一刻，我心中在暗嘲那些像方鸿渐的人，但是反过来一想，自己身上也有方鸿渐的影子，芸芸众生，生活便是如此，围城之外又是一座围城。</p><h4 id="section-2">3.6</h4><p>最近无聊，翻了翻Instagram，原来我已经上传了这么多，因为一些特殊原因吧，我的Instagram没人关注，不过这样也好，可以在上面所心所欲发自己觉得拍的比较好看的照片，有时候甚至觉得Instagram的排版比国内的app还挺好看。</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002D/0x002D_3.jpg' style="zoom: 33%;" ></p><h4 id="section-3">3.7</h4><p>这几天晚上又因为一些琐事，晚上好久没看书了，有点懊悔自己断了这个习惯，不过每天在自己的小本本上记录的习惯却坚持了下来。最近又重新看了<span class="math inline">\(Sean\  Tucher\)</span>的视频，在练听力的过程中，我在刷评论区，看到了一段文字，让我内心深有感触</p><p>"过去的失败，给了我们一个倾听灵魂深处声音的机会，并且它促使我们去往一个平时绝对不会接触的地方"。</p><p><a href="https://www.bilibili.com/video/BV16t411S7jr">拥抱阴影——关于光线和人生的思考【Sean Tucker中字】_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/av28378168">保护你的高光 | 合理安排相机和人生中有限的动态范围「Sean Tucker中字」_哔哩哔哩_bilibili</a></p><p>这几天，我一直在看他之前的两期视频，有时想，我每天深夜emo真的有意义吗？第二天我查看我的储存卡，已经好几天没出新片了，想着，总得在校园里闲逛会，但是愈在意，产出就愈低。</p><p>我不得不找个阴暗的地方，翻看这学期新拍的照，噢！原来当时的我是这样构图的，原来当时的我是这样调参数的。那干脆，今天不拍了，走在风中，听听歌貌似也不错。</p><p>很感谢一位朋友(<span class="math inline">\(@Lucas\)</span>)推荐了<span class="math inline">\(Sean\ Tucker\)</span>给我，这位摄影师在哲学层面教会了我许多(当然你也可以认为我在扯淡)。</p><h4 id="section-4">3.10</h4><p>这几天在看书时，脑子里蹦出一句话，"有用是毒药，无用是解药"，这当时是一篇初中语文阅读题的标题。有时候我一直在想，什么是艺术，什么是文艺青年，我以前一直在想，我拿着相机到处走走拍拍，抱着本书读，这样就是文艺，这样就是文艺青年，显然，我只是青年，是伪文艺青年，自己还不配谈"文艺"。</p><p>文艺不应该是噱头，如果我能享受其中，那我就搞文艺这一套，读书摄影看电影，思考散步谈人生，做一些在别人眼里的为"无用"的事。别人再怎么嘲讽都没用，因为，这是我的生活方式。</p><p>或许吧，也不应该有"文艺青年"这个标签，<strong>安安静静做点自己想做的事，过点自己想过的生活</strong>，这也许是"文艺青年"最初的定义吧。</p>]]></content>
    
    
    <summary type="html">一些想法，当然你也可以认为我在扯淡</summary>
    
    
    
    <category term="随笔" scheme="https://jaydenchang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://jaydenchang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>cocos2d拖动组件吸附效果</title>
    <link href="https://jaydenchang.top/post/0x002C.html"/>
    <id>https://jaydenchang.top/post/0x002C.html</id>
    <published>2022-02-17T16:00:00.000Z</published>
    <updated>2022-03-02T10:51:46.841Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习制作小游戏，要实现一个拖动吸附效果，这里简单实现一下</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C-1.png' style="zoom:67%;" ></p><h4 id="代码实现">代码实现</h4><h5 id="定义节点和函数功能">定义节点和函数功能</h5><p>在<code>properties</code>里新建一个对象，用来接收目标区域的节点</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">properties:&#123;    sense: &#123;        defaule: null,        type: cc.Node,    &#125;&#125;</code></pre><p>然后在小车节点里绑定这个脚本，将要测试的目标节点拖动到属性检查器的<code>sense</code></p><p>这里用小车来表示要移动的组件，先在<code>onload()</code>内定义小车组件，设置位置，以及定义三个触摸事件函数</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">onload() &#123;    this.carPos &#x3D; cc.v2(0, 0);    &#x2F;&#x2F; 定义一个触摸移动控件    this.node.setPosition(this.carPos.x, this.carPos.y);    this.origin &#x3D; this.node.convertToWorldSpace(cc.v2(0, 0));    &#x2F;&#x2F; 获取小车移动前的坐标        &#x2F;&#x2F; 对当前节点设置位置    this.node.on(&quot;touchstart&quot;, this.touchStart, this);    this.node.on(&quot;touchmove&quot;, this.touchMove, this);    this.node.on(&quot;touchend&quot;, this.touchEnd, this);    &#x2F;&#x2F; 定义三个触摸事件函数&#125;</code></pre><p>然后就是对三个触摸事件定义</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">touchStart(event) &#123;    let touchPos &#x3D; event.getLocation();    &#x2F;&#x2F; 获取当前触摸位置    let posInNode &#x3D; this.worldConvertLocalPoint(this.node, touchPos);    &#x2F;&#x2F; 将当前触摸位置坐标转换为世界坐标    let target &#x3D; this.node.getContentSize();    &#x2F;&#x2F; 获得当前触摸组件的大小    let rect &#x3D; cc.rect(0, 0, target.width, target.height);    &#x2F;&#x2F; 对触摸对象组件创建一个矩形对象    if (rect.contains(posInNode)) &#123;        &#x2F;&#x2F; 判断触摸的位置是否在矩形内        this.touchTile &#x3D; this.node;        &#x2F;&#x2F; 获取被触摸的对象    &#125;    console.log(posInNode.x + &quot; &quot; + posInNode.y);    &#x2F;&#x2F; 测试，打印当前触摸位置&#125;,    touchMove(event) &#123;    if (this.touchTile) &#123;        this.touchTile.setPosition(this.touchTile.x + event.getDelta().x ,            this.touchTile.y + event.getDelta().y);        &#x2F;&#x2F; 根据小车组件移动距离重新给小车定位    &#125;&#125;,touchEnd(event) &#123;    let touchPos &#x3D; this.touchTile.convertToWorldSpaceAR(cc.v2(0, 0));    let posInNode &#x3D; this.worldConvertLocalPoint(this.sense1, touchPos);    let target &#x3D; this.sense1.getContentSize();    &#x2F;&#x2F; 定义坐标修正值    let correctValue &#x3D; cc.v2(this.sense.width &#x2F; 2  - this.origin.x - this.node.width &#x2F; 2, this.sense.height &#x2F; 2 - this.origin.y - this.node.height &#x2F; 2);    &#x2F;&#x2F; 获取要置放的区域的大小    let rect &#x3D; cc.rect(0, 0, target.width, target.height);    if (rect.contains(posInNode)) &#123;        &#x2F;&#x2F; 判断小车是否落在目标区域的矩形内        console.log(&quot;---endPos&quot;);        &#x2F;&#x2F; 设置触摸结束后小车的落位坐标        let targetPos &#x3D; this.sense1.convertToWorldSpace(cc.v2(correctValue));        &#x2F;&#x2F; 获取目标区域的中心坐标        let action &#x3D; cc.moveTo(0.3, targetPos);        &#x2F;&#x2F; 新建一个位移动作，动画持续时间为0.3s        this.touchTile.runAction(action);        &#x2F;&#x2F; 小车组件执行动作    &#125; else &#123;        console.log(&quot;----go back&quot;);        let action &#x3D; cc.moveTo(0.3, this.carPos);        &#x2F;&#x2F; 组件回到小车初始位置        this.touchTile.runAction(action);    &#125;    this.touchTile &#x3D; null;    &#x2F;&#x2F; 重置触摸组件为空&#125;,    worldConvertLocalPoint(node, worldPoint) &#123;    if (node) &#123;        return node.convertToNodeSpace(worldPoint);    &#125;    return null;&#125;</code></pre><h5 id="最终效果">最终效果</h5><p>拖入目标区域</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_drag_accept.gif' style="zoom:67%;" ></p><p>没拖到指定区域</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_drag_refuse.gif' style="zoom:67%;" ></p><h5 id="修正">修正</h5><p>这里要把小车放到目标区域的正中心，需要对坐标进行修正。在cocos creator里，有节点坐标和世界坐标这两个概念</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_xOy.png' style="zoom:67%;" ></p><p>而在属性检查器里，我们所设置的<code>position</code>，也就是锚点的位置，是相对于父节点的，例如图中我把<code>position</code>设为0和0，就是相对于父节点，该组件定位在父节点的几何中心。</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_xOy_detail.png' style="zoom:67%;" ></p><p>那么，哪些坐标值和最终放置的位置坐标有关联呢？</p><ul><li>小车初始坐标值</li><li>小车组件的长宽</li><li>目标区域的长宽</li></ul><p>在没有修正之前，把<code>targetPos</code>的值设为<code>this.sense.convertToWorldSpace(cc.v2(0, 0))</code>，拖动后的效果如下图</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_without_correct.gif' style="zoom:67%;" ></p><p>并且log打印目标位置的坐标，水平值离屏幕宽度一半还有一定的差距，这时我又打印了拖动结束后小车的坐标值，好家伙，我轻点小车没有拖动，控制台输出的坐标值为<code>(0,0)</code>，而图中很明显，小车的位置不在世界坐标的原点上，即此时小车的坐标参照点为小车的初始位置</p><p>那问题来了，怎么修正？</p><p>只需在<code>onload()</code>中定义一个变量储存小车的世界坐标值 <code>this.origin = this.node.convertToWorldSpace(cc.v2(0, 0))</code>，然后在<code>touchEnd()</code>中新定义一个向量值<code>correctValue</code>，新建一个向量<code>cc.v2(-this.origin.x, -this.origin.y)</code>，并返回给<code>correctValue</code>，再将<code>correctValue</code>转化为世界坐标赋给<code>targetPos</code>，此时小车会自动吸附到目标区域左下角，展现的效果如下</p><p><img src='https://jaydenchang.gitee.io/images/images/0x002C_correct.gif' style="zoom:67%;" ></p><p>如果要把小车定位到目标区域的正中央，还需要考虑小车组件和目标区域的长宽，相应地，<code>correctValue</code>应该设为<code>cc.v2(this.sense.width / 2 - this.node.width / 2 - this.origin.x, this.sense.height / 2 - this.node.height / 2 - this.origin.y)</code></p><h4 id="参考链接">参考链接</h4><p><a href="https://blog.csdn.net/qq_45310244/article/details/113854722">(61条消息) CocosCreator的拖动小游戏主要逻辑_天才派大星 !的博客-CSDN博客_cocos creator 拖动</a></p>]]></content>
    
    
    <summary type="html">在Cocos2d中拖动组件并吸附到节点中央</summary>
    
    
    
    <category term="Cocos" scheme="https://jaydenchang.top/categories/Cocos/"/>
    
    
    <category term="JavaScript" scheme="https://jaydenchang.top/tags/JavaScript/"/>
    
    <category term="Cocos" scheme="https://jaydenchang.top/tags/Cocos/"/>
    
  </entry>
  
  <entry>
    <title>win10找回Ubuntu启动项(非EasyBCD)</title>
    <link href="https://jaydenchang.top/post/0x002B.html"/>
    <id>https://jaydenchang.top/post/0x002B.html</id>
    <published>2022-01-12T16:00:00.000Z</published>
    <updated>2022-01-13T04:04:41.513Z</updated>
    
    <content type="html"><![CDATA[<p>最近想对装在电脑上的Ubuntu进行更新，但是之前在BIOS里改了引导系统的文件，导致找不到Ubuntu启动项，EasyBCD程序也不起作用(整块硬盘Windows分区都是GPT，改BIOS也没什么用)，在必应上逛了两天找到了一个解决方法，在Windows下用命令行修改引导文件</p><p>打开管理员命令行(不是<u><strong>powershell</strong></u>)，输入以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mountvol g: &#x2F;sg:cd EFIbcdedit &#x2F;set &#123;bootmgr&#125; path \EFI\ubuntu\grubx64.efi</code></pre><p>这时候重启，开机就会进入grub菜单</p><p>如果想改回Windows引导，则最后一行命令改为</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bcdedit &#x2F;set &#123;bootmgr&#125; path \EFI\Microsoft\Boot\bootmgfw.efi</code></pre><h4 id="参考链接">参考链接</h4><p><a href="https://linux.cn/article-4667-1.html">桌面应用|Windows和Ubuntu双系统，修复UEFI引导的两种办法 (linux.cn)</a></p>]]></content>
    
    
    <summary type="html">不进入BIOS的情况下找回Ubuntu启动项</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="Linux" scheme="https://jaydenchang.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>不关闭SELinux情况下使用ftp传输</title>
    <link href="https://jaydenchang.top/post/0x002A.html"/>
    <id>https://jaydenchang.top/post/0x002A.html</id>
    <published>2022-01-03T16:00:00.000Z</published>
    <updated>2022-01-03T08:43:52.196Z</updated>
    
    <content type="html"><![CDATA[<p>在做搭建ftp服务器的作业时，整了一个活，在不关闭SELinux的情况下测试ftp服务器</p><p>使用的环境，虚拟机*2 (CentOS 7)，Hyper-v，网卡已设为静态</p><p>需要安装的软件包：</p><ul><li><p>服务器(下称server)：</p><ul><li><p>vsftpd</p></li><li><p>ftp</p></li><li><p>ip可自定义，此处设为192.168.4.5</p></li></ul></li><li><p>客户机(下称client)：</p><ul><li><p>ftp</p></li><li><p>ip这里设为192.168.4.205</p></li></ul></li></ul><h4 id="修改vsftpd配置">修改vsftpd配置</h4><p>进入目录<code>/etc/vsftpd</code>，编辑<code>vsftpd.conf</code>，在最后一行添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">listen_port&#x3D;21</code></pre><h4 id="防火墙添加信任">防火墙添加信任</h4><p>然后在防火墙里允许特定ip访问特定端口(作业里要访问的ip是<code>192.168.4.205</code>)</p><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --permanent --add-rich-rule&#x3D;&quot;rule family&#x3D;&quot;ipv4&quot; source address&#x3D;&quot;192.168.4.205&quot; port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;21&quot; accept&quot;</code></pre><p>向客户机开放21端口</p><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --reload</code></pre><p>重新载入防火墙</p><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --zone&#x3D;public --list-rich-rules</code></pre><p>查看开放的端口</p><p>如果显示防火墙未启动，可以运行命令启动防火墙</p><pre class="line-numbers language-none"><code class="language-none">systemctl start firewalld</code></pre><h4 id="客户机测试">客户机测试</h4><p>连接服务器</p><pre class="line-numbers language-none"><code class="language-none">ftp 192.168.4.5</code></pre><p>当显示<code>ftp&gt;</code>时，输入<code>ls</code>或者<code>pwd</code>查看当前位置时，又出现了一个bug，显示<code>no route to host</code>，</p><p>这时候再回到服务器，修改<code>/etc/sysconfig/</code>下的<code>iptables-config</code>，更改其中<code>IPTABLES_MODULES=""</code>项为</p><pre class="line-numbers language-none"><code class="language-none">IPTABLES_MODULES&#x3D;&quot;ip_nat_ftp ip_conntrack_ftp&quot;</code></pre><p>然后重启防火墙相关服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart iptables.service</code></pre><p>如果服务器重启后，客户机ftp连接服务器还出现<code>no route to host</code>的情况，以此输入以下命令开启相关防火墙服务</p><pre class="line-numbers language-none"><code class="language-none">systemctl start firewalldsystemctl start iptables.service</code></pre><p>如果仅是临时使用，可以运行以下两条命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">modprobe ip_nat_ftpmodprobe ip_conntrack_ftp</code></pre><h4 id="参考链接">参考链接</h4><p><a href="https://blog.csdn.net/u012906135/article/details/69944485">ftp connect: No route to host 解决方案_hello world!-CSDN博客</a></p><p><a href="https://www.jianshu.com/p/4801d9dbaa84">Linux防火墙firewall只允许特定ip访问 - 简书 (jianshu.com)</a></p>]]></content>
    
    
    <summary type="html">两台Linux服务器不关闭SELinux进行ftp传输</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="Linux" scheme="https://jaydenchang.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jaydenchang.top/post/0x0000.html"/>
    <id>https://jaydenchang.top/post/0x0000.html</id>
    <published>2021-12-10T23:52:02.544Z</published>
    <updated>2022-10-17T02:37:49.471Z</updated>
    
    <content type="html"><![CDATA[<ul><li>0x0001随笔</li><li>0x0002随笔-年报</li><li>0x0003技术-链表</li><li>0x0004技术-二分法</li><li>0x0005 1月的胡思乱想</li><li>0x0006 基于单链表的图书管理系统</li><li>0x0007 最近沉沦、颓废的一些感受</li><li>0x0008 第一次前端作业</li><li>0x0009 第二次前端作业</li><li>0x000A c++类的简短总结 -- 10</li><li>0x000B c++类的链表实例</li><li>0x000C 第六次前端作业</li><li>0x000D 二级下拉菜单</li><li>0x000E 第八次前端作业</li><li>0x000F 第十次前端作业 -- 15</li><li>0x0010 第十一次前端作业</li><li>0x0011 最小生成树之prim</li><li>0x0012 重构运算符</li><li>0x0013 简单实现页面提交数据</li><li>0x0014 模板类链表 -- 20</li><li>0x0015 拖拽式页面</li><li>0x0016 网页注册，登录，拦截</li><li>0x0017 js轮播图升级版</li><li>0x0018 基于css的动画</li><li>0x0019 摸鱼的大一 -- 25</li><li>0x001A 关于面向对象编程</li><li>0x001B 接口和包</li><li>0x001C 练字时我在想什么</li><li>0x001D 关于大众对杨倩和王璐瑶的评价的一些想法</li><li>0x001E js简单实现拦截访问指定网页 -- 30</li><li>0x001F 稀疏数组和队列(数组)</li><li>0x0020 单链表(Java)</li><li>0x0021 为博客添加评论提醒功能(踩坑全过程)</li><li>0x0022 博客迁移</li><li>0x0023 旧手机改造成web服务器并实现内网穿透 -- 35</li><li>0x0024 数据结构--关于单链表小细节的一些补充</li><li>0x0025 数据结构--不设头指针的循环链队列</li><li>0x0026 kmp</li><li>0x0027 简单二叉树</li><li>0x0028 Huffman Tree -- 40</li><li>0x0029 图及最小生成树</li><li>0x002A 不关闭SELinux情况下使用ftp传输</li><li>0x002B win10找回Ubuntu启动项(非EasyBCD)</li><li>0x002C cocos2d拖动组件吸附效果</li><li>0x002D 只是一期唠嗑 -- 45</li><li>0x002E 摄影的哲与思</li><li>0x002F gee-web</li><li>0x0030 Java swing实现应用程序对数据库的访问</li><li>0x0031 gee-rpc</li><li>0x0032</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;0x0001随笔&lt;/li&gt;
&lt;li&gt;0x0002随笔-年报&lt;/li&gt;
&lt;li&gt;0x0003技术-链表&lt;/li&gt;
&lt;li&gt;0x0004技术-二分法&lt;/li&gt;
&lt;li&gt;0x0005 1月的胡思乱想&lt;/li&gt;
&lt;li&gt;0x0006 基于单链表的图书管理系统&lt;/li&gt;
&lt;li&gt;0x0007 最近沉沦、颓废的一些感受&lt;/li&gt;
&lt;li&gt;0x0008 第一次前端作业&lt;/li&gt;
&lt;li&gt;0x0009 第二次前端作业&lt;/li&gt;
&lt;li&gt;0x000A c++类的简短总结 -- 10&lt;/li&gt;
&lt;li&gt;0x000B c++类的链表实例&lt;/li&gt;
&lt;li&gt;0x000C 第六次前端作业&lt;/li&gt;
&lt;li&gt;0x000D 二级下拉菜单&lt;/li&gt;
&lt;li&gt;0x000E 第八次前端作业&lt;/li&gt;
&lt;li&gt;0x000F 第十次前端作业 -- 15&lt;/li&gt;
&lt;li&gt;0x0010 第十一次前端作业&lt;/li&gt;
&lt;li&gt;0x0011 最小生成树之prim&lt;/li&gt;
&lt;li&gt;0x0012 重构运算符&lt;/li&gt;
&lt;li&gt;0x0013 简单实现页面提交数据&lt;/li&gt;
&lt;li&gt;0x0014 模板类链表 -- 20&lt;/li&gt;
&lt;li&gt;0x0015 拖拽式页面&lt;/li&gt;
&lt;li&gt;0x0016 网页注册，登录，拦截&lt;/li&gt;
&lt;li&gt;0x0017 js轮播图升级版&lt;/li&gt;
&lt;li&gt;0x0018 基于css的动画&lt;/li&gt;
&lt;li&gt;0x0019 摸鱼的大一 -- 25&lt;/li&gt;
&lt;li&gt;0x001A 关于面向对象编程&lt;/li&gt;
&lt;li&gt;0x001B 接口和包&lt;/li&gt;
&lt;li&gt;0x001C 练字时我在想什么&lt;/li&gt;
&lt;li&gt;0x001D 关于大众对杨倩和王璐瑶的评价的一些想法&lt;/li&gt;
&lt;li&gt;0x001E js简单实现拦截访问指定网页 -- 30&lt;/li&gt;
&lt;li&gt;0x001F 稀疏数组和队列(数组)&lt;/li&gt;
&lt;li&gt;0x0020 单链表(Java)&lt;/li&gt;
&lt;li&gt;0x0021 为博客添加评论提醒功能(踩坑全过程)&lt;/li&gt;
&lt;li&gt;0x0022 博客迁移&lt;/li&gt;
&lt;li&gt;0x0023 旧手机改造成web服务器并实现内网穿透 -- 35&lt;/li&gt;
&lt;li&gt;0x0024 数据结构--关于单链表小细节的一些补充&lt;/li&gt;
&lt;li&gt;0x0025 数据结构--不设头指针的循环链队列&lt;/li&gt;
&lt;li&gt;0x0026 kmp&lt;/li&gt;
&lt;li&gt;0x0027 简单二叉树&lt;/li&gt;
&lt;li&gt;0x0028 Huffman Tree -- 40&lt;/li&gt;
&lt;li&gt;0x0029 图及最小生成树&lt;/li&gt;
&lt;li&gt;0x002A 不关闭SELinux情况下使用ftp传输&lt;/li&gt;
&lt;li&gt;0x002B win10找回Ubuntu启动项(非EasyBCD)&lt;/li&gt;
&lt;li&gt;0x002C cocos2d拖动组件吸附效果&lt;/li&gt;
&lt;li&gt;0x002D 只是一期唠嗑 -- 45&lt;/li&gt;
&lt;li&gt;0x002E 摄影的哲与思&lt;/li&gt;
&lt;li&gt;0x002F gee-web&lt;/li&gt;
&lt;li&gt;0x0030 Java swing实现应用程序对数据库的访问&lt;/li&gt;
&lt;li&gt;0x0031 gee-rpc&lt;/li&gt;
&lt;li&gt;0x0032&lt;/li&gt;
&lt;/ul&gt;
</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构-图及最小生成树</title>
    <link href="https://jaydenchang.top/post/0x0029.html"/>
    <id>https://jaydenchang.top/post/0x0029.html</id>
    <published>2021-12-08T16:00:00.000Z</published>
    <updated>2021-12-11T06:08:25.654Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更了 <del>其实摸鱼摸太久了</del>，当然也是最近太多事，一直没有时间去打理博客，趁着周末有空，来整理下图部分的内容</p><p>这里来总结下无向图、最小生成树(prim和Dijkstra)算法</p><h4 id="无向图">无向图</h4><h5 id="结构">结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 到后面发现，visited在无向图中设计的是真的巧妙template &lt;class DataType&gt;class MGraph &#123;    public:      MGraph(DataType a[], int n, int e); &#x2F;&#x2F; 构造函数，构造有n个顶点e条边的图     ~MGraph() &#123;&#125;     void DFS(int); &#x2F;&#x2F; 深搜     void BFS(int); &#x2F;&#x2F; 广搜        private:     DataType vertex[maxSize]; &#x2F;&#x2F; 存放图中顶点的数组     int edge[maxSize][maxSize]; &#x2F;&#x2F; 存放图中边的数组     int vertexNum, edgeNum; &#x2F;&#x2F; 图中的顶点数和变数&#125;;</code></pre><h5 id="构造函数">构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, k;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i]; &#x2F;&#x2F; 储存顶点    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            edge[i][j] &#x3D; 0; &#x2F;&#x2F; 初始化邻接矩阵        &#125;    &#125;    for (k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cin &gt;&gt; i &gt;&gt; j; &#x2F;&#x2F; 以此输入每条边依附的两个顶点的编号        edge[i][j] &#x3D; 1; &#x2F;&#x2F; 对输入的边做标记(无向图，双向标记)        edge[j][i] &#x3D; 1;    &#125;&#125;</code></pre><h5 id="广搜和深搜">广搜和深搜</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;        if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0)             DFS(j);        &#x2F;&#x2F; 递归的妙处会在后面讲到    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int w, j, queue[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; queue数组记录的是访问矩阵第几行的顺序    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        visited[i] &#x3D; 0;    &#125;    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="主函数">主函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;;    MGraph&lt;char&gt; MG(ch, 6, 6);    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS order: \n&quot;;    MG.DFS(0);    cout &lt;&lt; &quot;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;;    cout &lt;&lt; &quot;BFS order: \n&quot;;    MG.BFS(0);&#125;</code></pre><h5 id="测试用例及其邻接矩阵">测试用例及其邻接矩阵</h5><p>测试数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0 10 20 51 21 43 4</code></pre><p>邻接矩阵</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0 1 2 3 4 5 0&#39;   1 1     1 &#39;1&#39; 1   1   1   &#39;2&#39; 1 1         &#39;3&#39;         1   &#39;4&#39;   1   1     &#39; 5&#39; 1           &#39;&#x2F;&#x2F; 以横轴为x，竖轴为y       </code></pre><p>借用这个样例来说一下深搜和广搜</p><h6 id="深搜">深搜</h6><p>已知无向图的邻接矩阵是关于对角线对称的，深搜从第一行开始搜索，搜索到<code>(1,0)</code>时进入递归，进入递归后，首先对<code>visited[v]</code>进行标记，通过观察可以知道，上一轮DFS传入的j和下一轮DFS的v在矩阵中关于对角线对称 <del>好像是个无用信息</del>，每一轮DFS的<code>visited[v]=1</code>就是为了避免重复访问<code>vertex[v]</code>，再加上那条if语句的配合，即可无重复遍历完整个图</p><h6 id="广搜">广搜</h6><p>广搜的话其实还是要自己画出一个无向图来并且在debug模式运行一遍才知道大概是怎么个流程。对上面的测试用例来说，在第一轮搜索时，访问的都是和0号这个点有通路的点，第二轮是1号，第三轮是2号，依此类推。如果把最开始输入的0号放在中间，后面输入的数据一圈圈和0号联通，产生关联，那么广搜可以理解为，从搜寻点一圈圈向外扩散找</p><h5 id="完整代码">完整代码</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;class MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);        private:     int vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, k;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            edge[i][j] &#x3D; 0;        &#125;    &#125;    for (k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cin &gt;&gt; i &gt;&gt; j;        edge[i][j] &#x3D; 1;        edge[j][i] &#x3D; 1;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;        if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0)            DFS(j);    &#125;&#125;template &lt;class DateType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int w, j, queue[maxSize] &#x3D; &#123;0&#125;;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        visited[i] &#x3D; 0;    &#125;    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;;    int i;    MGraph&lt;char&gt; MG(ch, 6, 6);    for (i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS order: \n&quot;;    MG.DFS(0);    cout &lt;&lt; &quot;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;;    cout &lt;&lt; &quot;BFS order: \n&quot;;    MG.BFS(0);&#125;</code></pre><h4 id="prim">prim</h4><h5 id="结构-1">结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;class MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);     void Prim(int);     int minEdge(int[], int);        private:     DataType vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;</code></pre><h5 id="构造函数-1">构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, w &#x3D; 0;    vertexNum &#x3D; n;    edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                 edge[i][j] &#x3D; 0; &#x2F;&#x2F; 这里忽略自环            else                edge[i][j] &#x3D; 100;            &#x2F;&#x2F; 这里初始化权值，赋比较大的数即可        &#125;    &#125;    for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cout &lt;&lt; &quot;input two points of the edge: &quot;;        cin &gt;&gt; i &gt;&gt; j;        cout &lt;&lt; &quot;input the weight of the edge: &quot; ;        cin &gt;&gt; w;        edge[i][j] &#x3D; w;        edge[j][i] &#x3D; w;    &#125;&#125;</code></pre><h5 id="prim代码实现">prim代码实现</h5><p>将图中顶点（V）分两部分，最小生成树的点集为U，其余顶点在集合（V-U）</p><ul><li><ol type="1"><li>首先任取一个点作为起点</li></ol></li><li><ol start="2" type="1"><li>在V-U中找和起点之间权值最小的边</li></ol></li><li><ol start="3" type="1"><li>adjVex记录上一轮找最小值的位置，cost记录到各顶点的距离</li></ol></li><li><ol start="4" type="1"><li>然后上一轮找到的权值最小的边的另一个点作为起点，不断重复步骤2，3</li></ol></li></ul><h6 id="找到最小值位置">找到最小值位置</h6><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;int MGraph&lt;DataType&gt;::minEdge(int r[], int n) &#123;    int index;    int min &#x3D; 100; &#x2F;&#x2F; 图中all权值最大不超过100    for (int i &#x3D; 0; i &lt; n; i++) &#123;        if (r[i] !&#x3D; 0 &amp;&amp; r[i] &lt; min) &#123;            min &#x3D; r[i];            index &#x3D; i;        &#125;    &#125;    return index; &#x2F;&#x2F; 返回最小值在数组中的位置&#125;</code></pre><h6 id="prim核心代码">prim核心代码</h6><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Prim(int v) &#123;    int adjVex[maxSize], cost[maxSize];    int i, j, k;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        &#x2F;&#x2F; 通过起点对adjVex，cost数组初始化        cost[i] &#x3D; edge[v][i];        adjVex[i] &#x3D; v;        &#x2F;&#x2F; 将起点所有有联通的点都录入cost中，找权值最小的边(类似BFS)    &#125;    cost[v] &#x3D; 0; &#x2F;&#x2F; 将顶点加入u中    for (k &#x3D; 1; k &lt; vertexNum; k++) &#123;        j &#x3D; minEdge(cost, vertexNum); &#x2F;&#x2F; 在cost数组找最小值        &#x2F;&#x2F; cout &lt;&lt; &#39;(&#39; &lt;&lt; adjVex[j] &lt;&lt; &#39;,&#39; &lt;&lt; j &lt;&lt; &#39;)&#39; &lt;&lt; cost[j] &lt;&lt; endl; &#x2F;&#x2F; 输出的是点的序号        cout &lt;&lt; &#39;(&#39; &lt;&lt; vertex[j] &lt;&lt; &#39;,&#39; &lt;&lt; vertex[adjVex[j]] &lt;&lt; &#39;)&#39; &lt;&lt; cost[j] &lt;&lt; endl;  &#x2F;&#x2F; 输出的是字符        &#x2F;&#x2F; 输出生成最小生成树的过程(都是输出上一轮查找结果)        cost[j] &#x3D; 0; &#x2F;&#x2F; 将最小值的点加入U中(清零当前最小值的权值，防止后面重复遍历)        for (int p &#x3D; 0; p &lt; vertexNum; p++) &#123;            &#x2F;&#x2F; 这一步，是以第j号为起点，不断寻找和j号联通的最小权值的路线            if (edge[p][j] &lt; cost[p]) &#123;                &#x2F;&#x2F; 从所有与当前最小值临界点出发找到最小值点权值最小的                cost[p] &#x3D; edge[p][j];                adjVex[p] &#x3D; j; &#x2F;&#x2F; 记录新加入顶点上一轮迭代的最小值的位置            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="测试用例及邻接矩阵">测试用例及邻接矩阵</h5><pre class="line-numbers language-none"><code class="language-none">0 1340 2460 5191 4122 3172 5253 4383 5254 526</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0  1  2  3  4  5 0&#39;    34 46       19 &#39;1&#39; 34          12    &#39;2&#39; 46       17    25 &#39;3&#39;       17    38    &#39;4&#39;    12    38    26 &#39; 5&#39; 19    25    26    &#39;&#x2F;&#x2F; 以横轴为x，竖轴为y       </code></pre><h4 id="dijkstra">Dijkstra</h4><h5 id="结构-2">结构</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 到后面发现，visited在无向图中设计的是真的巧妙template &lt;class DataType&gt;class MGraph &#123;    public:      MGraph(DataType a[], int n, int e); &#x2F;&#x2F; 构造函数，构造有n个顶点e条边的图     ~MGraph() &#123;&#125;     void DFS(int); &#x2F;&#x2F; 深搜     void BFS(int); &#x2F;&#x2F; 广搜        private:     DataType vertex[maxSize]; &#x2F;&#x2F; 存放图中顶点的数组     int edge[maxSize][maxSize]; &#x2F;&#x2F; 存放图中边的数组     int vertexNum, edgeNum; &#x2F;&#x2F; 图中的顶点数和变数&#125;;</code></pre><h5 id="构造函数-2">构造函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    vertexNum &#x3D; e, edgeNum &#x3D; n;    int i, j, w &#x3D; 0;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                 edge[i][j] &#x3D; 0;            else                edge[i][j] &#x3D; 100;        &#125;        for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;            cout &lt;&lt; &quot;input two vertexes of the edge: &quot;;            cin &gt;&gt; i &gt;&gt; j;            cout &lt;&lt; &quot;input the weight of the edge: &quot;;            cin &gt;&gt; w;            edge[i][j] &#x3D; w;        &#125;    &#125;&#125;</code></pre><h5 id="深搜和广搜">深搜和广搜</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        if (edge[v][i] &lt; 100 &amp;&amp; visited[i] &#x3D;&#x3D; 0)             DFS(i);    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int queue[maxSize];    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &lt; 100 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[v];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; 1;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="dijkstra-1">Dijkstra</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Dijkstra(MGraph&lt;DataType&gt; mg, int v) &#123;    int dist[maxSize];    &#x2F;&#x2F; dist为起点到各个点的距离，具有临时性    string path[maxSize];    string vertex(mg.vertex);    for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;        dist[i] &#x3D; mg.edge[v][i];        &#x2F;&#x2F; 初始化dist数组，0号顶点到其余各顶点的初始路程        if (dist[i] !&#x3D; 100) &#123;            path[i] +&#x3D; vertex[v];            path[i] +&#x3D; vertex[i];            &#x2F;&#x2F; 这里是记录起点可以直达的路径        &#125; else &#123;            path[i] &#x3D; &quot;&quot;;        &#125;    &#125;    dist[v] &#x3D; 0;    int num &#x3D; 1;    while (num &lt; mg.vertexNum) &#123;        int min &#x3D; 255, k &#x3D; 0; &#x2F;&#x2F; 每一轮重置最小值        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (dist[i] !&#x3D; 0 &amp;&amp; dist[i] &lt; min) &#123;                min &#x3D; dist[i];                k &#x3D; i;                &#x2F;&#x2F; 找最小值            &#125;        &#125;        &#x2F;&#x2F; cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; dist[k] &lt;&lt; &quot;;\n&quot;;        num++; &#x2F;&#x2F; 标记这是第几个被访问的点        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (dist[i] &gt; dist[k] + mg.edge[k][i]) &#123;                dist[i] &#x3D; dist[k] + mg.edge[k][i];                path[i] &#x3D; &quot;&quot;; &#x2F;&#x2F; 重置路径                path[i] +&#x3D; path[k]; &#x2F;&#x2F; 加上之前走过的路                path[i] +&#x3D; vertex[i];            &#125;        &#125;        cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; dist[k] &lt;&lt; &quot;;\n&quot;;        dist[k] &#x3D; 0;    &#125;&#125;</code></pre><h5 id="测试用例及邻接矩阵-1">测试用例及邻接矩阵</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0 1100 3300 41001 2502 4103 2203 460</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">   0   1   2   3   40          1&#39; 10                 &#39;2&#39;     50      20     &#39;3&#39; 30                 &#39;4&#39; 100     10  60     &#39;&#x2F;&#x2F; 横轴为x，竖轴为y       </code></pre><h5 id="完整代码-1">完整代码</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxSize &#x3D; 100;int visited[maxSize] &#x3D; &#123;0&#125;;template &lt;class DataType&gt;struct MGraph &#123;    public:     MGraph(DataType a[], int n, int e);     ~MGraph() &#123;&#125;     void DFS(int);     void BFS(int);     void Dijkstra(MGraph&lt;DataType&gt;, int);        private:     DataType vertex[maxSize];     int edge[maxSize][maxSize];     int vertexNum, edgeNum;&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, w &#x3D; 0;    vertexNum &#x3D; n, edgeNum &#x3D; e;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        vertex[i] &#x3D; a[i];    &#125;    for (i &#x3D; 0; i &lt; vertexNum; i++) &#123;        for (j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (i &#x3D;&#x3D; j)                edge[i][j] &#x3D; 0;            else                edge[i][j] &#x3D; 100;        &#125;    &#125;    for (int k &#x3D; 0; k &lt; edgeNum; k++) &#123;        cout &lt;&lt; &quot;input two vertexes of the edge: &quot;;        cin &gt;&gt; i &gt;&gt; j;        cout &lt;&lt; &quot;input the weight of the edge: &quot;;        cin &gt;&gt; w;        edge[i][j] &#x3D; w;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFS(int v) &#123;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    for (int i &#x3D; 0; i &lt; vertexNum; i++) &#123;        if (edge[v][i] &lt; 100 &amp;&amp; visited[i] &#x3D;&#x3D; 0)            DFS(i);    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFS(int v) &#123;    int queue[maxSize];    int front &#x3D; -1, rear &#x3D; -1;    cout &lt;&lt; vertex[v];    visited[v] &#x3D; 1;    queue[++rear] &#x3D; v;    while (front !&#x3D; rear) &#123;        v &#x3D; queue[++front];        for (int j &#x3D; 0; j &lt; vertexNum; j++) &#123;            if (edge[v][j] &lt; 100 &amp;&amp; visited[j] &#x3D;&#x3D; 0) &#123;                cout &lt;&lt; vertex[j];                visited[j] &#x3D; 1;                queue[++rear] &#x3D; j;            &#125;        &#125;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::Dijkstra(MGraph&lt;DataType&gt; mg, int v) &#123;    int distance[maxSize];    string path[maxSize];    string vertex(mg.vertex);    for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;        distance[i] &#x3D; mg.edge[v][i];        if (dist[i] !&#x3D; 100) &#123;            path[i] +&#x3D; vertex[v];            path[i] +&#x3D; vertex[i];        &#125; else &#123;            path[i] &#x3D; &quot;&quot;;        &#125;    &#125;    distance[v] &#x3D; 0;    int num &#x3D; 1;    while (num &lt; mg.vertexNum) &#123;        int min &#x3D; 100, k &#x3D; 0;        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (distance[i] !&#x3D; 0 &amp;&amp; distance[i] &lt; min) &#123;                min &#x3D; distance[i];                k &#x3D; i;            &#125;        &#125;        num++;        for (int i &#x3D; 0; i &lt; mg.vertexNum; i++) &#123;            if (distance[i] &gt; distance[k] + mg.edge[v][i]) &#123;                distance[i] &#x3D; distance[i] + mg.edge[k][i];                path[i] &#x3D; &quot;&quot;;                path[i] +&#x3D; path[k];                path[i] +&#x3D; vertex[i];            &#125;        &#125;        cout &lt;&lt; path[k] &lt;&lt; &#39;,&#39; &lt;&lt; distance[k] &lt;&lt; &quot;;\n&quot;;        distance[k] &#x3D; 0;    &#125;&#125;int main() &#123;    char ch[] &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;&#125;;    MGraph&lt;char&gt; mg(ch, 5, 7);    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;DFS: &quot;;    mg.DFS(0);    cout &lt;&lt; endl;    for (int i &#x3D; 0; i &lt; maxSize; i++) &#123;        visited[i] &#x3D; 0;    &#125;    cout &lt;&lt; &quot;BFS: &quot;;    mg.BFS(0);    cout &lt;&lt; &quot;the short path: \n&quot;;    mg.Dijkstra(mg, 0);&#125;</code></pre><h4 id="参考链接">参考链接</h4><p><a href="https://blog.csdn.net/zgsdlr/article/details/121426826">【数据结构】最小生成树Prim算法_zgsdlr的博客-CSDN博客_ java求最小生成树</a></p>]]></content>
    
    
    <summary type="html">填坑系列之图，整理了数据结构无向图、最小生成树(Prim和Dijkstra)</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--哈夫曼树与哈夫曼编码</title>
    <link href="https://jaydenchang.top/post/0x0028.html"/>
    <id>https://jaydenchang.top/post/0x0028.html</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2021-12-11T10:14:34.545Z</updated>
    
    <content type="html"><![CDATA[<p>填坑系列之哈夫曼树</p><p>刚开始看哈夫曼树时有点懵懵的，加权是啥子玩意，后面查阅资料后才明白，哈夫曼树以及哈夫曼编码多用在压缩编码中，再配合二倍速食用B站大学的网课，算是把整个算法过了一遍</p><h4 id="the-main-structure">the main structure</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int Max &#x3D; 1000;char **HuffmanCode;typedef struct Node &#123;    int weight;    int parent, left, right;&#125; HTNode, *HuffmanTree;</code></pre><h4 id="select">Select</h4><p>select是来选择剩余结点中权值最小的两颗二叉树(包括新构造的树)的左右子树来构建一个新的二叉树，新根节点权值为其左右子树根节点的权值之和</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Select(HuffmanTree ht, int k, int&amp; id1, int&amp; id2) &#123;    long min1, min2;    min1 &#x3D; min2 &#x3D; 99999; &#x2F;&#x2F; 不能太小    for (int i &#x3D; 0;i &lt; k;i++) &#123;        if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min1 &gt; ht[i].weight) &#123;            &#x2F;&#x2F; 选择无双亲的结点            if (min1 &lt; min2) &#123;                 &#x2F;&#x2F; 这里是比大小的操作，规定min1为小                min2 &#x3D; min1;                id2 &#x3D; id1;            &#125;            min1 &#x3D; ht[i].weight; &#x2F;&#x2F; 这个操作可以把这k个数据都遍历一遍，可以选出两个最小的结点            id1 &#x3D; i;        &#125; else if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min2 &gt; ht[i].weight) &#123;            min2 &#x3D; ht[i].weight;            id2 &#x3D; i;        &#125;    &#125;&#125;</code></pre><h4 id="create-a-huffman-tree">Create a Huffman Tree</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HuffmanTree(huffTree &amp;ht, int n) &#123;    int m &#x3D; n * 2 - 1;    int id1, id2;    int i;    if (n &lt; 0) &#x2F;&#x2F; 创建空树        return;    ht &#x3D; new Node[m];    for (i &#x3D; 0;i &lt; m;i++) &#123;        ht[i].parent &#x3D; ht[i].left &#x3D; ht[i].right &#x3D; -1;        &#x2F;&#x2F; 初始化各节点    &#125;    for (i &#x3D; 0;i &lt; n;i++) &#123;        cin &gt;&gt; ht[i].weight; &#x2F;&#x2F; 输入各个结点的权值    &#125;    for (i &#x3D; n;i &lt; m;i++) &#123;        Select(ht, i, id1, id2);        &#x2F;&#x2F; 在n个结点中选择俩无双亲的结点且权值最小的结点        ht[id1].parent &#x3D; ht[id2].parent &#x3D; i;        &#x2F;&#x2F; 获得id1，id2，把第i个结点设为它俩的双亲        ht[i].left &#x3D; id1;        ht[i].right &#x3D; id2; &#x2F;&#x2F; 设第i个结点的左右孩子为id1，id2        ht[i].weight &#x3D; ht[id1].weight + ht[id2].weight;    &#125;&#125;</code></pre><h4 id="destroy-a-huffman-tree">destroy a Huffman Tree</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Destroy(HuffmanTree &amp;ht) &#123;    delete[] ht;    ht &#x3D; NULL;&#125;</code></pre><h4 id="create-the-huffman-code">create the Huffman Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void createHuffmanCode(HuffmanTree ht, HuffmanCode &amp;hc, int n) &#123;    int start;    int cur, f;    hc &#x3D; new char *[n + 1];    char *cd &#x3D; new char[n];    cd[n - 1] &#x3D; &#39;\0&#39;;    for (i &#x3D; 0;i &lt; n;i++) &#123;        start &#x3D; n - 1;         cur &#x3D; i; &#x2F;&#x2F; 当前结点在数组中的位置        f &#x3D; hf[i].parent; &#x2F;&#x2F; 当前结点的父节点在数组的位置        while (f !&#x3D; 0) &#123;            &#x2F;&#x2F; 如果该结点是父节点的左孩子则对应编码为0，否则右孩子为1            start--;            if (hf[f].left &#x3D;&#x3D; cur)                cd[start] &#x3D; &#39;0&#39;;            else                 cd[start] &#x3D; &#39;1&#39;;            &#x2F;&#x2F; 以父节点为孩子结点，继续朝树根的方向遍历            cur &#x3D; f;            f &#x3D; hf[f].parent;        &#125;        &#x2F;&#x2F; 跳出循环后，cd数组中从下标start开始，存放的就是该结点的哈夫曼编码        hc[i] &#x3D; new char[n - start];        strcpy(hc[i], &amp;cd[start]);    &#125;    delete cd;&#125;</code></pre><h4 id="the-code">the code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int Max &#x3D; 9999;typedef char **HuffmanCode;typedef struct Node &#123;    int weight;    int parent, left, right;&#125; HTNode, *HuffmanTree;void Select(HuffmanTree ht, int k, int id1, int id2) &#123;    int min1 &#x3D; min2 &#x3D; 9999;for (int i &#x3D; 0;i &lt; k;i++) &#123;        if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min1 &lt; ht[i].weight) &#123;            if (min1 &lt; min2) &#123;                min2 &#x3D; min1;                id2 &#x3D; id1;            &#125;            id1 &#x3D; i;            min1 &#x3D; ht[i].weight;        &#125; else if (ht[i].parent &#x3D;&#x3D; -1 &amp;&amp; min2 &gt; ht[i].weight) &#123;            min2 &#x3D; ht[i].weight;            id2 &#x3D; i;        &#125;    &#125;&#125;void createHuffmanTree(HuffmanTree ht, int n) &#123;    int id1, id2;    if (n &lt;&#x3D; 0)         return;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        ht[i].left &#x3D; ht[i].right &#x3D; ht[i].parent &#x3D; 0;    &#125;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        cin &gt;&gt; ht[i].weight;    &#125;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        Select(ht, i, id1, id2);        ht[id1].parent &#x3D; ht[id2].parent &#x3D; i;        ht[i].left &#x3D; id1;        ht[i].right &#x3D; id2;        ht[weight] &#x3D; ht[id1].weight + ht[id2].weight;    &#125;&#125;void createHuffmanTreeCode(HuffmanTree ht, HuffmanCode &amp;hc, int n) &#123;    int start, cur f;    hc &#x3D; new char*[n + 1];    char* cd &#x3D; new char[n];    cd[n - 1] &#x3D; &#39;\0&#39;;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        start &#x3D; n - 1;        cur &#x3D; i;        f &#x3D; ht[i].parent;        while (f !&#x3D; 0) &#123;            start--;            if (ht[f].left &#x3D;&#x3D; cur) &#123;                cd[start] &#x3D; &#39;0&#39;;            &#125; else &#123;                cd[start] &#x3D; &#39;1&#39;;            &#125;            cur &#x3D; f;            f &#x3D; ht[i].parent;        &#125;        hc[i] &#x3D; cd[n - start];        strcpy(hc[i], &amp;cd[start]);    &#125;    delete cd;&#125;int main() &#123;    int n;    cin &gt;&gt; n;    HuffmanTree ht;    HuffmanCode hc;    int sum &#x3D; 0;    HuffmanTree(ht, n);    createHuffmanCode(ht, hc, n);    for (int i &#x3D; 0;i &lt; 2 * n - 1;i++) &#123;        cout &lt;&lt; ht[i].weight &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 测试，输出所有结点，包括非原有结点    &#125;    cout &lt;&lt; endl;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        cout &lt;&lt; hc[i] &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 输出每个结点的HuffmanCode    &#125;&#125;</code></pre><h4 id="参考链接">参考链接</h4><p><a href="https://www.cnblogs.com/linfangnan/p/12593480.html">数据结构：哈夫曼树与哈夫曼编码 - 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p><p><a href="https://www.bilibili.com/video/BV18t411U7Tb">数据结构与算法基础--第09周04--5.7哈夫曼树及其应用4-5.7.2哈夫曼树的构造算法2-哈夫曼树算法实现_哔哩哔哩_bilibili</a>(共6p)</p>]]></content>
    
    
    <summary type="html">填坑系列之哈夫曼树，整理了哈夫曼树和哈夫曼编码</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--简单二叉树(无序)</title>
    <link href="https://jaydenchang.top/post/0x0027.html"/>
    <id>https://jaydenchang.top/post/0x0027.html</id>
    <published>2021-11-15T16:00:00.000Z</published>
    <updated>2021-12-11T05:45:42.062Z</updated>
    
    <content type="html"><![CDATA[<p>本次来简单总结下简单二叉树(无序)，前面欠的债有点多，最近在疯狂追赶课程进度，简单记录下自己对简单二叉树的一些理解</p><h4 id="binary-tree">binary tree</h4><h5 id="the-main-structure">the main structure</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int Max &#x3D; 100;template &lt;class DataType&gt;struct BiNode &#123;    DataType data;    BiNode *leftChild, *rightChild;    &#125;;template &lt;class DataType&gt;class BiTree &#123;    public:     BiTree() &#123; root &#x3D; Create(); &#125;     ~BiTree() &#123; Release(root); &#125;     void PreOrder() &#123; PreOrder(root); &#125;     void InOrder() &#123; InOrder(root); &#125;     void LevelOrder();     int leafNum(BiNode*);     BiNode* getRoot() &#123; return root; &#125;        private:     BiNode* root;     BiNode* Create();     void Release(BiNode* bt);     void PreOrder(BiNode* bt);     void InOrder(BiNode* bt);     void PostOrder(BiNode* bt);&#125;;</code></pre><h5 id="create">Create()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;BiTree::BiTree() &#123;    BiNode* bt;    DataType ch;    cout &lt;&lt; &quot;enter a binary node: &quot;;    cin &gt;&gt; ch;    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;        return NULL;    &#125; else &#123;        bt &#x3D; new BiNode;        bt-&gt;data &#x3D; ch;        bt-&gt;leftChild &#x3D; Create();        bt-&gt;rightchild &#x3D; Create();        &#x2F;&#x2F; 不断套娃递归    &#125;&#125;</code></pre><h5 id="release">Release()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;BiTree::Release(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        Release(bt-&gt;leftChild);        Release(bt-&gt;rightChild);        delete bt;    &#125;&#125;</code></pre><h5 id="preorder">PreOrder</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::PreOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        PreOrder(bt-&gt;leftChild);        PreOrder(bt-&gt;rightChild);    &#125;&#125;</code></pre><h5 id="inorder">InOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::InOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        InOrder(bt-&gt;leftChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        InOrder(bt-&gt;rightChild);    &#125;&#125;</code></pre><h5 id="postorder">PostOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::PostOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        PostOrder(bt-&gt;leftChild);        PostOrder(bt-&gt;rightChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;    &#125;&#125;</code></pre><h5 id="levelorder">LevelOrder()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void BiTree::LevelOrder() &#123;    BiNode *queue[Max], *ptr &#x3D; NULL;    int front &#x3D; -1, rear &#x3D; -1;    if (root &#x3D;&#x3D; NULL)         return;        queue[++rear] &#x3D; root; &#x2F;&#x2F; 根节点入队    while (front !&#x3D; rear) &#123;        ptr &#x3D; queue[++front]; &#x2F;&#x2F; 把根节点赋给临时指针ptr        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;; &#x2F;&#x2F; 输出当前结点的内容               if (ptr-&gt;leftChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;leftChild;        if (ptr-&gt;rightChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;rightChild;        &#x2F;&#x2F; 这里依次遍历左右左右孩子节点并添加入列    &#125;&#125;</code></pre><h5 id="leafnum">leafNum()</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;int BiTree::leafNum(BiNode* bt)&#123;    if (bt &#x3D;&#x3D; NULL)        return 0;    if (bt-&gt;leftChild &#x3D;&#x3D; NULL &amp;&amp; bt-&gt;rightChild &#x3D;&#x3D; NULL)         return 1;    int left &#x3D; leafNum(bt-&gt;leftChild);    int right &#x3D; leafNum(bt-&gt;rightChild);    return left + right;&#125;</code></pre><h5 id="complete-code">Complete code</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int Max &#x3D; 100;template &lt;class DataType&gt;struct BiNode &#123;    DataType data;    BiNode *leftChild, *rightChild;&#125;;template &lt;class DataType&gt;class BiTree &#123;    public:     BiTree() &#123; root &#x3D; Create(); &#125;     ~BiTree() &#123;Release(root); &#125;     void PreOrder() &#123; PreOrder(root); &#125;     void InOrder() &#123; InOrder(root); &#125;     void PostOrder() &#123; PostOrder(root); &#125;     void LevelOrder();     int leafNum(BiNode*);     BiNode* getRoot() &#123; return root; &#125;        private:     BiNode* root;     BiNode* Create();     void Release(BiNode*);     void PreOrder(BiNode*);     void InOrder(BiNode*);     void PostOrder(BiNode*);&#125;;template &lt;class DataType&gt;BiNode* BiTree::Create() &#123;    BiNode* bt;    DataType ch;    cout &lt;&lt; &quot;enter a node data: &quot;;    cin &gt;&gt; ch;    if (ch !&#x3D; &#39;#&#39;) &#123;        bt-&gt;data &#x3D; ch;        bt-&gt;leftChild &#x3D; Create();        bt-&gt;rightChild &#x3D; Create();        return bt;    &#125;&#125;template &lt;class DataType&gt;void BiTree::Release(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        Release(bt-&gt;leftChild);        Release(bt-&gt;rightChild);        delete bt;    &#125;&#125;template &lt;class DataType&gt;void BiTree::PreOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        PreOrder(bt-&gt;leftChild);        PreOrder(bt-&gt;rightChild);    &#125;&#125;template &lt;class DataType&gt;void BiTree::InOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        InOrder(bt-&gt;leftChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;        InOrder(bt-&gt;rightChild);    &#125;&#125;template &lt;class DataType&gt;void BiTree::PostOrder(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL) &#123;        return;    &#125; else &#123;        PostOrder(bt-&gt;leftChild);        PostOrder(bt-&gt;rightChild);        cout &lt;&lt; bt-&gt;data &lt;&lt; &#39; &#39;;    &#125;&#125;template &lt;class DataType&gt;void BiTree::LevelOrder() &#123;    BiNode* queue[Max], ptr &#x3D; NULL;    int front &#x3D; -1, rear &#x3D; -1;    if (root &#x3D;&#x3D; NULL)        return;queue[++rear] &#x3D; root;    while (front !&#x3D; rear) &#123;        ptr &#x3D; queue[++front];        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;;        if (ptr-&gt;leftChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;leftChild;        if (ptr-&gt;rightChild !&#x3D; NULL)            queue[++rear] &#x3D; ptr-&gt;rightChild;    &#125;&#125;template &lt;class DataType&gt;int BiTree::leafNum(BiNode* bt) &#123;    if (bt &#x3D;&#x3D; NULL)        return 0;    if (bt-&gt;leftChild &#x3D;&#x3D; NULL &amp;&amp; bt-&gt;rightChild &#x3D;&#x3D; NULL)        return 1;    int left &#x3D; leafNum(bt-&gt;leftChild);    int right &#x3D; leafNum(bt-&gt;rightChild);    return left + right;    &#125;int main() &#123;    BiTree tree;    cout &lt;&lt; &quot;---PreOrder---\n&quot;;    tree.PreOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---InOrder---\n&quot;;    tree.InOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---PostOrder---\n&quot;;    tree.PostOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;---LevelOrder---\n&quot;;    tree.LevelOrder();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;the num of the leaves: &quot;;    cout &lt;&lt; tree.leafNum(tree.getRoot());&#125;</code></pre>]]></content>
    
    
    <summary type="html">整理了简单二叉树的简单应用，包括前中后遍历，求树的深度、叶子节点个数</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>kmp</title>
    <link href="https://jaydenchang.top/post/0x0026.html"/>
    <id>https://jaydenchang.top/post/0x0026.html</id>
    <published>2021-10-30T16:00:00.000Z</published>
    <updated>2022-08-16T14:23:32.545Z</updated>
    
    <content type="html"><![CDATA[<p>注：本篇文章只记录我理解的过程、需要注意的小细节，不涉及具体讲解，一些具体的原理、推导步骤可参考文末我列出的文章和视频</p><p>说到字符串匹配，以前的我，对时间、空间复杂度没有什么概念，估计写出来的代码长这样</p><h3 id="bfbrute-force">BF(brute-force)</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int BF(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0; j &#x3D; 0;    while (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        if (s[i] &#x3D;&#x3D; p[j]) &#123;            i++, j++;            &#x2F;&#x2F; 匹配成功就指针都后移        &#125; else &#123;            i &#x3D; i - j + 1;            j &#x3D; 0;        &#125;    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else         return -1;&#125;</code></pre><p>查阅资料后发现，这￥%&amp;#时间复杂度还挺高，假设文本串长m，模式串长n，时间复杂度是<code>O(m*n)</code>，如果m和n都很大的话，效率会低到无法想象</p><h3 id="kmp">kmp</h3><p>这时候，引入一个新算法，kmp，反正就是三个大佬的名字首字母拼在一起</p><p>要理解kmp，首先要理解kmp中的next数组，next数组，说人话，就类似一个索引。kmp的本质就是利用模式串的最长公共前后缀来缩短查找时间</p><p>如果字符失配，模式串向后移动<code>j-next[j]</code>位，这样说还不是很好理解，看一个例子</p><table><thead><tr class="header"><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr class="odd"><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td><u><strong>d</strong></u></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>这里在第七位失配，在d前面，有最长公共前后缀"ab"，长度为2，按照刚才说的，模式串向后移动<code>j-next[j]</code>位，即<code>6-next[6]</code>，其中<code>next[6] = 2</code>，变成如下</p><table><thead><tr class="header"><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td><u><strong>c</strong></u></td><td>d</td><td>a</td><td>b</td><td>d</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>c失配，c前无最长公共前后缀，向后移动<code>2-next[2]</code>，也就是2位</p><table><thead><tr class="header"><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td><u><strong>d</strong></u></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在d处又失配，再次移动<code>6-next[6]</code>也就是4位</p><table><thead><tr class="header"><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>d</th><th>e</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td>d</td><td></td></tr></tbody></table><p>匹配成功ヾ(≧▽≦*)o</p><p>以上就是kmp算法的基本实现流程</p><h4 id="next">next</h4><h5 id="next数组的二三事">next数组的二三事</h5><p>next数组的实质是：在当前字符前，最长公共前后缀的字符数</p><p>先拿出一个模式串：<code>abcabzan</code></p><p>对于next，有些版本默认第0位是-1，有的是0，这里默认第0位是-1.</p><ul><li>对于第一位是a，前面没有字符，赋值-1</li><li>第二位b前面只有一个字符，没有相同子串，赋值0</li><li>第三位前面两个字符没有同，赋值0</li><li>第四位前面也无，同上</li><li>第五位前面有相同前后缀元素，即a，赋值1</li><li>第六位前面，继续找，发现有更长的前后缀公共元素，是ab，两个字符，赋值2</li><li>第七位无，第八位前有一个a，赋值1，后面无公共元素</li><li>一般来说不用管最后一位是否和前面的字符能匹配上，next的目的是判断当前字符前面是否有相同的子串</li></ul><p>最后把next数组的值罗列一下</p><p><code>-1 0 0 0 1 2 0 1</code></p><p>然后就得到了next数组</p><h5 id="next数组代码实现">next数组代码实现</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void makeNext(string p, int next[]) &#123;    int j &#x3D; 0, k &#x3D; -1;    int len &#x3D; p.length();    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            &#x2F;&#x2F; 这里判断是否从首位开始匹配，或者模式串前后是否匹配成功            j++, k++;            next[j] &#x3D; k;            &#x2F;&#x2F; 匹配成功就把当前匹配的字符数赋给当前next[j]            &#x2F;&#x2F; 即模式串第j位前有k个最长前后缀公共元素        &#125; else &#123;            k &#x3D; next[k];            &#x2F;&#x2F; 把当前next[k]赋给k，也就相当于整个模式串向后移动next[k]位        &#125;    &#125;&#125;</code></pre><h5 id="next数组的优化">next数组的优化</h5><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr class="odd"><td>a</td><td>b</td><td>a</td><td>b</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>对于模式串<code>"abab"</code>，它的next数组为<code>-1 0 0 1</code></p><p>当c与b失配时，模式串向后移动<code>3-next[3] = 2</code>，变成如下</p><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td>a</td><td><u><strong>b</strong></u></td><td>a</td><td>b</td><td></td><td></td><td></td></tr></tbody></table><p>看到上面这里，原来<code>p[j]</code>和<code>s[j]</code>失配，右移之后，变成<code>s[j]</code>和<code>p[next[j]]</code>(即前后缀相同字符)匹配，然后呢，又失配了，虽然说在这组字符串里最后都能匹配成功，但是移动后，按照道理，失配位前面的字符在移动之后都能匹配成功，如果一直出现这样的情况的话，那么匹配的效率就会下降。</p><p>那么怎么修改？答案是，<strong>不能容许<code>p[j]=p[next[j]]</code></strong>。如果出现刚才叙述的情况，则需递归，令<code>next[j] = next[next[j]]</code></p><p>那么这个递归又是怎么个回事呢？(看了好久才懂)</p><p>随便举一个字符串<code>ababc</code></p><p>下标从0开始，到c这个位置，也就是第4位，下标为1的字符b和下标为3的字符b是等价的，在递归之后，next数组更新，可避免出现刚才那样的bug，后移之后在前面的子串部分失配(按照道理，公共前后缀部分是不会失配的)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void makeNext(string p, int next[]) &#123;    int len &#x3D; p.length();    int k &#x3D; -1, j &#x3D; 0;    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            j++, k++;            if (p[j] !&#x3D; p[k])                 next[j] &#x3D; k;            &#x2F;&#x2F; 如果匹配失败就把匹配数赋给next[j]            else                 next[j] &#x3D; next[k];            &#x2F;&#x2F; 不能出现p[j] &#x3D; p[next[j]]的情况，需要继续递归        &#125; else &#123;            k &#x3D; next[k];            &#x2F;&#x2F; 把k复位(分匹配是否成功两种情况)        &#125;    &#125;&#125;</code></pre><p>优化过后的数组</p><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>b</th></tr></thead><tbody><tr class="odd"><td>-1</td><td>0</td><td>-1</td><td>0</td></tr></tbody></table><p>单单只看优化过后的代码，感觉还是有点恍惚，还是要结合kmp的主干部分来看</p><h4 id="kmp-1">kmp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int kmp(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0, j &#x3D; 0;    int *next &#x3D; new int[len2];    makeNext(p, next);    while (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        &#x2F;&#x2F; j为-1 or 匹配成功才指针后移        if(j &#x3D;&#x3D; -1 || s[i] &#x3D;&#x3D; p[j])             i++, j++;        &#x2F;&#x2F; 匹配就指针后移        else             j &#x3D; next[j];                &#x2F;&#x2F; 不匹配就根据之前求出的next来决定模式串从哪开始匹配    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else        return 0;&#125;</code></pre><p>优化过后继续结合刚才优化前出现bug的那个数组</p><p>优化后next：<code>-1 0 -1 0</code></p><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr class="odd"><td>a</td><td>b</td><td>a</td><td><u><strong>b</strong></u></td><td></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第四位失配，后移<code>3-next[3]</code>，递归后<code>next[3] = 0</code>，后移了3位</p><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td>a</td><td>b</td><td>a</td><td>b</td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td><td></td></tr></tbody></table><p>c和a失配，再后移</p><table><thead><tr class="header"><th>a</th><th>b</th><th>a</th><th>c</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr class="odd"><td></td><td></td><td></td><td></td><td>a</td><td>b</td><td>a</td><td>b</td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td><td>-1</td><td>0</td><td>-1</td><td>0</td><td></td></tr></tbody></table><p>匹配成功</p><h4 id="完整代码">完整代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;void makeNext(string p, int next[]);int kmp(string s, string p);void makeNext(string p, int next[]) &#123;    int len &#x3D; p.length();    int j &#x3D; 0, k &#x3D; -1;    next[0] &#x3D; -1;    while (j &lt; len - 1) &#123;        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;            j++, k++;            if (p[j] !&#x3D; p[k])                next[j] &#x3D; next[k];            else                k &#x3D; next[j];        &#125;     &#125;&#125;int kmp(string s, string p) &#123;    int len1 &#x3D; s.length();    int len2 &#x3D; p.length();    int i &#x3D; 0, j &#x3D; 0;    int *next &#x3D; new int[len2];    makeNext(p, next);    while (i &lt; len1 &amp;&amp; j &lt; len2) &#123;        if (j &#x3D;&#x3D; -1 || s[i] &#x3D;&#x3D; p[j])            i++, j++;        else            j &#x3D; next[j];    &#125;    if (j &#x3D;&#x3D; len2)        return 1;    else         return 0;&#125;int main() &#123;    string s, p;    cin &gt;&gt; s &gt;&gt; p;    if (kmp(s, p) &#x3D;&#x3D; 1)        cout &lt;&lt; &quot;found the key string\n&quot;;    else        cout &lt;&lt; &quot;not found the key string\n&quot;;&#125;</code></pre><h3 id="参考链接">参考链接</h3><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解KMP（2014年8月22日版）_结构之法 算法之道-CSDN博客_kmp</a></p><p><a href="https://www.bilibili.com/video/BV1Ys411d7yh?from=search&amp;seid=14595349758363193343&amp;spm_id_from=333.337.0.0">【soso字幕】汪都能听懂的KMP字符串匹配算法【双语字幕】_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">填坑系列之kmp，本篇文章只记录我理解的过程、需要注意的小细节，不涉及具体讲解，一些具体的原理、推导步骤可参考文末我列出的文章和视频</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--不设头指针的循环链队列</title>
    <link href="https://jaydenchang.top/post/0x0025.html"/>
    <id>https://jaydenchang.top/post/0x0025.html</id>
    <published>2021-10-24T16:00:00.000Z</published>
    <updated>2021-12-11T05:52:19.369Z</updated>
    
    <content type="html"><![CDATA[<p>本次数据结构的作业是设计一个只有尾指针的循环链队列，要求实现构造(有参 &amp;&amp; 无参)、析构、出入列、获取头结点等功能。在完成过程中踩了很多坑(特别是在实现析构时qwq)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;struct Node &#123;    DataType data;    Node&lt;DataType&gt;* next;&#125;;template &lt;class DataType&gt;class LinkQueue &#123;    public:     LinkQueue();     LinkQueue(int [], int);     ~LinkQueue();     void EnQueue(DataType x);     DataType DeQueue();     DataType GetQueue();        private:     Node&lt;DataType&gt;* rear;&#125;;</code></pre><h4 id="有参构造无参构造">有参构造&amp;&amp;无参构造</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue(int arr[], int n) &#123;    rear &#x3D; new Node&lt;DataType&gt;;    Node&lt;DataType&gt;* p &#x3D; rear;    &#x2F;&#x2F;储存首地址，最后把尾巴连上for(int i &#x3D; 0; i &lt; n; i++) &#123;        rear-&gt;next &#x3D; new Node&lt;DataType&gt;;        rear &#x3D; rear-&gt;next;        rear-&gt;data &#x3D; arr[i];    &#125;    rear-&gt;next &#x3D; p;    &#x2F;&#x2F; 把尾巴连到首部&#125;template &lt;class DataType&gt;LinkQueue&lt;DataTpye&gt;::LinkQueue() &#123;    rear &#x3D; NULL;&#125;</code></pre><h4 id="进队-出队">进队 &amp;&amp; 出队</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;void LinkQueue&lt;DataType&gt;::EnQueue(DataType x) &#123;    Node&lt;DataType&gt;* p &#x3D; new Node&lt;DataType&gt;;        p-&gt;data &#x3D; x;    if (rear &#x3D;&#x3D; NULL) &#123;        rear &#x3D; p;        rear-&gt;next &#x3D; p;    &#125; else &#123;        p-&gt;next &#x3D; rear-&gt;next;  &#x2F;&#x2F; 新建节点连接头指针        rear-&gt;next &#x3D; p; &#x2F;&#x2F; 尾指针连接新节点        rear &#x3D; p; &#x2F;&#x2F; 尾指针后移    &#125;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::DeQueue() &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    DataType x;    if (rear &#x3D;&#x3D; NULL)         throw &quot;dive dowm&quot;;    p &#x3D; rear-&gt;next;    x &#x3D; p-&gt;data;    if (rear &#x3D;&#x3D; p)        rear &#x3D; NULL;    else         rear-&gt;next &#x3D; p-&gt;next;    delete p;    return x;&#125;</code></pre><h4 id="获取头结点">获取头结点</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::GetQueue() &#123;    if (rear !&#x3D; NULL)        return rear-&gt;next-&gt;data;    &#x2F;&#x2F; return rear-&gt;data;    &#x2F;&#x2F; 这里rear已经指向队末，按照上一行代码，返回的是队末元素    else        throw &quot;empty queue&quot;;&#125;</code></pre><h4 id="清空循环链队列也可写成析构">清空循环链队列(也可写成析构)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::~LinkQueue() &#123;    Node&lt;DataType&gt;* p;    while (rear !&#x3D; NULL) &#123;        &#x2F;&#x2F; the wrong version:                &#x2F;&#x2F; p &#x3D; rear;        &#x2F;&#x2F; rear &#x3D; rear-&gt;next;        &#x2F;&#x2F; delete p;        p &#x3D; rear-&gt;next;        if (rear &#x3D;&#x3D; p) &#123;            delete rear;            break;        &#125; else             rear-&gt;next &#x3D; p-&gt;next;        delete p;    &#125;&#125;</code></pre><p>关于这个析构函数，我在网上找了很多个版本，很多代码都是写成注释里的那样，包括老师给的答案也是，有些编译器直接运行可能看不出什么问题，但是放在debug模式里，就会报错</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0025-1.jpg' style="zoom:67%;" ></p><p>如上图，在这里我已将循环链队列所有元素delete，当我查看变量的值时，发现，没那么简单，rear指针不为null，它指向的data值也是不规则的，也就不难说明为什么跳不出第46行的while循环了</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0025-2.jpg' style="zoom:67%;" ></p><p>跳不出循环后，继续delete，就会报错，虽然提示<code>unKnown signal</code>，实际上是队列为空，无法继续delete</p><p>那么怎么解决呢，我将出列函数改写，放到析构函数里，这样子在删除最后一个节点时就能跳出循环，结束析构</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0025-3.JPG'></p><h4 id="完整代码">完整代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template &lt;class DataType&gt;struct Node &#123;    DataType data;    Node&lt;DataType&gt;* next;&#125;;template &lt;class DataType&gt;class LinkQueue &#123;   public:    LinkQueue();    LinkQueue(int[], int);    ~LinkQueue();    void EnQueue(DataType x);    DataType DeQueue();    DataType GetQueue();   private:    Node&lt;DataType&gt;* rear;&#125;;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue(int arr[], int n) &#123;    rear &#x3D; new Node&lt;DataType&gt;;    &#x2F;&#x2F; rear-&gt;data &#x3D; arr[0];    Node&lt;DataType&gt;* p &#x3D; rear;  &#x2F;&#x2F; 储存首地址，最后把尾巴连接到首部    for (int i &#x3D; 0; i &lt; n; i++) &#123;        rear-&gt;next &#x3D; new Node&lt;DataType&gt;;  &#x2F;&#x2F; 不断开辟空间        rear &#x3D; rear-&gt;next;                &#x2F;&#x2F; rear后移        rear-&gt;data &#x3D; arr[i];    &#125;    rear-&gt;next &#x3D; p;  &#x2F;&#x2F;把尾巴连到首部&#125;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue() &#123;    rear &#x3D; NULL;&#125;template &lt;class DataType&gt;LinkQueue&lt;DataType&gt;::~LinkQueue() &#123;    Node&lt;DataType&gt;* p;    while (rear !&#x3D; NULL) &#123;                p &#x3D; rear-&gt;next;        if (rear &#x3D;&#x3D; p) &#123;            delete rear;            break;        &#125; else &#123;            rear-&gt;next &#x3D; p-&gt;next;        &#125;        delete p;    &#125;&#125;template &lt;class DataType&gt;void LinkQueue&lt;DataType&gt;::EnQueue(DataType x) &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    p &#x3D; new Node&lt;DataType&gt;;    p-&gt;data &#x3D; x;    if (rear &#x3D;&#x3D; NULL) &#123;        rear &#x3D; p;        rear-&gt;next &#x3D; p;    &#125; else &#123;        p-&gt;next &#x3D; rear-&gt;next;  &#x2F;&#x2F; 新建节点连接头指针        rear-&gt;next &#x3D; p;        &#x2F;&#x2F; 尾指针连接新节点        rear &#x3D; p;              &#x2F;&#x2F; 尾指针后移    &#125;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::DeQueue() &#123;    Node&lt;DataType&gt;* p &#x3D; NULL;    DataType x;    if (rear &#x3D;&#x3D; NULL)        throw &quot;dive down&quot;;    p &#x3D; rear-&gt;next;    x &#x3D; p-&gt;data;    if (rear &#x3D;&#x3D; p)        rear &#x3D; NULL;    else        rear-&gt;next &#x3D; p-&gt;next;    delete p;    return x;&#125;template &lt;class DataType&gt;DataType LinkQueue&lt;DataType&gt;::GetQueue() &#123;    if (rear !&#x3D; NULL)        return rear-&gt;next-&gt;data;    &#x2F;&#x2F; return rear-&gt;data;    &#x2F;&#x2F; 这里rear已指向队末，返回的是队末元素    else        throw &quot;empty queue&quot;;&#125;int main() &#123;    LinkQueue&lt;int&gt; Queue;    try &#123;        Queue.EnQueue(5);        Queue.EnQueue(10);        Queue.EnQueue(15);        &#x2F;&#x2F; Queue.EnQueue(20);    &#125; catch (char* wrong) &#123;        cout &lt;&lt; wrong &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;get head element&quot; &lt;&lt; endl;    cout &lt;&lt; Queue.GetQueue() &lt;&lt; endl;    try &#123;        Queue.DeQueue();    &#125; catch (char* wrong) &#123;        cout &lt;&lt; wrong &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;get head element&quot; &lt;&lt; endl;    cout &lt;&lt; Queue.GetQueue() &lt;&lt; endl;&#125;</code></pre>]]></content>
    
    
    <summary type="html">记录一次和作业答案bug的对抗过程</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构--关于单链表小细节的一些补充</title>
    <link href="https://jaydenchang.top/post/0x0024.html"/>
    <id>https://jaydenchang.top/post/0x0024.html</id>
    <published>2021-10-04T16:00:00.000Z</published>
    <updated>2021-12-11T05:53:22.157Z</updated>
    
    <content type="html"><![CDATA[<p>以下是在做数据结构作业时遇到的一些bug<del>(老师给的答案不太行)</del></p><h4 id="无相应构造函数报错">无相应构造函数报错</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int MaxSize &#x3D; 10;template &lt;class T&gt;class Seqlist &#123;    public:    Seqlist() &#123; length &#x3D; 0;&#125;    Seqlist(T [],int);    private:    int length;    T data[MaxSize];&#125;;    class B &#123;    public:    B(T);    B() &#123;&#125; &#x2F;&#x2F;这个默认的构造函数十分重要    private:    T data;&#125;;B::B(T n) &#123;    data &#x3D; n;&#125;template &lt;class T&gt;Seqlist&lt;T&gt;::Seqlist(T arr[], int n) &#123;    if (n &gt; MaxSize) throw &quot;invalid num&quot;;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        data[i] &#x3D; arr[i];    &#125;    length &#x3D; n;&#125;int main() &#123;    B b[3] &#x3D; &#123;B(10), B(20), B(30)&#125;;    Seqlist&lt;B&gt; list(b,3);&#125;</code></pre><p>在上面部分代码中，如果把有注释的那一行代码删去，则这部分代码不能正常运行，报错信息是</p><p><code>no matching function for call to 'B::B()'[25, 35]</code></p><p>根据这个报错信息找到相应行数，居然在<code>int n</code>这里报错，我寻思着这关n什么事，后面查阅了资料，原因出在第34行的<code>B b[3]</code>这里，定义了一个B类型的数组，没有参数传入，而B类中无适配该成员的构造函数，于是编译器报错</p><p>解决方法是，加上相应的构造函数<code>B() &#123;&#125;</code></p><h4 id="线性链表的反转和复制功能">线性链表的反转和复制功能</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;template &lt;class T&gt;struct Node &#123;    T data;    Node&lt;T&gt;* next;&#125;;template &lt;class T&gt;class LinkList &#123;    public:     LinkList(); &#x2F;&#x2F; create an empty list    LinkList(T[], int);    &#x2F;&#x2F;~LinkList();        void Reverse(Node&lt;T&gt;* head);    Node&lt;T&gt;* Copy(Node&lt;T&gt;* head);    Node&lt;T&gt;* first;&#125;template &lt;class T&gt;LinkList&lt;T&gt;::LinkList() &#123;    first &#x3D; new Node&lt;T&gt;;    first-&gt;next &#x3D; NULL;&#125;template &lt;class T&gt;LinkList&lt;T&gt;::LinkList(T arr[], int n) &#123;    first &#x3D; new Node&lt;T&gt;;    Node&lt;T&gt;* p &#x3D; first;    for (int i &#x3D; 0;i &lt; n;i++) &#123;        Node&lt;T&gt;* s &#x3D; new Node&lt;T&gt;;        s-&gt;data &#x3D; arr[i];        p-&gt;next &#x3D; s;&#x2F;&#x2F;让first指向第一个节点        p &#x3D; s;&#x2F;&#x2F;虽说把s的地址赋给p，但是first的地址和p不一样，对p操作不会改变first        &#x2F;&#x2F;因此first永远指向链表第一个位置    &#125;    p-&gt;next &#x3D; NULL;&#125;template &lt;class T&gt;void LinkList&lt;T&gt;::Reverse(Node&lt;T&gt;* head) &#123;    Node&lt;T&gt;* pre, *cur;    cur &#x3D; head-&gt;next;    head-&gt;next &#x3D; NULL;    while (cur) &#123;        pre &#x3D; cur;&#x2F;&#x2F;让当前节点的上一节点移动到当前节点位置        cur &#x3D; cur-&gt;next;&#x2F;&#x2F;当前节点移动到下一个位置        pre-&gt;next &#x3D; head-&gt;next;&#x2F;&#x2F;这一操作就是让pre不断指向前一个节点        head-&gt;next &#x3D; pre;&#x2F;&#x2F;更新节点，让head的next指向pre    &#125;    &#x2F;&#x2F;在画图理解时，要让cur和pre同时向后移动    &#x2F;&#x2F;这一部分，建议自己在纸上画出若干个节点和用三个小部件(代表三个指针)模拟一边才能够真正地理解&#125;&#x2F;&#x2F;复盘时自己有个小细节没注意到，这里都是指针变量的赋值操作，这里的赋值只是赋予地址，给予者的值改变，接收者的值不会改变template &lt;class T&gt;Node&lt;T&gt;* LinkList&lt;T&gt;::Copy(Node&lt;T&gt;* head) &#123;    Node&lt;T&gt;* headB &#x3D; new Node&lt;T&gt;;    Node&lt;T&gt;* pb &#x3D; headB;    Node&lt;T&gt;* pa &#x3D; head-&gt;next;    while (pa !&#x3D; NULL) &#123;        Node&lt;T&gt;* temp &#x3D; new Node&lt;T&gt;;        temp-&gt;data &#x3D; pa-&gt;data;        temp-&gt;next &#x3D; NULL;&#x2F;&#x2F;这里用到了一个临时指针变量        pb-&gt;next &#x3D; temp;&#x2F;&#x2F;让pb连上temp        pb &#x3D; pb-&gt;next;        pa &#x3D; pa-&gt;next;        &#x2F;&#x2F;这里向后移动    &#125;    return headB;    &#x2F;&#x2F;注意这里返回的是headB，在调用时记得再加一个&quot;-&gt;next&quot;&#125;int main() &#123;    int arr[] &#x3D; &#123;1, 2, 3, 4, 5&#125;;    LinkList&lt;int&gt; list(arr,5);    cout &lt;&lt; &quot;the origin state: &quot; &lt;&lt; endl;    list.PrintList();        cout &lt;&lt; endl &lt;&lt; &quot;copy list a to list b\n&quot;;    Node&lt;int&gt;* ptr &#x3D; new Node&lt;int&gt;;    ptr &#x3D; list.copy(list.first)-&gt;next;    while (ptr !&#x3D; NULL) &#123;        cout &lt;&lt; ptr-&gt;data &lt;&lt; &#39; &#39;;        ptr &#x3D; ptr-&gt;next;    &#125;        cout &lt;&lt; endl &lt;&lt; &quot;reverse the list a\n&quot;;    list.Reverse(list.first);    list.PrintList();&#125;</code></pre><h4 id="链表反转参考视频">链表反转参考视频</h4><p><a href="https://www.bilibili.com/video/BV1KZ4y157Up?from=search&amp;seid=15845376229805622503&amp;spm_id_from=333.337.0.0">LeetCode力扣刷题 | 剑指Offer 24. 反转链表_哔哩哔哩_bilibili</a> [小姐姐声音很温柔doge]</p><p><a href="https://www.bilibili.com/video/BV1CW411N7mg?from=search&amp;seid=15845376229805622503&amp;spm_id_from=333.337.0.0">一分钟教你链表反转_哔哩哔哩_bilibili</a> [这个动画模拟比较贴合代码框的函数]</p><p>//谁知道我当时居然还去断点debug把每个节点以及他们的next的地址抄下来去对比</p>]]></content>
    
    
    <summary type="html">记录一次和老师给的答案的bug的对抗过程</summary>
    
    
    
    <category term="C++" scheme="https://jaydenchang.top/categories/C/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://jaydenchang.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>旧手机改造成web服务器并实现内网穿透</title>
    <link href="https://jaydenchang.top/post/0x0023.html"/>
    <id>https://jaydenchang.top/post/0x0023.html</id>
    <published>2021-08-27T16:00:00.000Z</published>
    <updated>2021-12-11T05:53:51.507Z</updated>
    
    <content type="html"><![CDATA[<p>前几天由于gitee的审核引擎一通乱杀，使得gitee pages停止提供服务，心生更换服务器或者其他pages托管的想法，看了看价格感人的云服务器以及空空的钱包，这时，脑子有个奇怪的想法飘过，自己搞一个服务器，忽然想起来，我有一台root的旧手机，刚好拿来做测试</p><h3 id="前期准备">前期准备</h3><p>需要的工具：一台旧安卓手机(能获取root权限)，能联网的电脑，并装有Git</p><p>需要安装的软件：Linux Deploy，BusyBox，JuiceSSH (可选)，KSWEB (可选)</p><blockquote><p>JuiceSSH执行命令速度比电脑快，不过是手机操作，可能需要外接键盘</p><p>以下操作全在电脑端操作，不演示JuiceSSH与Linux Deploy的连接 (教程见文末第三个链接)</p></blockquote><p>需要的经验：部署过hexo博客，有一定git (或linux)基础，灵活运用关键字搜索，vim编辑器的使用语法</p><p><em>旧手机的基本信息</em></p><blockquote><ul><li>手机型号：Redmi 3</li><li>Android版本：5.1.1</li><li>Linux发行版：CentOS 7 (AltArch) [running via Linux Deploy]</li><li>RAM：2.0GiB</li><li>CPU：8核1.5GHz</li><li>储存空间：10GiB，可用4GiB</li></ul></blockquote><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-1.jpg' style="zoom: 25%;border-radius:2em" ></p><h3 id="配置linux环境">配置Linux环境</h3><p>首先打开BusyBox，点击安装 (需要root权限)</p><p>然后打开Linux Deploy，点击右下方的配置，设置系统相关信息，容器类型选chroot，发行版选CentOS，如果选其他发行版，架构一定要选对，不然会安装出错，或者无法使用，安装之前一定要知道手机CPU的架构；源地址建议切换为国内源，这里放上中科大的镜像源 http://mirrors.ustc.edu.cn/centos-altarch/ ，国内还有其他源可选择，例如清华源，阿里源等</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-2.jpg' style="zoom: 25%;border-radius:2em" ></p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-3.jpg' style="zoom: 25%;border-radius:2em" ></p><p>这里的设置很重要，一定要启用ssh，后面的步骤会用到 (SSH默认端口是22，此端口用于JuiceSSH连接)</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-4.jpg' style="zoom: 25%;border-radius:2em" ></p><p>然后返回主界面，点击左上，打开设置，建议前三个选项都勾上，往下滑，看到<code>PATH变量</code>，输入<code>/system/xbin</code>，再往下拉，把 调试模式 也勾上</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-5.jpg' style="zoom: 25%;border-radius:2em" ></p><p>再回到主界面，点击右上角，开始安装，大约要半小时</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-6.jpg' style="zoom: 25%;border-radius:2em" ></p><p>a few thousand years later......</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-7.jpg' style="zoom: 25%;border-radius:2em" ></p><p>看到手机输出<code>&lt;&lt;&lt;deploy</code>时说明安装完成，启动前先点击一次停止按钮，看见<code>&lt;&lt;&lt;stop</code>时再点击启动，看见输出如图内容时即成功启动。</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-8.jpg' style="zoom: 25%;border-radius:2em" ></p><p>然后打开KSWEB，查看当前手机的局域网ip，例如我手机的ip是192.168.101.10</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-9.jpg' style="zoom: 25%;border-radius:2em" ></p><p>然后打开电脑终端(cmd，git，wsl都可)，输入<code>ssh admin@192.168.101.10</code>，按照要求输入密码(前面的Linux Deploy配置里有密码的选项)，如下图所示即成功连接手机</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-10.jpg' style="zoom: 100%;border-radius:0.5em" ></p><h3 id="在服务器上部署">在服务器上部署</h3><h4 id="配置git">配置git</h4><p>在服务器端安装git和node.js</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y gitcurl -sL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_12.x | bash -yum -y install nodejs</code></pre><div class="tip"><p>如果出现没做任何操作，下载自行终止并出现<code>Exiting on user cancel</code>，可尝试输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum clean metadatayum clean allyum upgrade</code></pre><p>如果出现<code>Failed to set locale, defaulting to C.UTF-8</code>，是没有正确设置语言环境或者没安装相关语言包导致的，可尝试用两种解决方法</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;export LC_ALL&#x3D;en_US.UTF-8&quot; &gt;&gt; &#x2F;etc&#x2F;profilesource &#x2F;etc&#x2F;profile</code></pre><p>执行完后<strong>重新登陆</strong>再试安装，若还出现这个情况，安装相应语言包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install glibc-langpack-zh &#x2F;&#x2F;中文包&#x2F;&#x2F;英文包dnf install glibc-langpack-en 或dnf install langpacks-en glibc-all-langpacks -y</code></pre></div><p>创建用户并配置其仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">useradd gitpasswd git &#x2F;&#x2F; 设置密码su git &#x2F;&#x2F; 这步很重要，不切换用户后面会很麻烦cd &#x2F;home&#x2F;git&#x2F;mkdir -p projects&#x2F;blog &#x2F;&#x2F; 项目存在的真实目录mkdir repos &amp;&amp; cd reposgit init --bare blog.git &#x2F;&#x2F; 创建一个裸露的仓库cd blog.git&#x2F;hooksvi post-receive &#x2F;&#x2F; 创建 hook 钩子函数，输入了内容如下</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;shgit --work-tree&#x3D;&#x2F;home&#x2F;git&#x2F;projects&#x2F;blog --git-dir&#x3D;&#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git checkout -f</code></pre><p>添加完毕修改权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod +x post-receiveexit &#x2F;&#x2F; 退出到 root 登录chown -R git:git &#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git &#x2F;&#x2F; 添加权限</code></pre><p>测试<code>git仓库</code>是否可用，另找空白文件夹，在电脑端右键git bash here，输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone git@server_ip:&#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git</code></pre><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-11.jpg' style="zoom:50%;border-radius:0.7em" ></p><p>如果能clone空仓库，说明git仓库搭建成功</p><p>建立ssh信任关系，在电脑输入以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-copy-id -i C:&#x2F;Users&#x2F;yourname&#x2F;.ssh&#x2F;id_rsa.pub git@server_ip&#x2F;&#x2F;如果用户名有空格，路径用引号括起来ssh git@server_ip &#x2F;&#x2F; 测试能否登录</code></pre><p><strong>注：此时的 ssh 登录 git 用户不需要密码！否则就有错，请仔细重复步骤 3-5</strong></p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-12.jpg' style="zoom:50%;border-radius:0.7em" ></p><p>如图即成功添加信任</p><p>为了安全起见禁用 git 用户的 shell 登录权限，从而只能用 git clone，git push</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;etc&#x2F;shells &#x2F;&#x2F; 查看 git-shell 是否在登录方式里面which git-shell &#x2F;&#x2F; 查看是否安装vi &#x2F;etc&#x2F;shells添加上2步显示出来的路劲，通常在 &#x2F;usr&#x2F;bin&#x2F;git-shell</code></pre><p>修改<code>/etc/passwd</code>中的权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;&#x2F; 将原来的git:x:1000:1000::&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash&#x2F;&#x2F; 修改为git:x:1000:1000:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</code></pre><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-13.jpg' style="zoom:45%;" ></p><blockquote><p>需修改的内容一般在最后一行，数字不用改，只需添加半角逗号和改路径即可</p></blockquote><h4 id="搭建nginx服务器">搭建nginx服务器</h4><p>下载并安装nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;usr&#x2F;local&#x2F;srcwget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.15.2.tar.gztar xzvf nginx-1.15.2.tar.gzcd nginx-1.15.2&#x2F;&#x2F; 执行之前先检查是否有安装gcc gdb gcc-c++ make wget这五个软件，没有的话不能进行下一步，可直接用yum命令安装.&#x2F;configure &#x2F;&#x2F; 如果后面还想要配置 SSL 协议，就执行后面一句！.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_modulemake &amp;&amp; make installalias nginx&#x3D;&#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx&#39; &#x2F;&#x2F; 为 nginx 取别名，后面可直接用，重新登陆后失效</code></pre><p>配置nginx文件</p><p>先启动是否安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx &#x2F;&#x2F; 直接来！浏览器查看 server_ip，默认是 80 端口</code></pre><p>修改配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -s stop &#x2F;&#x2F; 先停止nginxcd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;confvi nginx.conf修改 root 解析路径，如下图同时将 user 改为 root 如下图，不然nginx无法访问 &#x2F;home&#x2F;git&#x2F;projects&#x2F;blognginx -s reload</code></pre><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-14.jpg' style="zoom:50%;border-radius:0.7em" ></p><blockquote><p>需要修改第一个箭头所指的nobody，第二个箭头所指的是会产生bug的文件</p></blockquote><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-15.jpg' style="zoom:50%;border-radius:0.7em" ></p><blockquote><p>需要修改root的路径为博客位置，例如我之前设置的位置是<code>/home/git/projects/blog</code>，就把这个路径替换进去，注意不要漏了句尾的分号</p></blockquote><div class="tip"><p>在修改配置文件这里目测有坑，会出现<code>/usr/local/nginx/logs/nginx.pid failed</code>这样的字眼，打开<code>/usr/local/nginx/logs</code>，输入<code>ls -al</code>，没看见有<code>nginx.pid</code>，我的解决方法是输入这个<br /><code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code>，再输入<code>ls -al</code>，发现<code>nginx.pid</code>出现了，再次运行<code>nginx -s reload</code>，没有报错。</p></div><p>在这里，可以测试下部署在服务器的网页，不过只能实现局域网查。注意上图中有一个<code>listen  80</code>，这是一个设置在localhost的端口，可尝试在浏览器打开预览，不过建议换成其他端口，避免端口被占用无法预览，这里我换成800，可成功预览</p><div class="warning"><p>别忘了启动nginx，不然不能预览页面</p></div><p>在手机浏览器输入<code>127.0.0.1:800</code>或<code>192.168.101.10:800</code>可以预览</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-19.jpg' style="zoom: 40%;border-radius:0.8em" ></p><p>在同一局域网的电脑输入<code>192.168.101.10:800</code>即可预览</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-20.jpg' style="zoom: 50%;border-radius:0.8em" ></p><h3 id="发布">发布</h3><h4 id="配置_config.yml文件">配置<code>_config.yml</code>文件</h4><p>编辑deploy属性</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-17.jpg' style="zoom: 67%;border-radius:0.8em" ></p><blockquote><p>repo是推送到的目的地地址</p></blockquote><p>推送到服务器</p><p>使用<code>hexo d -g</code>或<code>hexo g- d</code>均可，如图即成功推送</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-18.jpg' style="zoom:67%;border-radius:0.7em" ></p><h3 id="内网穿透">内网穿透</h3><p>内网穿透有很多工具，常见的有花生壳，FRP，ngork。由于花生壳的价格过于感人，FRP需要另一台有公网ip的服务器，这里使用基于ngork的<a href='natapp.cn'>natapp</a></p><p>官网：https://natapp.cn <del>(快来打钱doge)</del></p><p>这里需要在Linux安装，安装方法用wget + Linux安装包，由于我不知道wget会保存到哪里，所以我在wget后加了一个指定路径</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget -P &#x2F;home&#x2F;git&#x2F; https:&#x2F;&#x2F;cdn.natapp.cn&#x2F;assets&#x2F;downloads&#x2F;clients&#x2F;2_3_9&#x2F;natapp_linux_arm64&#x2F;natapp?version&#x3D;20190730</code></pre><p>下载之后对安装包重命名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv natapp?version&#x3D;20190730 natapp</code></pre><p>在root下先给予执行权限再执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod a+x natapp.&#x2F;natapp</code></pre><p>直接运行<code>./natapp</code>还不能运行程序，这里需要加上创建的隧道的authtoken参数才能打开</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;natapp -authtoken&#x3D;&lt;your token&gt;</code></pre><p>运行程序后，图中的网址已穿透内网，可对外访问 (这是个临时链接)</p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-21.jpg' style="zoom:50%;border-radius:0.8em" ></p><p><img src='https://jaydenchang.gitee.io/images/images/0x0023/0x0023-22.jpg' style="zoom:40%;border-radius:0.8em" ></p><p>到这里，一个web私人服务器就搭好了。</p><p>另外，关于穿透的网址，natapp有一个付费隧道可以绑定自定义域名，每个月9￥，而花生壳那边的价格比较感人 (还花了6￥开启https穿透的认证，发现没什么luan用，我*&amp;%@)，最终还是选择了natapp</p><p>不过，我还是选择GitHub Pages + Netlify 来配置我的网站，私人服务器跑网页，需要让服务器24h保持运作状态 (感觉也废不了什么电费)，毕竟通过隧道来访问网站的速度和直接托管在GitHub Pages差不多，干脆直接用GitHub Pages比较省事</p><p>除了网页服务器，旧手机理论上也可以建一个私人网盘 <del>(感觉也没时间整了)</del></p><h3 id="参考链接">参考链接</h3><p><a href="https://ii.do/24.html">旧手机搭建网站以及内网穿透 - Dark's blog (ii.do)</a></p><p><a href="https://blog.csdn.net/qq_35561857/article/details/81590953">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器_jeffery5461的博客-CSDN博客_</a></p><p><a href="https://www.cnblogs.com/sw-code/p/14990229.html">使用Linux Deploy将闲置的安卓手机改造简易服务器 - sw-code - 博客园 (cnblogs.com)</a></p><p><a href="https://segmentfault.com/a/1190000017986794">超详细Hexo+Github Page搭建技术博客教程【持续更新】 - SegmentFault 思否</a></p><p>[<a href="https://blog.csdn.net/qq_41502780/article/details/104064975">解决nginx: [error] open() ＂/usr/local/nginx/logs/nginx.pid＂ failed错误_三也先生的博客-CSDN博客]</a></p><p><a href="https://developer.aliyun.com/article/387493">centos 7 升级后yum install出现Exiting on user cancel-阿里云开发者社区 (aliyun.com)</a></p><p><a href="https://www.cnblogs.com/h2285409/p/14745010.html">Failed to set locale, defaulting to C.UTF-8 - 天军 - 博客园 (cnblogs.com)</a></p><p><a href="https://mx142.cn/2020/12/22/11/">把hexo博客部署到服务器 | MX (mx142.cn)</a></p>]]></content>
    
    
    <summary type="html">我用半个月做了一个&quot;服务器&quot;</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="整活" scheme="https://jaydenchang.top/tags/%E6%95%B4%E6%B4%BB/"/>
    
    <category term="Linux" scheme="https://jaydenchang.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>迁移博客</title>
    <link href="https://jaydenchang.top/post/0x0022.html"/>
    <id>https://jaydenchang.top/post/0x0022.html</id>
    <published>2021-08-19T16:00:00.000Z</published>
    <updated>2021-12-11T05:54:15.728Z</updated>
    
    <content type="html"><![CDATA[<p>本站点已由<a href='https://jaydenchang.gitee.io'>旧站点</a>迁往<a href='https://jaydenchang.top'>jaydenchang.top</a>，旧站点已废弃</p><p>前几天准备更博客时，发现gitee的站点被ban了，了解到我的站点有违规内容 <del>(一脸懵逼)</del>，具体就不吐槽了，<strong>果然免费的是最贵的</strong>。后来心里冒出个想法，迁博客到别的服务器，gitee就当作图床了doge。</p><p>最终还是选择了GitHub pages，云服务器太贵了，自己搭的服务器内网穿透效果一般般<del>(先挖个坑)</del></p>]]></content>
    
    
    <summary type="html">记录一次站点迁移</summary>
    
    
    
    <category term="随笔" scheme="https://jaydenchang.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://jaydenchang.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>为博客添加评论邮件提醒功能(踩坑全过程)</title>
    <link href="https://jaydenchang.top/post/0x0021.html"/>
    <id>https://jaydenchang.top/post/0x0021.html</id>
    <published>2021-08-15T16:00:00.000Z</published>
    <updated>2021-12-11T05:55:03.852Z</updated>
    
    <content type="html"><![CDATA[<p>在很早之前，我就想过要给博客加一个邮件评论提醒功能，上个月折腾了三天愣是没折腾出什么，这几天学不进去，刚好来折腾这个。</p><p>因为懒，需要加载到图床的图片太多，这次不插入图片。</p><h3 id="准备工作">准备工作</h3><ul><li>注册一个 leancloud 国际版账户(国内的需要备案等一系列复杂的操作)</li><li>去GitHub fork项目，开启GitHub Action功能</li></ul><h3 id="为hexo博客添加评论valine系统">为hexo博客添加评论valine系统</h3><p>这一步可参考以下链接，此处不再赘述，包括</p><ul><li>注册leancloud</li><li>配置hexo博客根目录下的<code>_config.(the name of your theme).yml</code> (这里需要修改的是对应主题的yml文件，不是<code>_config.yml</code>)</li></ul><p><a href='https://blog.csdn.net/blue_zy/article/details/79071414'>为你的Hexo加上评论系统-Valine -- blue_zy</a></p><p><a href='https://blog.csdn.net/jiunian_2761/article/details/97388997'>Hexo博客进阶：为Next主题添加Valine评论系统-- 千帆过烬</a></p><p>前两步，csdn，博客园大多数帖子都有教程，剩下的步骤有些难度，需要大量阅读相关帖子</p><h3 id="为hexo博客添加valine评论邮件提醒功能">为hexo博客添加valine评论邮件提醒功能</h3><p>这一步包括</p><ul><li>自定义云引擎的变量 <del>(可选择氪还是不氪，不氪的选择体验版)</del></li><li>添加定时任务，定期唤醒和检查补发邮件</li></ul><p><a href='https://blog.csdn.net/Aoman_Hao/article/details/105323917'>Hexo博客Next主题valine评论系统邮件提醒 -- AomanHao</a></p><p>完成这一步并且测试后，我心满意足，开始写博客，一开始还是有收到评论邮件的，过几天更新时发现有新评论却没有邮件提醒，回到leancloud后台一看，我%￥#&amp;*，引擎自动休眠了，再看日志，现实云函数报错，马上去必应一下这个情况，找不到有效解决方案，那就先搁着；过了几天来看，我去，提示我这个信息</p><p>"因为流控问题，通过定时任务唤醒体验版实例失败，建议升级至标准版引擎实例避免休眠"</p><p>好家伙，这明摆着要我去氪。不过，本着我多年不氪金<del>(白嫖)</del>的习惯，又去必应了下解决方案</p><h3 id="解决leancloud流控问题最难">解决leancloud流控问题(最难)</h3><p>有三个常见的唤醒功能</p><ul><li>cron-job</li><li>Github+Action</li><li>Ajax请求唤醒</li></ul><p>csdn上大多数是去阿里云等网站申请唤醒功能，不过这些感觉需要花很多大洋的样子，就没去理会，后来发现GitHub+Action这个貌似不错，然后就去必应了下，雀食有很多帖子教GitHub+Action的，不过他们fork的项目已经不能访问了，就是这个： <code>https://github.com/blogimg/WakeLeanCloud</code></p><p>下面这两个帖子的</p><p><a href='https://hiram.wang/leancloud-timer-github-actions/#原有方案'>使用Github Actions模拟评论解决LeanCloud的流控限制 -- Hiram's Blog</a></p><p><a href='https://www.aimtao.net/slef-wake-leancloud/'>Gtihub Action｜一行命令解决 LeanCloud 流控问题 -- AimTao's Blog</a></p><p>以上两个博客提到的GitHub建议fork到本地仓库</p><p>按照上面两个博客其中之一设置完就差不多设置好了</p><h3 id="可能出现的问题">可能出现的问题</h3><ul><li>怎么进入leancloud国际版评论后台网站：参照这个博客来设置user变量 <a href='https://www.fezhu.top/2020/07/02/liukong/'>解决Leancloud流控问题 -- Uncleacc's Blog</a></li><li>为什么提示云函数报错：是因为没有在云引擎处设置变量<code>ADMIN_URL</code>，这里填leancloud评论后台管理网址</li><li>云引擎中的变量<code>SMTP_PASS</code>不是邮箱密码，是邮箱SMTP的授权码</li><li>GitHub Action那里的<code>SITE</code>应该填评论后台管理网址</li></ul><p>写到这里，总算把折腾的全过程写出来了<del>(无用的知识增加了)</del></p>]]></content>
    
    
    <summary type="html">记录一次整活，完善博客的评论提醒功能</summary>
    
    
    
    <category term="整活" scheme="https://jaydenchang.top/categories/%E6%95%B4%E6%B4%BB/"/>
    
    
    <category term="整活" scheme="https://jaydenchang.top/tags/%E6%95%B4%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>单链表(Java)</title>
    <link href="https://jaydenchang.top/post/0x0020.html"/>
    <id>https://jaydenchang.top/post/0x0020.html</id>
    <published>2021-08-06T16:00:00.000Z</published>
    <updated>2021-12-11T05:56:35.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识">基础知识</h3><p>大体结构和C++的链表差不多，参考之前写过的博客 <a href='https://jaydenchang.gitee.io/post/0x0006'>单链表图书管理系统实例</a> <a href='https://jaydenchang.gitee.io/post/0x000B'>基于类的单链表实例</a></p><p>补充之前不知道的：链表分两类，带和不带头结点的链表 <del>现在才知道，Java没有像C/C++那样的指针</del></p><p>首先创建一个<code>LinkList</code>类，然后把链表的各个功能添加进去</p><h4 id="创建结点">创建结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;当不考虑编号顺序时，找到当前链表最后节点，将最后节点next指向新节点public void add(PersonNode node) &#123;    &#x2F;&#x2F;因为头节点不能动，先需要一个辅助遍历节点temp    PersonNode temp &#x3D; head;            while (true) &#123;&#x2F;&#x2F;遍历链表，找到最后        if (temp.next &#x3D;&#x3D; null) &#123;            break;        &#125;                    temp &#x3D; temp.next;&#x2F;&#x2F;如果没到最后，就继续找下去    &#125;&#x2F;&#x2F;当退出while循环时，temp指向链表的最后    temp.next &#x3D; node;&#125;</code></pre><h4 id="添加结点乱序">添加结点(乱序)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void addByOrder(PersonNode node) &#123;    &#x2F;&#x2F;因为头节点不移动，仍通过一个辅助变量来找添加的位置    &#x2F;&#x2F;因为是单链表，所以找的temp时位于添加位置的前一个结点，否则不能插入    PersonNode temp &#x3D; head;    boolean flag &#x3D; false;&#x2F;&#x2F;标识添加的编号是否存在    while (true) &#123;        if (temp.next &#x3D;&#x3D; null) &#x2F;&#x2F;说明temp在链表最后            break;        if (temp.next.no &gt; node.no) &#123;&#x2F;&#x2F;位置找到了，就在temp后面            break;        &#125; else if (temp.next.no &#x3D;&#x3D; node.no) &#123;&#x2F;&#x2F;希望添加的编号已存在            flag &#x3D; true;            break;        &#125;        temp &#x3D; temp.next;    &#125;    if (flag) &#123;&#x2F;&#x2F;编号已存在，不能添加        System.out.println(&quot;already exist no.&quot; + node.no + &quot;, you can&#39;t add it.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125; else &#123;        node.next &#x3D; temp.next;        temp.next &#x3D; node;    &#125;&#125;&#x2F;&#x2F;最终还是按照序号来排列</code></pre><h4 id="编辑结点">编辑结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void edit(PersonNode node) &#123;&#x2F;&#x2F;这里直接引入外部结点，根据node.no来寻找需要修改的结点    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    PersonNode temp;    temp &#x3D; head.next;    boolean flag &#x3D; false;&#x2F;&#x2F;判断是否找到该结点    while (true) &#123;        if (temp &#x3D;&#x3D; null)            break;&#x2F;&#x2F;到了链表最后        if (temp.no &#x3D;&#x3D; node.no) &#123;            flag &#x3D; true;&#x2F;&#x2F;找到            break;        &#125;        temp &#x3D; temp.next;    &#125;    &#x2F;&#x2F;根据flag判断是否找到    if (flag) &#123;        temp.name &#x3D; node.name;        temp.score &#x3D; node.score;    &#125; else &#123;        System.out.println(&quot;not found no.&quot; + node.no + &quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#125;</code></pre><h4 id="删除结点">删除结点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void delete(int no) &#123;    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    PersonNode temp &#x3D; head;&#x2F;&#x2F;temp指向待删除结点的前一个结点    boolean flag &#x3D; false;    while (true) &#123;        if (temp.next &#x3D;&#x3D; null) &#123;                            break;&#x2F;&#x2F;已经到链表最后        &#125;        if (temp.next.no &#x3D;&#x3D; no) &#123;            flag &#x3D; true;&#x2F;&#x2F;找到了待删除结点的前一个结点temp            break;        &#125;        temp &#x3D; temp.next;    &#125;    if (flag) &#123;        temp.next &#x3D; temp.next.next;    &#x2F;&#x2F;Java会自动回收未被访问的数据            &#125; else &#123;        System.out.println(&quot;not found&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#125;</code></pre><h4 id="打印链表">打印链表</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void list() &#123;    &#x2F;&#x2F;判断链表是否为空    if (head.next &#x3D;&#x3D; null) &#123;        System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        return;    &#125;    &#x2F;&#x2F;头节点不动，需要一个辅助变量来遍历    PersonNode temp &#x3D; head.next;    while (true) &#123;        &#x2F;&#x2F;判断是否到链表最后        if (temp &#x3D;&#x3D; null) &#123;            break;        &#125;        &#x2F;&#x2F;输出节点信息        System.out.println(temp);        &#x2F;&#x2F;由于之前重写了toString，这里直接打印temp就可以打印出节点的所有信息        temp &#x3D; temp.next;    &#125;&#125;</code></pre><h4 id="主函数">主函数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;    PersonNode person1 &#x3D; new PersonNode(1, &quot;Jordan&quot;, 56);    PersonNode person2 &#x3D; new PersonNode(2, &quot;Kobe&quot;, 81);    PersonNode person3 &#x3D; new PersonNode(3, &quot;James&quot;, 61);    PersonNode person4 &#x3D; new PersonNode(4, &quot;Melo&quot;, 60);    LinkList list &#x3D; new LinkList();&#x2F;&#x2F;按照顺序添加    &#x2F;&#x2F; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#x2F;&#x2F; list.add(person1);    &#x2F;&#x2F; list.add(person2);    &#x2F;&#x2F; list.add(person3);    &#x2F;&#x2F; list.add(person4);&#x2F;&#x2F;不按照顺序添加    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add by order&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    list.addByOrder(person1);    list.addByOrder(person4);    list.addByOrder(person3);    list.addByOrder(person2);    list.list();    &#x2F;&#x2F; list.addByOrder(person2);    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;edit&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    PersonNode newNode &#x3D; new PersonNode(3, &quot;Ivring&quot;, 57);    list.edit(newNode);    list.list();&#x2F;&#x2F;删除结点    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;delete&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    list.delete(4);    list.list();&#125;</code></pre><h4 id="完整代码">完整代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;SingleLinkList.javapublic class SingleLinkList &#123;    public static void main(String[] args) &#123;        PersonNode person1 &#x3D; new PersonNode(1, &quot;Jordan&quot;, 56);        PersonNode person2 &#x3D; new PersonNode(2, &quot;Kobe&quot;, 81);        PersonNode person3 &#x3D; new PersonNode(3, &quot;James&quot;, 61);        PersonNode person4 &#x3D; new PersonNode(4, &quot;Melo&quot;, 60);        LinkList list &#x3D; new LinkList();    &#x2F;&#x2F;按照顺序添加        &#x2F;&#x2F; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#x2F;&#x2F; list.add(person1);        &#x2F;&#x2F; list.add(person2);        &#x2F;&#x2F; list.add(person3);        &#x2F;&#x2F; list.add(person4);    &#x2F;&#x2F;不按照顺序添加        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;add by order&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        list.addByOrder(person1);        list.addByOrder(person4);        list.addByOrder(person3);        list.addByOrder(person2);        list.list();        &#x2F;&#x2F; list.addByOrder(person2);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;edit&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        PersonNode newNode &#x3D; new PersonNode(3, &quot;Ivring&quot;, 57);        list.edit(newNode);        list.list();    &#x2F;&#x2F;删除结点        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;delete&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        list.delete(4);        list.list();    &#125;&#125;&#x2F;&#x2F;定义一个成员点class PersonNode &#123;    String name;    public int no;    public int score;    public PersonNode next;&#x2F;&#x2F;指向下一个结点    public PersonNode(int no, String name, int score) &#123;        this.no &#x3D; no;        this.name &#x3D; name;        this.score &#x3D; score;    &#125;    &#x2F;&#x2F;为了显示方便，重写toString    @Override    public String toString() &#123;        return &quot;[no&#x3D;&quot; + no + &quot;,name&#x3D;&quot; + name + &quot;,score&#x3D;&quot; + score + &quot;]&quot;;    &#125;&#125;&#x2F;&#x2F;定义LinkList管理personclass LinkList &#123;    &#x2F;&#x2F;初始化头节点，头节点不能动    private PersonNode head &#x3D; new PersonNode(0, &quot;&quot;, 0);    public PersonNode getHead()&#123;        return head;&#x2F;&#x2F;返回私有成员head    &#125;    &#x2F;&#x2F;当不考虑编号顺序时，找到当前链表最后节点，将最后节点next指向新节点    public void add(PersonNode node) &#123;        &#x2F;&#x2F;因为头节点不能动，先需要一个辅助遍历节点temp        PersonNode temp &#x3D; head;                while (true) &#123;&#x2F;&#x2F;遍历链表，找到最后            if (temp.next &#x3D;&#x3D; null) &#123;                break;            &#125;                        temp &#x3D; temp.next;&#x2F;&#x2F;如果没到最后，就继续找下去        &#125;&#x2F;&#x2F;当退出while循环时，temp指向链表的最后        temp.next &#x3D; node;    &#125;    public void addByOrder(PersonNode node) &#123;        &#x2F;&#x2F;因为头节点不移动，仍通过一个辅助变量来找添加的位置        &#x2F;&#x2F;因为是单链表，所以找的temp时位于添加位置的前一个结点，否则不能插入        PersonNode temp &#x3D; head;        boolean flag &#x3D; false;&#x2F;&#x2F;标识添加的编号是否存在        while (true) &#123;            if (temp.next &#x3D;&#x3D; null) &#x2F;&#x2F;说明temp在链表最后                break;            if (temp.next.no &gt; node.no) &#123;&#x2F;&#x2F;位置找到了，就在temp后面                break;            &#125; else if (temp.next.no &#x3D;&#x3D; node.no) &#123;&#x2F;&#x2F;希望添加的编号已存在                flag &#x3D; true;                break;            &#125;            temp &#x3D; temp.next;        &#125;        if (flag) &#123;&#x2F;&#x2F;编号已存在，不能添加            System.out.println(&quot;already exist no.&quot; + node.no + &quot;, you can&#39;t add it.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125; else &#123;            node.next &#x3D; temp.next;            temp.next &#x3D; node;        &#125;    &#125;    public void edit(PersonNode node) &#123;        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        PersonNode temp;        temp &#x3D; head.next;        boolean flag &#x3D; false;&#x2F;&#x2F;判断是否找到该结点        while (true) &#123;            if (temp &#x3D;&#x3D; null)                break;&#x2F;&#x2F;到了链表最后            if (temp.no &#x3D;&#x3D; node.no) &#123;                flag &#x3D; true;&#x2F;&#x2F;找到                break;            &#125;            temp &#x3D; temp.next;        &#125;        &#x2F;&#x2F;根据flag判断是否找到        if (flag) &#123;            temp.name &#x3D; node.name;            temp.score &#x3D; node.score;        &#125; else &#123;            System.out.println(&quot;not found no.&quot; + node.no + &quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;        public void delete(int no) &#123;        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        PersonNode temp &#x3D; head;&#x2F;&#x2F;temp指向待删除结点的前一个结点        boolean flag &#x3D; false;        while (true) &#123;            if (temp.next &#x3D;&#x3D; null) &#123;                                break;&#x2F;&#x2F;已经到链表最后            &#125;            if (temp.next.no &#x3D;&#x3D; no) &#123;                flag &#x3D; true;&#x2F;&#x2F;找到了待删除结点的前一个结点temp                break;            &#125;            temp &#x3D; temp.next;        &#125;        if (flag) &#123;            temp.next &#x3D; temp.next.next;        &#125; else &#123;            System.out.println(&quot;not found&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#x2F;&#x2F;Java会自动回收未被访问的数据    &#125;    &#x2F;&#x2F;显示链表(遍历)    public void list() &#123;        &#x2F;&#x2F;判断链表是否为空        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;empty LinkList&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);            return;        &#125;        &#x2F;&#x2F;头节点不动，需要一个辅助变量来遍历        PersonNode temp &#x3D; head.next;        while (true) &#123;            &#x2F;&#x2F;判断是否到链表最后            if (temp &#x3D;&#x3D; null) &#123;                break;            &#125;            &#x2F;&#x2F;输出节点信息            System.out.println(temp);            &#x2F;&#x2F;由于之前重写了toString，这里直接打印temp就可以打印出节点的所有信息            temp &#x3D; temp.next;        &#125;    &#125;&#125;</code></pre><h3 id="面试题">面试题</h3><h4 id="求单链表中有效结点个数">求单链表中有效结点个数</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;如果带头节点的链表，不统计头节点public static int getLength(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null)        return 0;    int length &#x3D; 0;    PersonNode current &#x3D; head.next;&#x2F;&#x2F;定义辅助变量    while (current !&#x3D; null) &#123;        length++;        current &#x3D; current.next;    &#125;    return length;&#125;</code></pre><p>在主函数中测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(getLength(list.getHead()));</code></pre><h4 id="查找单链表中倒数第n个结点新浪">查找单链表中倒数第n个结点(新浪)</h4><p>思路</p><ul><li>编写一个方法，接收head结点，同时接收一个index</li><li>index表示是倒数第index个结点</li><li>先把链表从头到尾遍历，得到链表的总长度 getLength</li><li>得到size后，我们从链表第一个开始遍历<code>(size-index)</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static PersonNode findLastIndexNode(PersonNode head, int index)&#123;    if (head.next &#x3D;&#x3D; null)        return null;    int size &#x3D; getlength(head);&#x2F;&#x2F;第一次遍历，获取链表大小    if (index &lt;&#x3D; 0 || index &gt; size)&#x2F;&#x2F;判断倒数的序号是否超出容量        return null;    PersonNode current &#x3D; head.next;    for (int i &#x3D; 0; i &lt; size - index; i++) &#123;        current &#x3D; current.next;&#x2F;&#x2F;遍历size-index次    &#125;    return current;&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">PersonNode res &#x3D; findLastIndexNode(list.getHead(), 1);System.out.println(res);</code></pre><h4 id="单链表反转腾讯">单链表反转(腾讯)</h4><p>思路</p><ul><li>先定义一个结点<code>reverseHead = new PersonNode();</code></li><li>从头到尾遍历原来的链表，每遍历一个链表，就将其取出，放在新链表最前端</li><li>原来链表的<code>head.next = reverseHead.next;</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void reverseList(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)        return;    &#x2F;&#x2F; 定义一个辅助遍历，帮助遍历原来的链表    PersonNode current &#x3D; head.next;    PersonNode next &#x3D; null;&#x2F;&#x2F;指向当前结点[current]的下一个结点    PersonNode reverseHead &#x3D; new PersonNode(0, &quot;&quot;, 0);    while (current !&#x3D; null) &#123;        next &#x3D; current.next;&#x2F;&#x2F;先暂时保存当前结点的下一个结点，后面会用到        current.next &#x3D; reverseHead.next;&#x2F;&#x2F;把current的下一个结点指向新链表最前端        reverseHead.next &#x3D; current;&#x2F;&#x2F;将current连接到新链表        current &#x3D; next;&#x2F;&#x2F;让current后移&#x2F;*每一次循环，reverseHead.next都会按照原链表的顺序定位到current，遍历结束，刚到reverseHead.next定位到链表最后一个，此时把reverseHead.next地址赋给head.next，这样就可以倒着来遍历链表*&#x2F;    &#125;    head.next &#x3D; reverseHead.next;&#x2F;&#x2F;头结点拼接，实现反转&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">reverseList(list.getHead());list.list();</code></pre><h4 id="从尾到头打印单链表百度">从尾到头打印单链表(百度)</h4><p>思路</p><ul><li>1.先反转后再打印(有个问题：只要求逆序打印，不要求反转，这样会破坏原链表结构)</li><li>2.用栈的方法，利用栈先进后出的特点，实现逆序打印的效果</li></ul><blockquote><p><code>stack.java</code></p></blockquote><p>下面是栈的实例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Stack;public class stack&#123;    public static void main(String[] args)&#123;        Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();        stack.add(&quot;James&quot;);        stack.add(&quot;Kboe&quot;);        stack.add(&quot;Jordan&quot;);        while(stack.size() &gt; 0)&#123;            System.out.println(stack.pop());        &#125;    &#125;&#125;</code></pre><p>用栈的方法实现从头到尾打印单链表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void reversePrint(PersonNode head) &#123;    if (head.next &#x3D;&#x3D; null)        return;    &#x2F;&#x2F;创建一个栈，将各个结点压入栈    Stack&lt;PersonNode&gt; stack &#x3D; new Stack&lt;PersonNode&gt;();    PersonNode current &#x3D; head.next;    while (current !&#x3D; null) &#123;        stack.push(current);        current &#x3D; current.next;    &#125;    while (stack.size() &gt; 0) &#123;        System.out.println(stack.pop());    &#125;&#125;</code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">reversePrint(list.getHead());</code></pre>]]></content>
    
    
    <summary type="html">Java版的链表</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组和队列(数组)</title>
    <link href="https://jaydenchang.top/post/0x001F.html"/>
    <id>https://jaydenchang.top/post/0x001F.html</id>
    <published>2021-08-05T16:00:00.000Z</published>
    <updated>2021-12-11T06:06:16.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="稀疏数组">稀疏数组</h3><p>当一个数组中大部分元素是0时，或者为同一个值的数组时，可以用稀疏数组来保存该数组，节省储存空间(二维数组储存太浪费空间了)</p><!--more>应用场景- 五子棋、围棋记录黑白子，无占位处记为0，黑白分别记为1，2- 扫雷- 象棋类，跳棋等处理方法：- 记录数组有几行几列，有多少个不同的值- 把有不同值的元素的行列及值记录在一个小规模的数组里，从而缩小程序的规模二维数组转化稀疏数组的思路- 遍历原始二维数组，得到有效数据的个数- 根据sum就可以创建稀疏数组 `int spareseArr[sum + 1][3]`- 将二维数组的有效数据的个数sum存入稀疏数组稀疏数组转原始二维数组- 先读稀疏数组第一行，根据第一行数据创建原始二维数组- 在读取稀疏数组后几行的数据，并赋予原始的二维数组`int originArr[size][size]`即可#### 代码<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;spareseArray.javaimport java.util.Scanner;public class spareseArray&#123;    public static void main(String[] args)&#123;        public static void main(String[] args) &#123;        Scanner scan &#x3D; new Scanner(System.in);        int size &#x3D; scan.nextInt();        scan.close();        int chessArr[][] &#x3D; new int[size][size];&#x2F;&#x2F;创建一个11*11的棋盘        chessArr[1][2] &#x3D; 1;        chessArr[2][3] &#x3D; 2;        chessArr[4][6] &#x3D; 1;        int sum &#x3D; 0;        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                if (chessArr[i][j] !&#x3D; 0)                    sum++;            &#125;        &#125;        &#x2F;&#x2F;创建稀疏数组        int spareseArr[][] &#x3D; new int[sum + 1][3];        &#x2F;&#x2F;给稀疏数组赋值        spareseArr[0][0] &#x3D; size;        spareseArr[0][1] &#x3D; size;        spareseArr[0][2] &#x3D; sum;        &#x2F;&#x2F;遍历二维数组，把非0的值存放在稀疏数组中        int count &#x3D; 0;&#x2F;&#x2F;计数器，记录非0数据个数        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                if (chessArr[i][j] !&#x3D; 0) &#123;                    count++;                    spareseArr[count][0] &#x3D; i;                    spareseArr[count][1] &#x3D; j;                    spareseArr[count][2] &#x3D; chessArr[i][j];                &#125;            &#125;        &#125;        &#x2F;&#x2F;输出稀疏数组的形式        System.out.println(&quot;the sparese Array:&quot;);        for (int i &#x3D; 0; i &lt; sum + 1; i++) &#123;            System.out.printf(&quot;%d %d %d\n&quot;, spareseArr[i][0], spareseArr[i][1], spareseArr[i][2]);        &#125;        &#x2F;&#x2F;稀疏数组恢复二维数组        int originArr[][] &#x3D; new int[spareseArr[0][0]][spareseArr[0][1]];        &#x2F;&#x2F;输出恢复后的二维数组        for (int i &#x3D; 1; i &lt; spareseArr.length; i++) &#123;            originArr[spareseArr[i][0]][spareseArr[i][1]] &#x3D; spareseArr[i][2];        &#125;        System.out.println(&quot;the origin array:&quot;);        for (int i &#x3D; 0; i &lt; size; i++) &#123;            for (int j &#x3D; 0; j &lt; size; j++) &#123;                System.out.print(originArr[i][j] + &quot; &quot;);            &#125;            System.out.println();        &#125;        &#125;&#125;</code></pre><p>参考链接：<a href='https://www.bilibili.com/video/BV1E4411H73v?from=search&seid=10722391219764061578'>尚硅谷--Java数据结构p7-p9  bilibili</a></p><h3 id="队列数组">队列(数组)</h3><p>队列是一个有序列表，可以用数组或者链表来实现。遵循先入先出原则，这一部分用数组来模拟</p><p>应用场景：银行排队案例</p><p>队列本身是有序列表，需要两个变量front和rear分别标记队列前后端，front随着数据输出而改变，rear随着数据输入而改变。还有需要一个maxSize来标记队列的最大容量。</p><p>当存数据入列时</p><ul><li>把尾指针后移：rear+1，当front=rear [ 空 ]</li><li>若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。<code>rear == maxSize-1</code> =&gt; 队列满</li></ul><h4 id="代码">代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package hello;import java.util.Scanner;public class Queue &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;创建一个队列        ArrayQueue queue &#x3D; new ArrayQueue(3);        char key &#x3D; &#39; &#39;;        Scanner scan &#x3D; new Scanner(System.in);        boolean loop &#x3D; true;        &#x2F;&#x2F;输出一个菜单        while (loop) &#123;            System.out.println(&quot;s(show queue)&quot;);            System.out.println(&quot;e(exit)&quot;);            System.out.println(&quot;a(add)&quot;);            System.out.println(&quot;g(get)&quot;);            System.out.println(&quot;h(head)&quot;);            key &#x3D; scan.next().charAt(0);            switch (key) &#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;output a num:&quot;);                    int value &#x3D; scan.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.printf(&quot;get the num is: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                        break;                    &#125;                    break;                case &#39;h&#39;:                    &#x2F;&#x2F;查看队列头数据                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.printf(&quot;head data: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:&#x2F;&#x2F;退出                    scan.close();                    loop &#x3D; false;&#x2F;&#x2F;退出while循环                    break;                default:                    break;            &#125;        &#125;    &#125;&#125;class ArrayQueue &#123;    private int maxSize;&#x2F;&#x2F;数组最大容量    private int front;&#x2F;&#x2F;队列头    private int rear;&#x2F;&#x2F;队列尾    private int[] arr;&#x2F;&#x2F;该数组用于存放数据，模拟队列    &#x2F;&#x2F;创建队列的构造器    public ArrayQueue(int arrMaxSize) &#123;        maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];        front &#x3D; -1;&#x2F;&#x2F;指向队列头部，指向数据头部前一个位置        rear &#x3D; -1;&#x2F;&#x2F;指向队列尾，指向队列尾的数据(即队列最后一个数据)    &#125;    &#x2F;&#x2F;判断队列是否满    public boolean isFull() &#123;        return rear &#x3D;&#x3D; maxSize - 1;    &#125;    &#x2F;&#x2F;判断队列是否空    public boolean isEmpty() &#123;        return rear &#x3D;&#x3D; front;    &#125;    &#x2F;&#x2F;添加数据到队列    public void addQueue(int n) &#123;        &#x2F;&#x2F;判断队列是否满        if (isFull()) &#123;            System.out.println(&quot;the queue is full~~&quot;);            return;        &#125;        &#x2F;&#x2F;rear++;&#x2F;&#x2F;rear后移        &#x2F;&#x2F;arr[rear] &#x3D; n;        arr[++rear] &#x3D; n;&#x2F;&#x2F;这是上两行代码简写    &#125;    &#x2F;&#x2F;获取队列数据，出队列    public int getQueue() &#123;        &#x2F;&#x2F;判断是否为空        if (isEmpty()) &#123;            &#x2F;&#x2F;抛出异常            throw new RuntimeException(&quot;empty queue~~&quot;);        &#125;        front++;        return arr[front];    &#125;    &#x2F;&#x2F;显示队列所有数据    public void showQueue() &#123;        if (isEmpty()) &#123;            System.out.println(&quot;empty queue~~&quot;);            return;        &#125;        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i, arr[i]);        &#125;    &#125;    &#x2F;&#x2F;显示队列的头数据，不是取出数据    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty queue~~&quot;);        &#125;        return arr[front + 1];&#x2F;&#x2F;使front指向头数据    &#125;&#125;</code></pre><p>缺点：</p><ul><li>数组只能用一次</li></ul><p>优化：</p><ul><li>改进成为环形队列 算法思想：取模%</li></ul><h3 id="数组模拟环形队列">数组模拟环形队列</h3><p>思路：</p><ul><li>front变量含义做一个调整：front指向队列第一个元素，也就是<code>arr[front]</code>就是队列第一个元素</li><li>rear变量含义做一个调整：rear指向队列最后一个元素的后一个位置。留出一个空间来判断队列是空或满</li><li>当队列满时，条件是：<code>(rear+1)&amp;maxSize == front</code> =&gt;队列满</li></ul><p>队列中有效数据的个数 <code>(rear + maxSize - front) % maxSize</code></p><h4 id="代码-1">代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class CircleArrayQueue &#123;    public static void main(String[] args) &#123;        CircleArray queue &#x3D; new CircleArray(4);&#x2F;&#x2F;队列有效数据是3        char key &#x3D; &#39; &#39;;        Scanner scan &#x3D; new Scanner(System.in);        boolean loop &#x3D; true;        &#x2F;&#x2F;输出一个菜单        while (loop) &#123;            System.out.println(&quot;s(show queue)&quot;);            System.out.println(&quot;e(exit)&quot;);            System.out.println(&quot;a(add)&quot;);            System.out.println(&quot;g(get)&quot;);            System.out.println(&quot;h(head)&quot;);            key &#x3D; scan.next().charAt(0);            switch (key) &#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;output a num:&quot;);                    int value &#x3D; scan.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.printf(&quot;get the num is: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                        break;                    &#125;                    break;                case &#39;h&#39;:                    &#x2F;&#x2F;查看队列头数据                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.printf(&quot;head data: %d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        &#x2F;&#x2F;TODO: handle exception                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:                    scan.close();                    loop &#x3D; false;                    break;                default:                    break;            &#125;        &#125;    &#125;&#125;class CircleArray &#123;    private int maxSize;&#x2F;&#x2F;数组最大容量    private int front;&#x2F;&#x2F;队列头，队列的第一个元素，不一定是0    private int rear;&#x2F;&#x2F;队列尾    private int[] arr;&#x2F;&#x2F;该数组用于存放数据，模拟队列    public CircleArray(int arrMaxSize) &#123;        maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];        front &#x3D; 0;        rear &#x3D; 0;    &#125;    public boolean isFull() &#123;        return (rear + 1) % maxSize &#x3D;&#x3D; front;&#x2F;&#x2F;+1是利用了留出的空位来判断队列是否为满    &#125;    public boolean isEmpty() &#123;        return rear &#x3D;&#x3D; front;&#x2F;&#x2F;初始化时rear和front都是0，如果没有add，即可判断为空    &#125;    public void addQueue(int n) &#123;        if (isFull()) &#123;            System.out.println(&quot;full array~~&quot;);            return;        &#125;        arr[rear] &#x3D; n;&#x2F;&#x2F;直接把n赋给arr        rear &#x3D; (rear + 1) % maxSize;&#x2F;&#x2F;考虑取模    &#125;    public int getQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty array~~&quot;);        &#125;        &#x2F;&#x2F;这里要分析出front是指向队列的第一个元素        &#x2F;&#x2F;1.先把front对应的值保留到一个临时变量        &#x2F;&#x2F;2.把front后移        &#x2F;&#x2F;3.把临时保存的变量返回        int value &#x3D; arr[front];            front &#x3D; (front + 1) % maxSize;        return value;    &#125;    public void showQueue() &#123;        if (isEmpty()) &#123;            System.out.println(&quot;empty array~~&quot;);            return;        &#125;        for (int i &#x3D; front; i &lt; front + size(); i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i % maxSize, arr[i % maxSize]);        &#125;    &#125;    &#x2F;&#x2F;求出当前队列有效数据个数    public int size() &#123;        return (rear + maxSize - front) % maxSize;    &#125;    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;empty array~~&quot;);        &#125;        return arr[front];    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">简单记录稀疏数组的用法</summary>
    
    
    
    <category term="Java" scheme="https://jaydenchang.top/categories/Java/"/>
    
    
    <category term="数据结构" scheme="https://jaydenchang.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Java" scheme="https://jaydenchang.top/tags/Java/"/>
    
  </entry>
  
</feed>
